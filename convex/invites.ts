import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

// 24 hours in milliseconds
const INVITE_EXPIRY_MS = 24 * 60 * 60 * 1000;

/**
 * Create an invite for a list.
 * Generates a unique token valid for 24 hours.
 */
export const createInvite = mutation({
  args: {
    listId: v.id("lists"),
    token: v.string(), // Generated by frontend (crypto.randomUUID())
    createdAt: v.number(),
  },
  handler: async (ctx, args) => {
    // Verify the list exists
    const list = await ctx.db.get(args.listId);
    if (!list) {
      throw new Error("List not found");
    }

    // Check if list already has a collaborator
    if (list.collaboratorDid) {
      throw new Error("This list already has a collaborator");
    }

    return await ctx.db.insert("invites", {
      listId: args.listId,
      token: args.token,
      createdAt: args.createdAt,
      expiresAt: args.createdAt + INVITE_EXPIRY_MS,
      usedAt: undefined,
      usedByDid: undefined,
    });
  },
});

/**
 * Validate an invite token.
 * Checks: exists, not expired, not used, list has < 2 collaborators.
 */
export const validateInvite = query({
  args: {
    listId: v.id("lists"),
    token: v.string(),
    currentTime: v.number(),
  },
  handler: async (ctx, args) => {
    // Find the invite
    const invite = await ctx.db
      .query("invites")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();

    if (!invite) {
      return { valid: false, error: "Invite not found" };
    }

    // Check if invite is for the correct list
    if (invite.listId !== args.listId) {
      return { valid: false, error: "Invite not found" };
    }

    // Check if expired
    if (args.currentTime > invite.expiresAt) {
      return { valid: false, error: "This invite has expired" };
    }

    // Check if already used
    if (invite.usedAt) {
      return { valid: false, error: "This invite has already been used" };
    }

    // Check if list exists and doesn't already have a collaborator
    const list = await ctx.db.get(args.listId);
    if (!list) {
      return { valid: false, error: "List not found" };
    }

    if (list.collaboratorDid) {
      return { valid: false, error: "This list already has a collaborator" };
    }

    return {
      valid: true,
      listName: list.name,
      ownerDid: list.ownerDid,
    };
  },
});

/**
 * Accept an invite.
 * Marks the invite as used and adds the user as a collaborator.
 */
export const acceptInvite = mutation({
  args: {
    listId: v.id("lists"),
    token: v.string(),
    userDid: v.string(),
    currentTime: v.number(),
  },
  handler: async (ctx, args) => {
    // Find the invite
    const invite = await ctx.db
      .query("invites")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();

    if (!invite) {
      throw new Error("Invite not found");
    }

    // Verify invite is for the correct list
    if (invite.listId !== args.listId) {
      throw new Error("Invite not found");
    }

    // Check if expired
    if (args.currentTime > invite.expiresAt) {
      throw new Error("This invite has expired");
    }

    // Check if already used
    if (invite.usedAt) {
      throw new Error("This invite has already been used");
    }

    // Check if list exists
    const list = await ctx.db.get(args.listId);
    if (!list) {
      throw new Error("List not found");
    }

    // Check if user is the owner (can't join your own list)
    if (list.ownerDid === args.userDid) {
      throw new Error("You cannot join your own list");
    }

    // Check if list already has a collaborator
    if (list.collaboratorDid) {
      throw new Error("This list already has a collaborator");
    }

    // Mark invite as used
    await ctx.db.patch(invite._id, {
      usedAt: args.currentTime,
      usedByDid: args.userDid,
    });

    // Add collaborator to list
    await ctx.db.patch(args.listId, {
      collaboratorDid: args.userDid,
    });
  },
});

/**
 * Get an invite by token (for display purposes).
 */
export const getInviteByToken = query({
  args: { token: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("invites")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();
  },
});
