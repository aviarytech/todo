import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

// 24 hours in milliseconds
const INVITE_EXPIRY_MS = 24 * 60 * 60 * 1000;

/**
 * Create an invite for a list.
 * Generates a unique token valid for 24 hours.
 * Now supports role-based invites (Phase 3).
 */
export const createInvite = mutation({
  args: {
    listId: v.id("lists"),
    token: v.string(), // Generated by frontend (crypto.randomUUID())
    role: v.optional(v.union(v.literal("editor"), v.literal("viewer"))), // Role to grant (defaults to editor)
    createdAt: v.number(),
  },
  handler: async (ctx, args) => {
    // Verify the list exists
    const list = await ctx.db.get(args.listId);
    if (!list) {
      throw new Error("List not found");
    }

    // Note: Removed the single-collaborator check for unlimited collaborators (Phase 3)

    return await ctx.db.insert("invites", {
      listId: args.listId,
      token: args.token,
      role: args.role ?? "editor", // Default to editor for backwards compat
      createdAt: args.createdAt,
      expiresAt: args.createdAt + INVITE_EXPIRY_MS,
      usedAt: undefined,
      usedByDid: undefined,
    });
  },
});

/**
 * Validate an invite token.
 * Checks: exists, not expired, not used.
 * Updated for unlimited collaborators (Phase 3).
 */
export const validateInvite = query({
  args: {
    listId: v.id("lists"),
    token: v.string(),
    currentTime: v.number(),
    userDid: v.optional(v.string()), // To check if already a collaborator
  },
  handler: async (ctx, args) => {
    // Find the invite
    const invite = await ctx.db
      .query("invites")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();

    if (!invite) {
      return { valid: false, error: "Invite not found" };
    }

    // Check if invite is for the correct list
    if (invite.listId !== args.listId) {
      return { valid: false, error: "Invite not found" };
    }

    // Check if expired
    if (args.currentTime > invite.expiresAt) {
      return { valid: false, error: "This invite has expired" };
    }

    // Check if already used
    if (invite.usedAt) {
      return { valid: false, error: "This invite has already been used" };
    }

    // Check if list exists
    const list = await ctx.db.get(args.listId);
    if (!list) {
      return { valid: false, error: "List not found" };
    }

    // Check if user is already a collaborator (if userDid provided)
    if (args.userDid) {
      const userDid = args.userDid; // Type narrowing
      const existing = await ctx.db
        .query("collaborators")
        .withIndex("by_list_user", (q) =>
          q.eq("listId", args.listId).eq("userDid", userDid)
        )
        .first();

      if (existing) {
        return {
          valid: false,
          error: "You are already a collaborator on this list",
        };
      }
    }

    return {
      valid: true,
      listName: list.name,
      ownerDid: list.ownerDid,
      role: invite.role ?? "editor", // Return the role the invite grants
    };
  },
});

/**
 * Accept an invite.
 * Marks the invite as used and adds the user as a collaborator.
 * Updated for unlimited collaborators with roles (Phase 3).
 */
export const acceptInvite = mutation({
  args: {
    listId: v.id("lists"),
    token: v.string(),
    userDid: v.string(),
    currentTime: v.number(),
  },
  handler: async (ctx, args) => {
    // Find the invite
    const invite = await ctx.db
      .query("invites")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();

    if (!invite) {
      throw new Error("Invite not found");
    }

    // Verify invite is for the correct list
    if (invite.listId !== args.listId) {
      throw new Error("Invite not found");
    }

    // Check if expired
    if (args.currentTime > invite.expiresAt) {
      throw new Error("This invite has expired");
    }

    // Check if already used
    if (invite.usedAt) {
      throw new Error("This invite has already been used");
    }

    // Check if list exists
    const list = await ctx.db.get(args.listId);
    if (!list) {
      throw new Error("List not found");
    }

    // Check if user is the owner (can't join your own list)
    if (list.ownerDid === args.userDid) {
      throw new Error("You cannot join your own list");
    }

    // Check if user is already a collaborator (Phase 3)
    const existing = await ctx.db
      .query("collaborators")
      .withIndex("by_list_user", (q) =>
        q.eq("listId", args.listId).eq("userDid", args.userDid)
      )
      .first();

    if (existing) {
      throw new Error("You are already a collaborator on this list");
    }

    // Mark invite as used
    await ctx.db.patch(invite._id, {
      usedAt: args.currentTime,
      usedByDid: args.userDid,
    });

    // Add collaborator to collaborators table (Phase 3)
    const role = invite.role ?? "editor";
    await ctx.db.insert("collaborators", {
      listId: args.listId,
      userDid: args.userDid,
      role,
      joinedAt: args.currentTime,
      invitedByDid: list.ownerDid,
    });
  },
});

/**
 * Get an invite by token (for display purposes).
 */
export const getInviteByToken = query({
  args: { token: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("invites")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();
  },
});
