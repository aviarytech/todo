/**
 * Convex HTTP router for server-side endpoints.
 *
 * Phase 8: Server-side authentication endpoints and protected mutations.
 */

import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { internal, api } from "./_generated/api";
import { createList, deleteList } from "./listsHttp";
import {
  createCategory,
  renameCategory,
  deleteCategory,
  setListCategory,
} from "./categoriesHttp";
import {
  addItem,
  checkItem,
  uncheckItem,
  removeItem,
  reorderItems,
} from "./itemsHttp";
import {
  addCollaborator,
  updateCollaboratorRole,
  removeCollaborator,
} from "./collaboratorsHttp";

// Rate limit configuration
const RATE_LIMITS = {
  initiate: { windowMs: 60000, maxAttempts: 5 },
  verify: { windowMs: 60000, maxAttempts: 5 },
};

/**
 * Helper to extract client IP from request headers.
 */
function getClientIp(request: Request): string {
  const forwardedFor = request.headers.get("x-forwarded-for");
  if (forwardedFor) {
    return forwardedFor.split(",")[0].trim();
  }
  const realIp = request.headers.get("x-real-ip");
  if (realIp) {
    return realIp.trim();
  }
  const cfConnectingIp = request.headers.get("cf-connecting-ip");
  if (cfConnectingIp) {
    return cfConnectingIp.trim();
  }
  return "unknown-ip";
}

/**
 * CORS headers for all responses.
 */
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

/**
 * Create a JSON response with CORS headers.
 */
function jsonResponse(data: unknown, status = 200, extraHeaders: Record<string, string> = {}): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      ...corsHeaders,
      ...extraHeaders,
    },
  });
}

/**
 * Create a 429 Too Many Requests response.
 */
function createRateLimitResponse(retryAfterMs: number): Response {
  const retryAfterSeconds = Math.ceil(retryAfterMs / 1000);
  return jsonResponse(
    { error: "Too many requests. Please try again later.", retryAfterSeconds },
    429,
    { "Retry-After": String(retryAfterSeconds) }
  );
}

// ============================================================================
// Auth HTTP Actions (call Node.js internal actions)
// ============================================================================

/**
 * POST /auth/initiate - Send OTP to user's email
 */
const initiate = httpAction(async (ctx, request) => {
  try {
    const clientIp = getClientIp(request);
    const rateLimitResult = await ctx.runMutation(api.rateLimits.checkAndIncrement, {
      key: clientIp,
      endpoint: "initiate",
    });

    if (!rateLimitResult.allowed) {
      console.log(`[authHttp] Rate limit exceeded for IP: ${clientIp}`);
      return createRateLimitResponse(rateLimitResult.retryAfterMs ?? RATE_LIMITS.initiate.windowMs);
    }

    const body = await request.json();
    const email = body.email as string;

    if (!email) {
      return jsonResponse({ error: "Email is required" }, 400);
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return jsonResponse({ error: "Invalid email format" }, 400);
    }

    console.log(`[authHttp] Initiating auth for: ${email} (IP: ${clientIp})`);

    // Call internal Node.js action
    const result = await ctx.runAction(internal.authInternal.initiateAuth, { email });

    // Persist session to Convex database
    await ctx.runMutation(api.authSessions.createSession, {
      sessionId: result.sessionId,
      email: result.session.email,
      subOrgId: result.session.subOrgId,
      otpId: result.session.otpId,
    });

    console.log(`[authHttp] Session created: ${result.sessionId}`);

    return jsonResponse({
      sessionId: result.sessionId,
      message: result.message,
    });
  } catch (error) {
    console.error("[authHttp] Initiate error:", error);
    return jsonResponse(
      { error: error instanceof Error ? error.message : "Failed to initiate auth" },
      500
    );
  }
});

/**
 * POST /auth/verify - Verify OTP and issue JWT
 */
const verify = httpAction(async (ctx, request) => {
  try {
    const body = await request.json();
    const sessionId = body.sessionId as string;
    const code = body.code as string;

    if (!sessionId || !code) {
      return jsonResponse({ error: "Session ID and code are required" }, 400);
    }

    const rateLimitResult = await ctx.runMutation(api.rateLimits.checkAndIncrement, {
      key: sessionId,
      endpoint: "verify",
    });

    if (!rateLimitResult.allowed) {
      console.log(`[authHttp] Rate limit exceeded for session: ${sessionId}`);
      return createRateLimitResponse(rateLimitResult.retryAfterMs ?? RATE_LIMITS.verify.windowMs);
    }

    console.log(`[authHttp] Verifying OTP for session: ${sessionId}`);

    // Get session from database
    const dbSession = await ctx.runQuery(api.authSessions.getSession, { sessionId });
    if (!dbSession) {
      return jsonResponse({ error: "Invalid or expired session" }, 400);
    }

    // Validate required session fields
    if (!dbSession.subOrgId || !dbSession.otpId) {
      return jsonResponse({ error: "Invalid session state" }, 400);
    }

    // Call internal Node.js action
    const result = await ctx.runAction(internal.authInternal.verifyAuth, {
      sessionId,
      code,
      session: {
        email: dbSession.email,
        subOrgId: dbSession.subOrgId,
        otpId: dbSession.otpId,
        timestamp: dbSession.timestamp,
        verified: dbSession.verified,
      },
    });

    if (!result.verified || !result.email || !result.subOrgId) {
      return jsonResponse({ error: "Verification failed" }, 400);
    }

    console.log(`[authHttp] OTP verified for: ${result.email}`);

    // Mark session as verified
    await ctx.runMutation(api.authSessions.markSessionVerified, {
      sessionId,
      subOrgId: result.subOrgId,
    });

    // Create/update user
    const tempDid = `did:temp:${result.subOrgId}`;
    await ctx.runMutation(api.auth.upsertUser, {
      turnkeySubOrgId: result.subOrgId,
      email: result.email,
      did: tempDid,
      displayName: result.email.split("@")[0],
    });

    // Get JWT token via internal action
    const authResult = await ctx.runAction(internal.authInternal.createAuthToken, {
      subOrgId: result.subOrgId,
      email: result.email,
    });

    // Clean up session
    await ctx.runMutation(api.authSessions.deleteSession, { sessionId });

    console.log(`[authHttp] Auth complete, JWT issued for: ${result.email}`);

    return jsonResponse(
      {
        token: authResult.token,
        user: {
          turnkeySubOrgId: result.subOrgId,
          email: result.email,
          displayName: result.email.split("@")[0],
        },
      },
      200,
      { "Set-Cookie": authResult.cookieValue }
    );
  } catch (error) {
    console.error("[authHttp] Verify error:", error);
    return jsonResponse(
      { error: error instanceof Error ? error.message : "Verification failed" },
      500
    );
  }
});

/**
 * POST /auth/logout - Clear auth cookie
 */
const logout = httpAction(async (ctx) => {
  console.log("[authHttp] Logging out");

  const result = await ctx.runAction(internal.authInternal.getLogoutCookie, {});

  return jsonResponse({ success: true }, 200, { "Set-Cookie": result.cookieValue });
});

const http = httpRouter();

// Auth endpoints
http.route({
  path: "/auth/initiate",
  method: "POST",
  handler: initiate,
});

http.route({
  path: "/auth/verify",
  method: "POST",
  handler: verify,
});

http.route({
  path: "/auth/logout",
  method: "POST",
  handler: logout,
});

// CORS preflight handler
const corsHandler = httpAction(async () => {
  return new Response(null, {
    status: 204,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Max-Age": "86400",
    },
  });
});

// CORS preflight handling for all auth routes
http.route({ path: "/auth/initiate", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/auth/verify", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/auth/logout", method: "OPTIONS", handler: corsHandler });

// ============================================================================
// Protected API endpoints (Phase 8.3)
// All endpoints below require JWT authentication via Authorization header.
// ============================================================================

// --- List endpoints ---
http.route({ path: "/api/lists/create", method: "POST", handler: createList });
http.route({ path: "/api/lists/create", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/lists/delete", method: "POST", handler: deleteList });
http.route({ path: "/api/lists/delete", method: "OPTIONS", handler: corsHandler });

// --- Category endpoints ---
http.route({ path: "/api/categories/create", method: "POST", handler: createCategory });
http.route({ path: "/api/categories/create", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/categories/rename", method: "POST", handler: renameCategory });
http.route({ path: "/api/categories/rename", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/categories/delete", method: "POST", handler: deleteCategory });
http.route({ path: "/api/categories/delete", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/categories/setListCategory", method: "POST", handler: setListCategory });
http.route({ path: "/api/categories/setListCategory", method: "OPTIONS", handler: corsHandler });

// --- Item endpoints ---
http.route({ path: "/api/items/add", method: "POST", handler: addItem });
http.route({ path: "/api/items/add", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/items/check", method: "POST", handler: checkItem });
http.route({ path: "/api/items/check", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/items/uncheck", method: "POST", handler: uncheckItem });
http.route({ path: "/api/items/uncheck", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/items/remove", method: "POST", handler: removeItem });
http.route({ path: "/api/items/remove", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/items/reorder", method: "POST", handler: reorderItems });
http.route({ path: "/api/items/reorder", method: "OPTIONS", handler: corsHandler });

// --- Collaborator endpoints ---
http.route({ path: "/api/collaborators/add", method: "POST", handler: addCollaborator });
http.route({ path: "/api/collaborators/add", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/collaborators/updateRole", method: "POST", handler: updateCollaboratorRole });
http.route({ path: "/api/collaborators/updateRole", method: "OPTIONS", handler: corsHandler });
http.route({ path: "/api/collaborators/remove", method: "POST", handler: removeCollaborator });
http.route({ path: "/api/collaborators/remove", method: "OPTIONS", handler: corsHandler });

export default http;
