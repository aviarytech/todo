const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-Yf-itXSD.js","assets/react-vendor-BToC6Ez8.js"])))=>i.map(i=>d[i]);
import{p as dn,g as Kd,c as ka,a as Vd}from"./react-vendor-BToC6Ez8.js";function Gd(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const a in r)if(a!=="default"&&!(a in e)){const o=Object.getOwnPropertyDescriptor(r,a);o&&Object.defineProperty(e,a,o.get?o:{enumerable:!0,get:()=>r[a]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}const Wd="modulepreload",$d=function(e){return"/"+e},Oa={},ln=function(t,n,r){let a=Promise.resolve();if(n&&n.length>0){let c=function(l){return Promise.all(l.map(u=>Promise.resolve(u).then(d=>({status:"fulfilled",value:d}),d=>({status:"rejected",reason:d}))))};document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),s=i?.nonce||i?.getAttribute("nonce");a=c(n.map(l=>{if(l=$d(l),l in Oa)return;Oa[l]=!0;const u=l.endsWith(".css"),d=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${d}`))return;const h=document.createElement("link");if(h.rel=u?"stylesheet":Wd,u||(h.as="script"),h.crossOrigin="",h.href=l,s&&h.setAttribute("nonce",s),document.head.appendChild(h),u)return new Promise((f,y)=>{h.addEventListener("load",f),h.addEventListener("error",()=>y(new Error(`Unable to preload CSS for ${l}`)))})}))}function o(i){const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=i,window.dispatchEvent(s),!s.defaultPrevented)throw i}return a.then(i=>{for(const s of i||[])s.status==="rejected"&&o(s.reason);return t().catch(o)})};var Ds={},Pi={};Pi.byteLength=Jd;Pi.toByteArray=Zd;Pi.fromByteArray=th;var _t=[],at=[],Xd=typeof Uint8Array<"u"?Uint8Array:Array,Xi="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var Qr=0,zd=Xi.length;Qr<zd;++Qr)_t[Qr]=Xi[Qr],at[Xi.charCodeAt(Qr)]=Qr;at[45]=62;at[95]=63;function Df(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");n===-1&&(n=t);var r=n===t?0:4-n%4;return[n,r]}function Jd(e){var t=Df(e),n=t[0],r=t[1];return(n+r)*3/4-r}function Yd(e,t,n){return(t+n)*3/4-n}function Zd(e){var t,n=Df(e),r=n[0],a=n[1],o=new Xd(Yd(e,r,a)),i=0,s=a>0?r-4:r,c;for(c=0;c<s;c+=4)t=at[e.charCodeAt(c)]<<18|at[e.charCodeAt(c+1)]<<12|at[e.charCodeAt(c+2)]<<6|at[e.charCodeAt(c+3)],o[i++]=t>>16&255,o[i++]=t>>8&255,o[i++]=t&255;return a===2&&(t=at[e.charCodeAt(c)]<<2|at[e.charCodeAt(c+1)]>>4,o[i++]=t&255),a===1&&(t=at[e.charCodeAt(c)]<<10|at[e.charCodeAt(c+1)]<<4|at[e.charCodeAt(c+2)]>>2,o[i++]=t>>8&255,o[i++]=t&255),o}function Qd(e){return _t[e>>18&63]+_t[e>>12&63]+_t[e>>6&63]+_t[e&63]}function eh(e,t,n){for(var r,a=[],o=t;o<n;o+=3)r=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(e[o+2]&255),a.push(Qd(r));return a.join("")}function th(e){for(var t,n=e.length,r=n%3,a=[],o=16383,i=0,s=n-r;i<s;i+=o)a.push(eh(e,i,i+o>s?s:i+o));return r===1?(t=e[n-1],a.push(_t[t>>2]+_t[t<<4&63]+"==")):r===2&&(t=(e[n-2]<<8)+e[n-1],a.push(_t[t>>10]+_t[t>>4&63]+_t[t<<2&63]+"=")),a.join("")}var Ns={};Ns.read=function(e,t,n,r,a){var o,i,s=a*8-r-1,c=(1<<s)-1,l=c>>1,u=-7,d=n?a-1:0,h=n?-1:1,f=e[t+d];for(d+=h,o=f&(1<<-u)-1,f>>=-u,u+=s;u>0;o=o*256+e[t+d],d+=h,u-=8);for(i=o&(1<<-u)-1,o>>=-u,u+=r;u>0;i=i*256+e[t+d],d+=h,u-=8);if(o===0)o=1-l;else{if(o===c)return i?NaN:(f?-1:1)*(1/0);i=i+Math.pow(2,r),o=o-l}return(f?-1:1)*i*Math.pow(2,o-r)};Ns.write=function(e,t,n,r,a,o){var i,s,c,l=o*8-a-1,u=(1<<l)-1,d=u>>1,h=a===23?Math.pow(2,-24)-Math.pow(2,-77):0,f=r?0:o-1,y=r?1:-1,g=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,i=u):(i=Math.floor(Math.log(t)/Math.LN2),t*(c=Math.pow(2,-i))<1&&(i--,c*=2),i+d>=1?t+=h/c:t+=h*Math.pow(2,1-d),t*c>=2&&(i++,c/=2),i+d>=u?(s=0,i=u):i+d>=1?(s=(t*c-1)*Math.pow(2,a),i=i+d):(s=t*Math.pow(2,d-1)*Math.pow(2,a),i=0));a>=8;e[n+f]=s&255,f+=y,s/=256,a-=8);for(i=i<<a|s,l+=a;l>0;e[n+f]=i&255,f+=y,i/=256,l-=8);e[n+f-y]|=g*128};(function(e){const t=Pi,n=Ns,r=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;e.Buffer=u,e.SlowBuffer=x,e.INSPECT_MAX_BYTES=50;const a=2147483647;e.kMaxLength=a;const{Uint8Array:o,ArrayBuffer:i,SharedArrayBuffer:s}=globalThis;u.TYPED_ARRAY_SUPPORT=c(),!u.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function c(){try{const v=new o(1),p={foo:function(){return 42}};return Object.setPrototypeOf(p,o.prototype),Object.setPrototypeOf(v,p),v.foo()===42}catch{return!1}}Object.defineProperty(u.prototype,"parent",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.buffer}}),Object.defineProperty(u.prototype,"offset",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.byteOffset}});function l(v){if(v>a)throw new RangeError('The value "'+v+'" is invalid for option "size"');const p=new o(v);return Object.setPrototypeOf(p,u.prototype),p}function u(v,p,m){if(typeof v=="number"){if(typeof p=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return y(v)}return d(v,p,m)}u.poolSize=8192;function d(v,p,m){if(typeof v=="string")return g(v,p);if(i.isView(v))return B(v);if(v==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof v);if(Fe(v,i)||v&&Fe(v.buffer,i)||typeof s<"u"&&(Fe(v,s)||v&&Fe(v.buffer,s)))return I(v,p,m);if(typeof v=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const M=v.valueOf&&v.valueOf();if(M!=null&&M!==v)return u.from(M,p,m);const G=b(v);if(G)return G;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof v[Symbol.toPrimitive]=="function")return u.from(v[Symbol.toPrimitive]("string"),p,m);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof v)}u.from=function(v,p,m){return d(v,p,m)},Object.setPrototypeOf(u.prototype,o.prototype),Object.setPrototypeOf(u,o);function h(v){if(typeof v!="number")throw new TypeError('"size" argument must be of type number');if(v<0)throw new RangeError('The value "'+v+'" is invalid for option "size"')}function f(v,p,m){return h(v),v<=0?l(v):p!==void 0?typeof m=="string"?l(v).fill(p,m):l(v).fill(p):l(v)}u.alloc=function(v,p,m){return f(v,p,m)};function y(v){return h(v),l(v<0?0:w(v)|0)}u.allocUnsafe=function(v){return y(v)},u.allocUnsafeSlow=function(v){return y(v)};function g(v,p){if((typeof p!="string"||p==="")&&(p="utf8"),!u.isEncoding(p))throw new TypeError("Unknown encoding: "+p);const m=_(v,p)|0;let M=l(m);const G=M.write(v,p);return G!==m&&(M=M.slice(0,G)),M}function S(v){const p=v.length<0?0:w(v.length)|0,m=l(p);for(let M=0;M<p;M+=1)m[M]=v[M]&255;return m}function B(v){if(Fe(v,o)){const p=new o(v);return I(p.buffer,p.byteOffset,p.byteLength)}return S(v)}function I(v,p,m){if(p<0||v.byteLength<p)throw new RangeError('"offset" is outside of buffer bounds');if(v.byteLength<p+(m||0))throw new RangeError('"length" is outside of buffer bounds');let M;return p===void 0&&m===void 0?M=new o(v):m===void 0?M=new o(v,p):M=new o(v,p,m),Object.setPrototypeOf(M,u.prototype),M}function b(v){if(u.isBuffer(v)){const p=w(v.length)|0,m=l(p);return m.length===0||v.copy(m,0,0,p),m}if(v.length!==void 0)return typeof v.length!="number"||Ot(v.length)?l(0):S(v);if(v.type==="Buffer"&&Array.isArray(v.data))return S(v.data)}function w(v){if(v>=a)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a.toString(16)+" bytes");return v|0}function x(v){return+v!=v&&(v=0),u.alloc(+v)}u.isBuffer=function(p){return p!=null&&p._isBuffer===!0&&p!==u.prototype},u.compare=function(p,m){if(Fe(p,o)&&(p=u.from(p,p.offset,p.byteLength)),Fe(m,o)&&(m=u.from(m,m.offset,m.byteLength)),!u.isBuffer(p)||!u.isBuffer(m))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(p===m)return 0;let M=p.length,G=m.length;for(let Z=0,ee=Math.min(M,G);Z<ee;++Z)if(p[Z]!==m[Z]){M=p[Z],G=m[Z];break}return M<G?-1:G<M?1:0},u.isEncoding=function(p){switch(String(p).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(p,m){if(!Array.isArray(p))throw new TypeError('"list" argument must be an Array of Buffers');if(p.length===0)return u.alloc(0);let M;if(m===void 0)for(m=0,M=0;M<p.length;++M)m+=p[M].length;const G=u.allocUnsafe(m);let Z=0;for(M=0;M<p.length;++M){let ee=p[M];if(Fe(ee,o))Z+ee.length>G.length?(u.isBuffer(ee)||(ee=u.from(ee)),ee.copy(G,Z)):o.prototype.set.call(G,ee,Z);else if(u.isBuffer(ee))ee.copy(G,Z);else throw new TypeError('"list" argument must be an Array of Buffers');Z+=ee.length}return G};function _(v,p){if(u.isBuffer(v))return v.length;if(i.isView(v)||Fe(v,i))return v.byteLength;if(typeof v!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof v);const m=v.length,M=arguments.length>2&&arguments[2]===!0;if(!M&&m===0)return 0;let G=!1;for(;;)switch(p){case"ascii":case"latin1":case"binary":return m;case"utf8":case"utf-8":return dt(v).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return m*2;case"hex":return m>>>1;case"base64":return Ne(v).length;default:if(G)return M?-1:dt(v).length;p=(""+p).toLowerCase(),G=!0}}u.byteLength=_;function N(v,p,m){let M=!1;if((p===void 0||p<0)&&(p=0),p>this.length||((m===void 0||m>this.length)&&(m=this.length),m<=0)||(m>>>=0,p>>>=0,m<=p))return"";for(v||(v="utf8");;)switch(v){case"hex":return J(this,p,m);case"utf8":case"utf-8":return V(this,p,m);case"ascii":return D(this,p,m);case"latin1":case"binary":return W(this,p,m);case"base64":return U(this,p,m);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return re(this,p,m);default:if(M)throw new TypeError("Unknown encoding: "+v);v=(v+"").toLowerCase(),M=!0}}u.prototype._isBuffer=!0;function k(v,p,m){const M=v[p];v[p]=v[m],v[m]=M}u.prototype.swap16=function(){const p=this.length;if(p%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let m=0;m<p;m+=2)k(this,m,m+1);return this},u.prototype.swap32=function(){const p=this.length;if(p%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let m=0;m<p;m+=4)k(this,m,m+3),k(this,m+1,m+2);return this},u.prototype.swap64=function(){const p=this.length;if(p%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let m=0;m<p;m+=8)k(this,m,m+7),k(this,m+1,m+6),k(this,m+2,m+5),k(this,m+3,m+4);return this},u.prototype.toString=function(){const p=this.length;return p===0?"":arguments.length===0?V(this,0,p):N.apply(this,arguments)},u.prototype.toLocaleString=u.prototype.toString,u.prototype.equals=function(p){if(!u.isBuffer(p))throw new TypeError("Argument must be a Buffer");return this===p?!0:u.compare(this,p)===0},u.prototype.inspect=function(){let p="";const m=e.INSPECT_MAX_BYTES;return p=this.toString("hex",0,m).replace(/(.{2})/g,"$1 ").trim(),this.length>m&&(p+=" ... "),"<Buffer "+p+">"},r&&(u.prototype[r]=u.prototype.inspect),u.prototype.compare=function(p,m,M,G,Z){if(Fe(p,o)&&(p=u.from(p,p.offset,p.byteLength)),!u.isBuffer(p))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof p);if(m===void 0&&(m=0),M===void 0&&(M=p?p.length:0),G===void 0&&(G=0),Z===void 0&&(Z=this.length),m<0||M>p.length||G<0||Z>this.length)throw new RangeError("out of range index");if(G>=Z&&m>=M)return 0;if(G>=Z)return-1;if(m>=M)return 1;if(m>>>=0,M>>>=0,G>>>=0,Z>>>=0,this===p)return 0;let ee=Z-G,le=M-m;const we=Math.min(ee,le),me=this.slice(G,Z),ve=p.slice(m,M);for(let Ee=0;Ee<we;++Ee)if(me[Ee]!==ve[Ee]){ee=me[Ee],le=ve[Ee];break}return ee<le?-1:le<ee?1:0};function T(v,p,m,M,G){if(v.length===0)return-1;if(typeof m=="string"?(M=m,m=0):m>2147483647?m=2147483647:m<-2147483648&&(m=-2147483648),m=+m,Ot(m)&&(m=G?0:v.length-1),m<0&&(m=v.length+m),m>=v.length){if(G)return-1;m=v.length-1}else if(m<0)if(G)m=0;else return-1;if(typeof p=="string"&&(p=u.from(p,M)),u.isBuffer(p))return p.length===0?-1:L(v,p,m,M,G);if(typeof p=="number")return p=p&255,typeof o.prototype.indexOf=="function"?G?o.prototype.indexOf.call(v,p,m):o.prototype.lastIndexOf.call(v,p,m):L(v,[p],m,M,G);throw new TypeError("val must be string, number or Buffer")}function L(v,p,m,M,G){let Z=1,ee=v.length,le=p.length;if(M!==void 0&&(M=String(M).toLowerCase(),M==="ucs2"||M==="ucs-2"||M==="utf16le"||M==="utf-16le")){if(v.length<2||p.length<2)return-1;Z=2,ee/=2,le/=2,m/=2}function we(ve,Ee){return Z===1?ve[Ee]:ve.readUInt16BE(Ee*Z)}let me;if(G){let ve=-1;for(me=m;me<ee;me++)if(we(v,me)===we(p,ve===-1?0:me-ve)){if(ve===-1&&(ve=me),me-ve+1===le)return ve*Z}else ve!==-1&&(me-=me-ve),ve=-1}else for(m+le>ee&&(m=ee-le),me=m;me>=0;me--){let ve=!0;for(let Ee=0;Ee<le;Ee++)if(we(v,me+Ee)!==we(p,Ee)){ve=!1;break}if(ve)return me}return-1}u.prototype.includes=function(p,m,M){return this.indexOf(p,m,M)!==-1},u.prototype.indexOf=function(p,m,M){return T(this,p,m,M,!0)},u.prototype.lastIndexOf=function(p,m,M){return T(this,p,m,M,!1)};function F(v,p,m,M){m=Number(m)||0;const G=v.length-m;M?(M=Number(M),M>G&&(M=G)):M=G;const Z=p.length;M>Z/2&&(M=Z/2);let ee;for(ee=0;ee<M;++ee){const le=parseInt(p.substr(ee*2,2),16);if(Ot(le))return ee;v[m+ee]=le}return ee}function O(v,p,m,M){return st(dt(p,v.length-m),v,m,M)}function R(v,p,m,M){return st($t(p),v,m,M)}function P(v,p,m,M){return st(Ne(p),v,m,M)}function K(v,p,m,M){return st(Te(p,v.length-m),v,m,M)}u.prototype.write=function(p,m,M,G){if(m===void 0)G="utf8",M=this.length,m=0;else if(M===void 0&&typeof m=="string")G=m,M=this.length,m=0;else if(isFinite(m))m=m>>>0,isFinite(M)?(M=M>>>0,G===void 0&&(G="utf8")):(G=M,M=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const Z=this.length-m;if((M===void 0||M>Z)&&(M=Z),p.length>0&&(M<0||m<0)||m>this.length)throw new RangeError("Attempt to write outside buffer bounds");G||(G="utf8");let ee=!1;for(;;)switch(G){case"hex":return F(this,p,m,M);case"utf8":case"utf-8":return O(this,p,m,M);case"ascii":case"latin1":case"binary":return R(this,p,m,M);case"base64":return P(this,p,m,M);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return K(this,p,m,M);default:if(ee)throw new TypeError("Unknown encoding: "+G);G=(""+G).toLowerCase(),ee=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function U(v,p,m){return p===0&&m===v.length?t.fromByteArray(v):t.fromByteArray(v.slice(p,m))}function V(v,p,m){m=Math.min(v.length,m);const M=[];let G=p;for(;G<m;){const Z=v[G];let ee=null,le=Z>239?4:Z>223?3:Z>191?2:1;if(G+le<=m){let we,me,ve,Ee;switch(le){case 1:Z<128&&(ee=Z);break;case 2:we=v[G+1],(we&192)===128&&(Ee=(Z&31)<<6|we&63,Ee>127&&(ee=Ee));break;case 3:we=v[G+1],me=v[G+2],(we&192)===128&&(me&192)===128&&(Ee=(Z&15)<<12|(we&63)<<6|me&63,Ee>2047&&(Ee<55296||Ee>57343)&&(ee=Ee));break;case 4:we=v[G+1],me=v[G+2],ve=v[G+3],(we&192)===128&&(me&192)===128&&(ve&192)===128&&(Ee=(Z&15)<<18|(we&63)<<12|(me&63)<<6|ve&63,Ee>65535&&Ee<1114112&&(ee=Ee))}}ee===null?(ee=65533,le=1):ee>65535&&(ee-=65536,M.push(ee>>>10&1023|55296),ee=56320|ee&1023),M.push(ee),G+=le}return H(M)}const C=4096;function H(v){const p=v.length;if(p<=C)return String.fromCharCode.apply(String,v);let m="",M=0;for(;M<p;)m+=String.fromCharCode.apply(String,v.slice(M,M+=C));return m}function D(v,p,m){let M="";m=Math.min(v.length,m);for(let G=p;G<m;++G)M+=String.fromCharCode(v[G]&127);return M}function W(v,p,m){let M="";m=Math.min(v.length,m);for(let G=p;G<m;++G)M+=String.fromCharCode(v[G]);return M}function J(v,p,m){const M=v.length;(!p||p<0)&&(p=0),(!m||m<0||m>M)&&(m=M);let G="";for(let Z=p;Z<m;++Z)G+=vt[v[Z]];return G}function re(v,p,m){const M=v.slice(p,m);let G="";for(let Z=0;Z<M.length-1;Z+=2)G+=String.fromCharCode(M[Z]+M[Z+1]*256);return G}u.prototype.slice=function(p,m){const M=this.length;p=~~p,m=m===void 0?M:~~m,p<0?(p+=M,p<0&&(p=0)):p>M&&(p=M),m<0?(m+=M,m<0&&(m=0)):m>M&&(m=M),m<p&&(m=p);const G=this.subarray(p,m);return Object.setPrototypeOf(G,u.prototype),G};function se(v,p,m){if(v%1!==0||v<0)throw new RangeError("offset is not uint");if(v+p>m)throw new RangeError("Trying to access beyond buffer length")}u.prototype.readUintLE=u.prototype.readUIntLE=function(p,m,M){p=p>>>0,m=m>>>0,M||se(p,m,this.length);let G=this[p],Z=1,ee=0;for(;++ee<m&&(Z*=256);)G+=this[p+ee]*Z;return G},u.prototype.readUintBE=u.prototype.readUIntBE=function(p,m,M){p=p>>>0,m=m>>>0,M||se(p,m,this.length);let G=this[p+--m],Z=1;for(;m>0&&(Z*=256);)G+=this[p+--m]*Z;return G},u.prototype.readUint8=u.prototype.readUInt8=function(p,m){return p=p>>>0,m||se(p,1,this.length),this[p]},u.prototype.readUint16LE=u.prototype.readUInt16LE=function(p,m){return p=p>>>0,m||se(p,2,this.length),this[p]|this[p+1]<<8},u.prototype.readUint16BE=u.prototype.readUInt16BE=function(p,m){return p=p>>>0,m||se(p,2,this.length),this[p]<<8|this[p+1]},u.prototype.readUint32LE=u.prototype.readUInt32LE=function(p,m){return p=p>>>0,m||se(p,4,this.length),(this[p]|this[p+1]<<8|this[p+2]<<16)+this[p+3]*16777216},u.prototype.readUint32BE=u.prototype.readUInt32BE=function(p,m){return p=p>>>0,m||se(p,4,this.length),this[p]*16777216+(this[p+1]<<16|this[p+2]<<8|this[p+3])},u.prototype.readBigUInt64LE=ne(function(p){p=p>>>0,xe(p,"offset");const m=this[p],M=this[p+7];(m===void 0||M===void 0)&&_e(p,this.length-8);const G=m+this[++p]*2**8+this[++p]*2**16+this[++p]*2**24,Z=this[++p]+this[++p]*2**8+this[++p]*2**16+M*2**24;return BigInt(G)+(BigInt(Z)<<BigInt(32))}),u.prototype.readBigUInt64BE=ne(function(p){p=p>>>0,xe(p,"offset");const m=this[p],M=this[p+7];(m===void 0||M===void 0)&&_e(p,this.length-8);const G=m*2**24+this[++p]*2**16+this[++p]*2**8+this[++p],Z=this[++p]*2**24+this[++p]*2**16+this[++p]*2**8+M;return(BigInt(G)<<BigInt(32))+BigInt(Z)}),u.prototype.readIntLE=function(p,m,M){p=p>>>0,m=m>>>0,M||se(p,m,this.length);let G=this[p],Z=1,ee=0;for(;++ee<m&&(Z*=256);)G+=this[p+ee]*Z;return Z*=128,G>=Z&&(G-=Math.pow(2,8*m)),G},u.prototype.readIntBE=function(p,m,M){p=p>>>0,m=m>>>0,M||se(p,m,this.length);let G=m,Z=1,ee=this[p+--G];for(;G>0&&(Z*=256);)ee+=this[p+--G]*Z;return Z*=128,ee>=Z&&(ee-=Math.pow(2,8*m)),ee},u.prototype.readInt8=function(p,m){return p=p>>>0,m||se(p,1,this.length),this[p]&128?(255-this[p]+1)*-1:this[p]},u.prototype.readInt16LE=function(p,m){p=p>>>0,m||se(p,2,this.length);const M=this[p]|this[p+1]<<8;return M&32768?M|4294901760:M},u.prototype.readInt16BE=function(p,m){p=p>>>0,m||se(p,2,this.length);const M=this[p+1]|this[p]<<8;return M&32768?M|4294901760:M},u.prototype.readInt32LE=function(p,m){return p=p>>>0,m||se(p,4,this.length),this[p]|this[p+1]<<8|this[p+2]<<16|this[p+3]<<24},u.prototype.readInt32BE=function(p,m){return p=p>>>0,m||se(p,4,this.length),this[p]<<24|this[p+1]<<16|this[p+2]<<8|this[p+3]},u.prototype.readBigInt64LE=ne(function(p){p=p>>>0,xe(p,"offset");const m=this[p],M=this[p+7];(m===void 0||M===void 0)&&_e(p,this.length-8);const G=this[p+4]+this[p+5]*2**8+this[p+6]*2**16+(M<<24);return(BigInt(G)<<BigInt(32))+BigInt(m+this[++p]*2**8+this[++p]*2**16+this[++p]*2**24)}),u.prototype.readBigInt64BE=ne(function(p){p=p>>>0,xe(p,"offset");const m=this[p],M=this[p+7];(m===void 0||M===void 0)&&_e(p,this.length-8);const G=(m<<24)+this[++p]*2**16+this[++p]*2**8+this[++p];return(BigInt(G)<<BigInt(32))+BigInt(this[++p]*2**24+this[++p]*2**16+this[++p]*2**8+M)}),u.prototype.readFloatLE=function(p,m){return p=p>>>0,m||se(p,4,this.length),n.read(this,p,!0,23,4)},u.prototype.readFloatBE=function(p,m){return p=p>>>0,m||se(p,4,this.length),n.read(this,p,!1,23,4)},u.prototype.readDoubleLE=function(p,m){return p=p>>>0,m||se(p,8,this.length),n.read(this,p,!0,52,8)},u.prototype.readDoubleBE=function(p,m){return p=p>>>0,m||se(p,8,this.length),n.read(this,p,!1,52,8)};function z(v,p,m,M,G,Z){if(!u.isBuffer(v))throw new TypeError('"buffer" argument must be a Buffer instance');if(p>G||p<Z)throw new RangeError('"value" argument is out of bounds');if(m+M>v.length)throw new RangeError("Index out of range")}u.prototype.writeUintLE=u.prototype.writeUIntLE=function(p,m,M,G){if(p=+p,m=m>>>0,M=M>>>0,!G){const le=Math.pow(2,8*M)-1;z(this,p,m,M,le,0)}let Z=1,ee=0;for(this[m]=p&255;++ee<M&&(Z*=256);)this[m+ee]=p/Z&255;return m+M},u.prototype.writeUintBE=u.prototype.writeUIntBE=function(p,m,M,G){if(p=+p,m=m>>>0,M=M>>>0,!G){const le=Math.pow(2,8*M)-1;z(this,p,m,M,le,0)}let Z=M-1,ee=1;for(this[m+Z]=p&255;--Z>=0&&(ee*=256);)this[m+Z]=p/ee&255;return m+M},u.prototype.writeUint8=u.prototype.writeUInt8=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,1,255,0),this[m]=p&255,m+1},u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,2,65535,0),this[m]=p&255,this[m+1]=p>>>8,m+2},u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,2,65535,0),this[m]=p>>>8,this[m+1]=p&255,m+2},u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,4,4294967295,0),this[m+3]=p>>>24,this[m+2]=p>>>16,this[m+1]=p>>>8,this[m]=p&255,m+4},u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,4,4294967295,0),this[m]=p>>>24,this[m+1]=p>>>16,this[m+2]=p>>>8,this[m+3]=p&255,m+4};function X(v,p,m,M,G){Ie(p,M,G,v,m,7);let Z=Number(p&BigInt(4294967295));v[m++]=Z,Z=Z>>8,v[m++]=Z,Z=Z>>8,v[m++]=Z,Z=Z>>8,v[m++]=Z;let ee=Number(p>>BigInt(32)&BigInt(4294967295));return v[m++]=ee,ee=ee>>8,v[m++]=ee,ee=ee>>8,v[m++]=ee,ee=ee>>8,v[m++]=ee,m}function Y(v,p,m,M,G){Ie(p,M,G,v,m,7);let Z=Number(p&BigInt(4294967295));v[m+7]=Z,Z=Z>>8,v[m+6]=Z,Z=Z>>8,v[m+5]=Z,Z=Z>>8,v[m+4]=Z;let ee=Number(p>>BigInt(32)&BigInt(4294967295));return v[m+3]=ee,ee=ee>>8,v[m+2]=ee,ee=ee>>8,v[m+1]=ee,ee=ee>>8,v[m]=ee,m+8}u.prototype.writeBigUInt64LE=ne(function(p,m=0){return X(this,p,m,BigInt(0),BigInt("0xffffffffffffffff"))}),u.prototype.writeBigUInt64BE=ne(function(p,m=0){return Y(this,p,m,BigInt(0),BigInt("0xffffffffffffffff"))}),u.prototype.writeIntLE=function(p,m,M,G){if(p=+p,m=m>>>0,!G){const we=Math.pow(2,8*M-1);z(this,p,m,M,we-1,-we)}let Z=0,ee=1,le=0;for(this[m]=p&255;++Z<M&&(ee*=256);)p<0&&le===0&&this[m+Z-1]!==0&&(le=1),this[m+Z]=(p/ee>>0)-le&255;return m+M},u.prototype.writeIntBE=function(p,m,M,G){if(p=+p,m=m>>>0,!G){const we=Math.pow(2,8*M-1);z(this,p,m,M,we-1,-we)}let Z=M-1,ee=1,le=0;for(this[m+Z]=p&255;--Z>=0&&(ee*=256);)p<0&&le===0&&this[m+Z+1]!==0&&(le=1),this[m+Z]=(p/ee>>0)-le&255;return m+M},u.prototype.writeInt8=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,1,127,-128),p<0&&(p=255+p+1),this[m]=p&255,m+1},u.prototype.writeInt16LE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,2,32767,-32768),this[m]=p&255,this[m+1]=p>>>8,m+2},u.prototype.writeInt16BE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,2,32767,-32768),this[m]=p>>>8,this[m+1]=p&255,m+2},u.prototype.writeInt32LE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,4,2147483647,-2147483648),this[m]=p&255,this[m+1]=p>>>8,this[m+2]=p>>>16,this[m+3]=p>>>24,m+4},u.prototype.writeInt32BE=function(p,m,M){return p=+p,m=m>>>0,M||z(this,p,m,4,2147483647,-2147483648),p<0&&(p=4294967295+p+1),this[m]=p>>>24,this[m+1]=p>>>16,this[m+2]=p>>>8,this[m+3]=p&255,m+4},u.prototype.writeBigInt64LE=ne(function(p,m=0){return X(this,p,m,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),u.prototype.writeBigInt64BE=ne(function(p,m=0){return Y(this,p,m,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function ae(v,p,m,M,G,Z){if(m+M>v.length)throw new RangeError("Index out of range");if(m<0)throw new RangeError("Index out of range")}function ce(v,p,m,M,G){return p=+p,m=m>>>0,G||ae(v,p,m,4),n.write(v,p,m,M,23,4),m+4}u.prototype.writeFloatLE=function(p,m,M){return ce(this,p,m,!0,M)},u.prototype.writeFloatBE=function(p,m,M){return ce(this,p,m,!1,M)};function oe(v,p,m,M,G){return p=+p,m=m>>>0,G||ae(v,p,m,8),n.write(v,p,m,M,52,8),m+8}u.prototype.writeDoubleLE=function(p,m,M){return oe(this,p,m,!0,M)},u.prototype.writeDoubleBE=function(p,m,M){return oe(this,p,m,!1,M)},u.prototype.copy=function(p,m,M,G){if(!u.isBuffer(p))throw new TypeError("argument should be a Buffer");if(M||(M=0),!G&&G!==0&&(G=this.length),m>=p.length&&(m=p.length),m||(m=0),G>0&&G<M&&(G=M),G===M||p.length===0||this.length===0)return 0;if(m<0)throw new RangeError("targetStart out of bounds");if(M<0||M>=this.length)throw new RangeError("Index out of range");if(G<0)throw new RangeError("sourceEnd out of bounds");G>this.length&&(G=this.length),p.length-m<G-M&&(G=p.length-m+M);const Z=G-M;return this===p&&typeof o.prototype.copyWithin=="function"?this.copyWithin(m,M,G):o.prototype.set.call(p,this.subarray(M,G),m),Z},u.prototype.fill=function(p,m,M,G){if(typeof p=="string"){if(typeof m=="string"?(G=m,m=0,M=this.length):typeof M=="string"&&(G=M,M=this.length),G!==void 0&&typeof G!="string")throw new TypeError("encoding must be a string");if(typeof G=="string"&&!u.isEncoding(G))throw new TypeError("Unknown encoding: "+G);if(p.length===1){const ee=p.charCodeAt(0);(G==="utf8"&&ee<128||G==="latin1")&&(p=ee)}}else typeof p=="number"?p=p&255:typeof p=="boolean"&&(p=Number(p));if(m<0||this.length<m||this.length<M)throw new RangeError("Out of range index");if(M<=m)return this;m=m>>>0,M=M===void 0?this.length:M>>>0,p||(p=0);let Z;if(typeof p=="number")for(Z=m;Z<M;++Z)this[Z]=p;else{const ee=u.isBuffer(p)?p:u.from(p,G),le=ee.length;if(le===0)throw new TypeError('The value "'+p+'" is invalid for argument "value"');for(Z=0;Z<M-m;++Z)this[Z+m]=ee[Z%le]}return this};const de={};function pe(v,p,m){de[v]=class extends m{constructor(){super(),Object.defineProperty(this,"message",{value:p.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${v}]`,this.stack,delete this.name}get code(){return v}set code(G){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:G,writable:!0})}toString(){return`${this.name} [${v}]: ${this.message}`}}}pe("ERR_BUFFER_OUT_OF_BOUNDS",function(v){return v?`${v} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),pe("ERR_INVALID_ARG_TYPE",function(v,p){return`The "${v}" argument must be of type number. Received type ${typeof p}`},TypeError),pe("ERR_OUT_OF_RANGE",function(v,p,m){let M=`The value of "${v}" is out of range.`,G=m;return Number.isInteger(m)&&Math.abs(m)>2**32?G=fe(String(m)):typeof m=="bigint"&&(G=String(m),(m>BigInt(2)**BigInt(32)||m<-(BigInt(2)**BigInt(32)))&&(G=fe(G)),G+="n"),M+=` It must be ${p}. Received ${G}`,M},RangeError);function fe(v){let p="",m=v.length;const M=v[0]==="-"?1:0;for(;m>=M+4;m-=3)p=`_${v.slice(m-3,m)}${p}`;return`${v.slice(0,m)}${p}`}function ye(v,p,m){xe(p,"offset"),(v[p]===void 0||v[p+m]===void 0)&&_e(p,v.length-(m+1))}function Ie(v,p,m,M,G,Z){if(v>m||v<p){const ee=typeof p=="bigint"?"n":"";let le;throw p===0||p===BigInt(0)?le=`>= 0${ee} and < 2${ee} ** ${(Z+1)*8}${ee}`:le=`>= -(2${ee} ** ${(Z+1)*8-1}${ee}) and < 2 ** ${(Z+1)*8-1}${ee}`,new de.ERR_OUT_OF_RANGE("value",le,v)}ye(M,G,Z)}function xe(v,p){if(typeof v!="number")throw new de.ERR_INVALID_ARG_TYPE(p,"number",v)}function _e(v,p,m){throw Math.floor(v)!==v?(xe(v,m),new de.ERR_OUT_OF_RANGE("offset","an integer",v)):p<0?new de.ERR_BUFFER_OUT_OF_BOUNDS:new de.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${p}`,v)}const mt=/[^+/0-9A-Za-z-_]/g;function bt(v){if(v=v.split("=")[0],v=v.trim().replace(mt,""),v.length<2)return"";for(;v.length%4!==0;)v=v+"=";return v}function dt(v,p){p=p||1/0;let m;const M=v.length;let G=null;const Z=[];for(let ee=0;ee<M;++ee){if(m=v.charCodeAt(ee),m>55295&&m<57344){if(!G){if(m>56319){(p-=3)>-1&&Z.push(239,191,189);continue}else if(ee+1===M){(p-=3)>-1&&Z.push(239,191,189);continue}G=m;continue}if(m<56320){(p-=3)>-1&&Z.push(239,191,189),G=m;continue}m=(G-55296<<10|m-56320)+65536}else G&&(p-=3)>-1&&Z.push(239,191,189);if(G=null,m<128){if((p-=1)<0)break;Z.push(m)}else if(m<2048){if((p-=2)<0)break;Z.push(m>>6|192,m&63|128)}else if(m<65536){if((p-=3)<0)break;Z.push(m>>12|224,m>>6&63|128,m&63|128)}else if(m<1114112){if((p-=4)<0)break;Z.push(m>>18|240,m>>12&63|128,m>>6&63|128,m&63|128)}else throw new Error("Invalid code point")}return Z}function $t(v){const p=[];for(let m=0;m<v.length;++m)p.push(v.charCodeAt(m)&255);return p}function Te(v,p){let m,M,G;const Z=[];for(let ee=0;ee<v.length&&!((p-=2)<0);++ee)m=v.charCodeAt(ee),M=m>>8,G=m%256,Z.push(G),Z.push(M);return Z}function Ne(v){return t.toByteArray(bt(v))}function st(v,p,m,M){let G;for(G=0;G<M&&!(G+m>=p.length||G>=v.length);++G)p[G+m]=v[G];return G}function Fe(v,p){return v instanceof p||v!=null&&v.constructor!=null&&v.constructor.name!=null&&v.constructor.name===p.name}function Ot(v){return v!==v}const vt=(function(){const v="0123456789abcdef",p=new Array(256);for(let m=0;m<16;++m){const M=m*16;for(let G=0;G<16;++G)p[M+G]=v[m]+v[G]}return p})();function ne(v){return typeof BigInt>"u"?j:v}function j(){throw new Error("BigInt not supported")}})(Ds);const te=Ds.Buffer,zg=Ds.Buffer;var rh={};(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});function Kr(e){var t="";return n(e),t;function n(a){if(a===null||typeof a!="object"||a.toJSON!=null)t+=JSON.stringify(a);else if(Array.isArray(a)){t+="[";var o=!1;a.forEach(function(s){o&&(t+=","),o=!0,s===void 0&&(s=null),n(s)}),t+="]"}else{t+="{";var i=Object.keys(a).filter(function(s){return a[s]!==void 0}).sort();i.forEach(function(s,c){return r(a,s,c)}),t+="}"}}function r(a,o,i){i>0&&(t+=","),t+=JSON.stringify(o),t+=":",n(a[o])}}var nh=(e,t)=>{if(!gt.isBrowser)return te.from(e,t);{let n=atob(e);return new Uint8Array(n.length).map((r,a)=>n.charCodeAt(a))}},ih=(e,t)=>gt.isBrowser?new TextDecoder().decode(e):te.from(e).toString(t),Fs=(...e)=>{if(!gt.isBrowser)return te.concat(e);let t=e.reduce((a,o)=>a+o.length,0),n=new Uint8Array(t),r=0;for(let a of e)n.set(a,r),r+=a.length;return n},Nf=typeof window<"u",Jn=e=>{if(!Nf)try{return rh?.[e]}catch{return}},gt={getEnvValue:Jn,isBrowser:Nf,isTestEnvironment:Jn("NODE_ENV")==="test",logResolves:Jn("LOG_RESOLVES")==="true",getVerificationMethods:()=>{let e=Jn("DID_VERIFICATION_METHODS");if(!e)return[];try{let t=nh(e,"base64");return JSON.parse(ih(t))}catch{return[]}}},De="{SCID}",Ui="webvh",oh=["https://www.w3.org/ns/did/v1","https://w3id.org/security/multikey/v1"],Ff;(e=>{e.BASE64URL_NO_PAD="u",e.BASE58_BTC="z"})(Ff||={});var Mf={z:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"};function sh(e){return te.from(e).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function ah(e){let t=e.length%4===0?0:4-e.length%4,n=e.replace(/-/g,"+").replace(/_/g,"/")+"=".repeat(t),r=atob(n),a=new Uint8Array(r.length);for(let o=0;o<r.length;o++)a[o]=r.charCodeAt(o);return a}function Ms(e){let t=Mf.z,n=0;for(let o=0;o<e.length&&e[o]===0;o++)n++;let r=0n;for(let o=0;o<e.length;o++)r=r*256n+BigInt(e[o]);let a="";for(;r>0n;){let o=Number(r%58n);r=r/58n,a=t[o]+a}return"1".repeat(n)+a}function ch(e){let t=Mf.z,n=0;for(let o=0;o<e.length&&e[o]==="1";o++)n++;let r=0n;for(let o=n;o<e.length;o++){let i=e[o],s=t.indexOf(i);if(s===-1)throw Error(`Invalid Base58 character: ${i}`);r=r*58n+BigInt(s)}let a=[];for(;r>0n;)a.unshift(Number(r%256n)),r=r/256n;return new Uint8Array([...Array(n).fill(0),...a])}function uh(e,t="u"){let n;switch(t){case"u":n=sh(e);break;case"z":n=Ms(e);break;default:throw Error(`Unsupported multibase encoding: ${t}`)}return`${t}${n}`}function Mn(e){if(!e||e.length<2)throw Error("Invalid multibase string: too short");let t=e[0],n=e.slice(1),r;switch(t){case"u":r=ah(n);break;case"z":r=ch(n);break;default:throw Error(`Unsupported multibase encoding prefix: ${t}`)}return{bytes:r,encoding:t}}var fh={18:32,32:48,22:32,21:48};function Ra(e){let t=[];for(;e>=128;)t.push(e&127|128),e>>>=7;return t.push(e&127),new Uint8Array(t)}function Cf(e,t){let n=fh[t];if(e.length!==n)throw Error(`Invalid digest length for algorithm ${t.toString(16)}: expected ${n}, got ${e.length}`);let r=Ra(t),a=Ra(e.length),o=new Uint8Array(r.length+a.length+e.length);return o.set(r,0),o.set(a,r.length),o.set(e,r.length+a.length),o}function lh(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Cs(e,...t){if(!lh(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function Pa(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function dh(e,t){Cs(e);let n=t.outputLen;if(e.length<n)throw Error("digestInto() expects output buffer of length at least "+n)}function Ss(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function zi(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function Et(e,t){return e<<32-t|e>>>t}function hh(e){if(typeof e!="string")throw Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function jf(e){return typeof e=="string"&&(e=hh(e)),Cs(e),e}class ph{}function yh(e){let t=r=>e().update(jf(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function gh(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);let a=BigInt(32),o=BigInt(4294967295),i=Number(n>>a&o),s=Number(n&o),c=r?4:0,l=r?0:4;e.setUint32(t+c,i,r),e.setUint32(t+l,s,r)}function wh(e,t,n){return e&t^~e&n}function mh(e,t,n){return e&t^e&n^t&n}class bh extends ph{constructor(t,n,r,a){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=a,this.buffer=new Uint8Array(t),this.view=zi(this.buffer)}update(t){Pa(this),t=jf(t),Cs(t);let{view:n,buffer:r,blockLen:a}=this,o=t.length;for(let i=0;i<o;){let s=Math.min(a-this.pos,o-i);if(s===a){let c=zi(t);for(;a<=o-i;i+=a)this.process(c,i);continue}r.set(t.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===a&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Pa(this),dh(t,this),this.finished=!0;let{buffer:n,view:r,blockLen:a,isLE:o}=this,{pos:i}=this;n[i++]=128,Ss(this.buffer.subarray(i)),this.padOffset>a-i&&(this.process(r,0),i=0);for(let d=i;d<a;d++)n[d]=0;gh(r,a-8,BigInt(this.length*8),o),this.process(r,0);let s=zi(t),c=this.outputLen;if(c%4)throw Error("_sha2: outputLen should be aligned to 32bit");let l=c/4,u=this.get();if(l>u.length)throw Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)s.setUint32(4*d,u[d],o)}digest(){let{buffer:t,outputLen:n}=this;this.digestInto(t);let r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:n,buffer:r,length:a,finished:o,destroyed:i,pos:s}=this;return t.destroyed=i,t.finished=o,t.length=a,t.pos=s,a%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}var zt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),vh=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Jt=new Uint32Array(64);class Eh extends bh{constructor(t=32){super(64,t,8,!1),this.A=zt[0]|0,this.B=zt[1]|0,this.C=zt[2]|0,this.D=zt[3]|0,this.E=zt[4]|0,this.F=zt[5]|0,this.G=zt[6]|0,this.H=zt[7]|0}get(){let{A:t,B:n,C:r,D:a,E:o,F:i,G:s,H:c}=this;return[t,n,r,a,o,i,s,c]}set(t,n,r,a,o,i,s,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=a|0,this.E=o|0,this.F=i|0,this.G=s|0,this.H=c|0}process(t,n){for(let d=0;d<16;d++,n+=4)Jt[d]=t.getUint32(n,!1);for(let d=16;d<64;d++){let h=Jt[d-15],f=Jt[d-2],y=Et(h,7)^Et(h,18)^h>>>3,g=Et(f,17)^Et(f,19)^f>>>10;Jt[d]=g+Jt[d-7]+y+Jt[d-16]|0}let{A:r,B:a,C:o,D:i,E:s,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){let h=Et(s,6)^Et(s,11)^Et(s,25),f=u+h+wh(s,c,l)+vh[d]+Jt[d]|0,y=(Et(r,2)^Et(r,13)^Et(r,22))+mh(r,a,o)|0;u=l,l=c,c=s,s=i+f|0,i=o,o=a,a=r,r=f+y|0}r=r+this.A|0,a=a+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(r,a,o,i,s,c,l,u)}roundClean(){Ss(Jt)}destroy(){this.set(0,0,0,0,0,0,0,0),Ss(this.buffer)}}var xh=yh(()=>new Eh);async function Er(e){return xh(e)}var qf=typeof dn<"u"&&typeof window>"u"&&!!(dn.versions&&dn.versions.node||dn.versions.bun),Ua=["node","fs"].join(":"),en=null,Yn=null,Kf=async()=>{if(!qf)throw Error("Filesystem access is not available in this environment (React Native, browser, or failed Node.js import)");return en||Yn||(Yn=(async()=>{let e=globalThis.require;if(typeof e=="function"){try{let t=e(Ua);return en=t,t}catch{}try{let t=e("fs");return en=t,t}catch{}}try{let t=await import(Ua);return en=t,t}catch{}try{let t=await ln(()=>Promise.resolve().then(()=>Ad),[]);return en=t,t}catch{}throw Error("Filesystem access is not available in this environment (unable to load fs)")})(),Yn)},Sh=e=>{try{let t=e.includes("localhost")?"http":"https";return new URL(`${t}://${e}`).hostname}catch{return e}},Ih=async(e,t)=>{let n=await Kf();try{let r=e.substring(0,e.lastIndexOf("/"));r&&!n.existsSync(r)&&n.mkdirSync(r,{recursive:!0}),n.writeFileSync(e,JSON.stringify(t[0])+`
`);for(let a=1;a<t.length;a++)n.appendFileSync(e,JSON.stringify(t[a])+`
`)}catch(r){throw console.error("Error writing log to disk:",r),r}},Vr=async(e,t)=>{if(gt.isTestEnvironment)try{let n=`./test/logs/${e.replace(/[^a-zA-Z0-9]+/g,"_")}.jsonl`;await Ih(n,t)}catch(n){console.error("Error writing test log:",n)}};function Xe(e){if(e===null||typeof e!="object")return e;if(e instanceof Date)return new Date(e.getTime());if(Array.isArray(e))return e.map(n=>Xe(n));let t={};for(let[n,r]of Object.entries(e))t[n]=Xe(r);return t}var js=e=>{let t=e.split(":");if(!e.startsWith("did:webvh:")||t.length<4)throw Error(`${e} is not a valid did:webvh identifier`);let n=decodeURIComponent(t.slice(3).join("/")),r=n.includes("localhost")?"http":"https",[a,...o]=n.split("/"),[i,s]=decodeURIComponent(a).split(":");i=Sh(i.normalize("NFC"));let c=s?`${i}:${s}`:i,l=o.join("/");return`${r}://${c}${l?"/"+l:""}`},qs=e=>{let t=js(e);return t.indexOf("/",t.indexOf("://")+3)!==-1?`${t}/did.jsonl`:`${t}/.well-known/did.jsonl`};async function _h(e,t=!1){try{if(t){let o=`./src/routes/${e.split(":").slice(4).join(":")||".well-known"}/did.jsonl`;try{let i;if(typeof Bun<"u"&&Bun.file)i=(await Bun.file(o).text()).trim();else if(qf)i=(await Kf()).readFileSync(o,"utf8").trim();else throw Error("Local log retrieval not supported in this environment");return i?i.split(`
`).map(s=>JSON.parse(s)):[]}catch(i){throw Error(`Error reading local DID log: ${i}`)}}let n=qs(e),r=await fetch(n);if(!r.ok)throw Error(`HTTP error! status: ${r.status}`);let a=(await r.text()).trim();if(!a)throw Error(`DID log not found for ${e}`);return a.split(`
`).map(o=>JSON.parse(o))}catch(n){throw console.error("Error fetching DID log:",n),n}}var zr=e=>new Date(e??Date.now()).toISOString().slice(0,-5)+"Z",Ks=async e=>e,Vf=new Map;function Ah(e){try{let t=JSON.stringify(e);return Vf.get(t)}catch{return}}function Th(e,t){try{let n=JSON.stringify(e);Vf.set(n,t)}catch{}}async function ut(e){let t=Ah(e);if(t)return t;let n=Kr(e),r=await Er(n),a=Cf(new Uint8Array(r),18),o=Ms(a);return Th(e,o),o}var Bh=async e=>{let t=await Er(e),n=Cf(new Uint8Array(t),18);return Ms(n)},Hi=async e=>{let{controller:t}=e,n=Oh(e.verificationMethods,t),r={"@context":e.context||oh,id:t,controller:t};return n&&typeof n=="object"&&(n.verificationMethod&&(r.verificationMethod=n.verificationMethod),n.authentication&&(r.authentication=n.authentication),n.assertionMethod&&(r.assertionMethod=n.assertionMethod),n.keyAgreement&&(r.keyAgreement=n.keyAgreement),n.capabilityDelegation&&(r.capabilityDelegation=n.capabilityDelegation),n.capabilityInvocation&&(r.capabilityInvocation=n.capabilityInvocation)),e.authentication&&(r.authentication=e.authentication),e.assertionMethod&&(r.assertionMethod=e.assertionMethod),e.keyAgreement&&(r.keyAgreement=e.keyAgreement),e.alsoKnownAs&&(r.alsoKnownAs=e.alsoKnownAs),{doc:r}},kh=(e=8)=>{let t="",n=36;for(let r=0;r<e;r++)t+="abcdefghijklmnopqrstuvwxyz0123456789".charAt(Math.floor(Math.random()*n));return t},tn=(e,t)=>`${t??""}#${e.publicKeyMultibase?.slice(-8)||kh(8)}`,Oh=(e,t=null)=>{let n={verificationMethod:[],authentication:[],assertionMethod:[],keyAgreement:[],capabilityDelegation:[],capabilityInvocation:[]};if(!e||e.length===0)return n;let r=e.map(a=>({...a,id:a.id??tn(a,t)}));return n.verificationMethod=r,n.authentication=e.filter(a=>!a.purpose||a.purpose==="authentication").map(a=>a.id??tn(a,t)),n.assertionMethod=e.filter(a=>a.purpose==="assertionMethod").map(a=>a.id??tn(a,t)),n.keyAgreement=e.filter(a=>a.purpose==="keyAgreement").map(a=>a.id??tn(a,t)),n.capabilityDelegation=e.filter(a=>a.purpose==="capabilityDelegation").map(a=>a.id??tn(a,t)),n.capabilityInvocation=e.filter(a=>a.purpose==="capabilityInvocation").map(a=>a.id??tn(a,t)),n},Gf=async e=>{try{if(e.startsWith("did:key:"))return{publicKeyMultibase:e.split("did:key:")[1].split("#")[0]};if(e.startsWith("did:webvh:")){let t=qs(e.split("#")[0]),n=(await(await fetch(t)).text()).trim().split(`
`).map(a=>JSON.parse(a)),{doc:r}=await Qf(n,{verificationMethod:e});return Vs(r,e)}throw Error(`Verification method ${e} not found`)}catch{throw Error(`Error resolving VM ${e}`)}},Vs=(e,t)=>{if(e.verificationMethod&&e.verificationMethod.some(r=>r.id===t))return e.verificationMethod.find(r=>r.id===t);let n=["authentication","assertionMethod","keyAgreement","capabilityInvocation","capabilityDelegation"];for(let r of n)if(e[r]&&e[r].some(a=>a.id===t))return e[r].find(a=>a.id===t);return null};async function Rh(){let e=[];try{for(let t of gt.getVerificationMethods()){let n=t.controller||t.id.split("#")[0];e.push(n)}}catch(t){console.error("Error processing verification methods:",t)}return e}async function Wf(e){try{let t=qs(e).replace("did.jsonl","did-witness.json"),n=await fetch(t);return n.ok?await n.json():[]}catch(t){return console.error("Error fetching witness proofs:",t),[]}}function br(e,t,n){if(typeof e=="string")return e.replaceAll(t,n);if(Array.isArray(e))return e.map(r=>br(r,t,n));if(e&&typeof e=="object"){let r={};for(let[a,o]of Object.entries(e))r[a]=br(o,t,n);return r}return e}function Gs(e){if(!e.witnesses||!Array.isArray(e.witnesses)||e.witnesses.length===0)throw Error("Witness list cannot be empty");if(!e.threshold||parseInt(e.threshold.toString())<1||parseInt(e.threshold.toString())>e.witnesses.length)throw Error("Witness threshold must be between 1 and the number of witnesses");let t=new Set;for(let n of e.witnesses){if(!n.id.startsWith("did:key:"))throw Error("Witness DIDs must be did:key format");if(t.has(n.id))throw Error(`Duplicate witness id: ${n.id}`);t.add(n.id)}}async function $f(e,t,n,r){if(!r)throw Error("Verifier implementation is required");let a=0,o=new Set;for(let i of t)for(let s of i.proof){if(s.cryptosuite!=="eddsa-jcs-2022")throw Error("Invalid witness proof cryptosuite");let c=n.witnesses?.find(l=>s.verificationMethod.startsWith(l.id));if(!c)throw Error("Proof from unauthorized witness");if(!o.has(c.id))try{let l=await Gf(s.verificationMethod);if(!l)throw Error(`Verification Method ${s.verificationMethod} not found`);let u;try{u=Mn(l.publicKeyMultibase).bytes}catch(b){throw Error(`Failed to decode public key: ${b.message}`)}if(u.length!==34)throw Error(`Invalid public key length ${u.length} (should be 34 bytes)`);let{proofValue:d,...h}=s,f=Kr({versionId:e.versionId}),y=Kr(h),g=await Er(f),S=await Er(y),B=Fs(S,g),I;try{I=Mn(d).bytes}catch(b){throw Error(`Failed to decode signature: ${b.message}`)}if(!await r.verify(I,B,u.slice(2)))throw Error("Invalid witness proof signature");a++,o.add(c.id)}catch(l){throw Error(`Invalid witness proof: ${l.message}`)}}if(a<parseInt(n.threshold?.toString()??"0"))throw Error(`Witness threshold not met: got ${a}, need ${n.threshold}`)}var Ph=(e,t)=>{if(gt.getEnvValue("IGNORE_ASSERTION_KEY_IS_AUTHORIZED")==="true")return!0;if(e.startsWith("did:key:")){let n=e.split("did:key:")[1].split("#")[0];return t.some(r=>{let a=r;return r.startsWith("did:key:")&&(a=r.split("did:key:")[1].split("#")[0]),a===n})}return!1},Uh=(e,t)=>{if(gt.getEnvValue("IGNORE_WITNESS_IS_AUTHORIZED")==="true")return!0;if(e.startsWith("did:webvh:")){let n=e.split("#")[0];return t.includes(n)}return!1},Bt=async(e,t,n,r,a)=>{if(gt.getEnvValue("IGNORE_ASSERTION_DOCUMENT_STATE_IS_VALID")==="true")return!0;if(!a)throw Error("Verifier implementation is required");let{proof:o,...i}=e;Array.isArray(o)||(o=[o]),n&&n.witnesses&&n.witnesses.length>0&&(r||Gs(n));for(let s=0;s<o.length;s++){let c=o[s];if(c.verificationMethod.startsWith("did:key:")){if(!Ph(c.verificationMethod,t))throw Error(`Key ${c.verificationMethod} is not authorized to update.`)}else if(c.verificationMethod.startsWith("did:webvh:")){if(n&&n.witnesses&&n.witnesses.length>0&&!Uh(c.verificationMethod,n.witnesses.map(B=>B.id)))throw Error(`Key ${c.verificationMethod} is not from an authorized witness.`)}else throw Error(`Unsupported verification method: ${c.verificationMethod}`);if(c.type!=="DataIntegrityProof")throw Error(`Unknown proof type ${c.type}`);if(c.proofPurpose!=="authentication"&&c.proofPurpose!=="assertionMethod")throw Error(`Unknown proof purpose ${c.proofPurpose}`);if(c.cryptosuite!=="eddsa-jcs-2022")throw Error(`Unknown cryptosuite ${c.cryptosuite}`);let l=await Gf(c.verificationMethod);if(!l)throw Error(`Verification Method ${c.verificationMethod} not found`);let u=Mn(l.publicKeyMultibase).bytes;if(u[0]!==237||u[1]!==1)throw Error("multiKey doesn't include ed25519 header (0xed01)");let{proofValue:d,...h}=c,f=Mn(d).bytes,y=await Er(Kr(i)),g=await Er(Kr(h)),S=Fs(g,y);if(!await a.verify(f,S,u.slice(2)))throw Error(`Proof ${s} failed verification (proofValue: ${d})`)}return!0},Xf=(e,t)=>gt.getEnvValue("IGNORE_ASSERTION_HASH_CHAIN_IS_VALID")==="true"?!0:e===t,zf=async(e,t)=>{if(gt.getEnvValue("IGNORE_ASSERTION_NEW_KEYS_ARE_VALID")==="true")return!0;if(t.length>0)for(let n of e){let r=await Bh(n);if(!t.includes(r))throw Error(`Invalid update key ${r}. Not found in nextKeyHashes ${t}`)}return!0},Jf=async(e,t)=>gt.getEnvValue("IGNORE_ASSERTION_SCID_IS_FROM_HASH")==="true"?!0:e===await Ks(t),Hh="1.0",Lh=`did:${Ui}:${Hh}`,Dh=async e=>{if(!e.updateKeys)throw Error("Update keys not supplied");e.witness&&e.witness.witnesses&&e.witness.witnesses.length>0&&Gs(e.witness);let t=encodeURIComponent(e.domain),n=e.paths?.join(":"),r=`did:${Ui}:${De}:${t}${n?`:${n}`:""}`,a=zr(e.created),o=e.verificationMethods?.map(y=>{if(y.secretKeyMultibase){console.warn("Warning: Removing secretKeyMultibase from verification method - secret keys should not be stored in DID documents");let{secretKeyMultibase:g,...S}=y;return S}return y}),{doc:i}=await Hi({...e,controller:r,verificationMethods:o}),s={scid:De,updateKeys:e.updateKeys,portable:e.portable??!1,nextKeyHashes:e.nextKeyHashes??[],watchers:e.watchers??[],witness:e.witness??{},deactivated:!1},c={versionId:De,versionTime:a,parameters:{method:Lh,...s},state:i},l=await ut(c);s.scid=await Ks(l),c.state=i;let u=JSON.parse(JSON.stringify(c).replaceAll(De,s.scid)),d=await ut(u);u.versionId=`1-${d}`;let h=await e.signer.sign({document:u,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:a,proofPurpose:"assertionMethod"}}),f=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:a,proofPurpose:"assertionMethod",proofValue:h.proofValue}];if(u.proof=f,!await Bt({...u,versionId:`1-${d}`},s.updateKeys,s.witness,!0,e.verifier))throw Error(`version ${u.versionId} is invalid.`);return{did:u.state.id,doc:u.state,meta:{versionId:u.versionId,created:u.versionTime,updated:u.versionTime,prerotation:(s.nextKeyHashes?.length??0)>0,...s},log:[u]}},Li=async(e,t={})=>{if(t.verificationMethod&&(t.versionNumber||t.versionId))throw Error("Cannot specify both verificationMethod and version number/id");let n=e.map(S=>Xe(S)),r="",a=null,o=null,i=null,s={versionId:"",created:"",updated:"",deactivated:!1,portable:!1,scid:"",updateKeys:[],nextKeyHashes:[],prerotation:!1,witness:void 0,watchers:null},c=null,l=null,u=0,d="",h=t.fastResolve??!0,f=S=>S===0,y=S=>S>=n.length-10,g=S=>!h||f(S)||y(S);try{for(;u<n.length;){let{versionId:S,versionTime:B,parameters:I,state:b,proof:w}=n[u],[x,_]=S.split("-");if(parseInt(x)!==u+1)throw Error(`version '${x}' in log doesn't match expected '${u+1}'.`);s.versionId=S,s.updated=B;let N=b;if(x==="1"){if(s.created=B,N=b,d=N.id.split(":").at(-1),s.scid=I.scid,s.portable=I.portable??s.portable,s.updateKeys=I.updateKeys,s.nextKeyHashes=I.nextKeyHashes||[],s.prerotation=s.nextKeyHashes.length>0,s.witness=I.witness||s.witness,s.watchers=I.watchers??null,g(u)){let k={versionId:De,versionTime:s.created,parameters:br(I,s.scid,De),state:br(N,s.scid,De)},T=await ut(k);if(s.previousLogEntryHash=T,!await Jf(s.scid,T))throw Error(`SCID '${s.scid}' not derived from logEntryHash '${T}'`);let L=br(k,De,s.scid),F=await ut(L);if(!await Bt({...L,versionId:`1-${F}`,proof:w},s.updateKeys,s.witness,!1,t.verifier))throw Error(`version ${s.versionId} failed verification of the proof.`)}}else{let k=N.id.split(":").at(-1);if(!s.portable&&k!==d)throw Error("Cannot move DID: portability is disabled");if(k!==d&&(d=k),g(u)){let T=s.prerotation?I.updateKeys:s.updateKeys;if(!await Bt(n[u],T,s.witness,!1,t.verifier))throw Error(`version ${s.versionId} failed verification of the proof.`);if(!Xf(`${u+1}-${_}`,S))throw Error(`Hash chain broken at '${s.versionId}'`);s.prerotation&&await zf(I.updateKeys??[],s.nextKeyHashes??[])}I.updateKeys&&(s.updateKeys=I.updateKeys),I.deactivated===!0&&(s.deactivated=!0),I.nextKeyHashes?(s.nextKeyHashes=I.nextKeyHashes,s.prerotation=!0):(s.nextKeyHashes=[],s.prerotation=!1),"witness"in I?s.witness=I.witness:I.witnesses&&(s.witness={witnesses:I.witnesses,threshold:I.witnessThreshold||I.witnesses.length}),"watchers"in I&&(s.watchers=I.watchers??null)}if(a=Xe(N),r=a.id,g(u)||u===n.length-1){a.service=a.service||[];let k=js(r);a.service.some(T=>T.id==="#files")||a.service.push({id:"#files",type:"relativeRef",serviceEndpoint:k}),a.service.some(T=>T.id==="#whois")||a.service.push({"@context":"https://identity.foundation/linked-vp/contexts/v1",id:"#whois",type:"LinkedVerifiablePresentation",serviceEndpoint:`${k}/whois.vp`})}if(t.verificationMethod&&Vs(a,t.verificationMethod)&&(o||(o=Xe(a),c={...s})),(t.versionNumber===parseInt(x)||t.versionId===s.versionId)&&(o||(o=Xe(a),c={...s})),t.versionTime&&t.versionTime>new Date(s.updated)&&(n[u+1]&&t.versionTime<new Date(n[u+1].versionTime)?o||(o=Xe(a),c={...s}):n[u+1]||o||(o=Xe(a),c={...s})),s.witness&&u===n.length-1){t.witnessProofs||(t.witnessProofs=await Wf(r));let k=t.witnessProofs.filter(T=>T.versionId===s.versionId);if(k.length>0)await $f(n[u],k,s.witness,t.verifier);else if(s.witness&&s.witness.threshold&&parseInt(s.witness.threshold.toString())>0)throw Error("No witness proofs found for version "+s.versionId)}i=Xe(a),l={...s},u++}}catch(S){if(!o)throw S}if(o||(o=i,c=l),!c)throw Error("DID resolution failed: No valid metadata found");return{did:r,doc:o,meta:c}},Nh=async e=>{let t=e.log,n=t[t.length-1],r=(await Li(t,{verifier:e.verifier,witnessProofs:e.witnessProofs})).meta;if(r.deactivated)throw Error("Cannot update deactivated DID");let a=t.length+1,o=zr(e.updated),i=e.watchers!==void 0?e.watchers:r.watchers,s={updateKeys:e.updateKeys??[],nextKeyHashes:e.nextKeyHashes??[],witness:e.witness!==void 0&&e.witness!==null?{witnesses:e.witness?.witnesses||[],threshold:e.witness?.threshold||0}:{},watchers:i??[]},c=e.verificationMethods?.map(B=>{if(B.secretKeyMultibase){console.warn("Warning: Removing secretKeyMultibase from verification method - secret keys should not be stored in DID documents");let{secretKeyMultibase:I,...b}=B;return b}return B}),{doc:l}=await Hi({...e,controller:e.controller||n.state.id||"",context:e.context||n.state["@context"],domain:e.domain??n.state.id?.split(":").at(-1)??"",updateKeys:e.updateKeys??[],verificationMethods:c??[]});e.services&&e.services.length>0&&(l.service=e.services),e.assertionMethod&&(l.assertionMethod=e.assertionMethod),e.keyAgreement&&(l.keyAgreement=e.keyAgreement);let u={versionId:De,versionTime:o,parameters:s,state:l},d=await ut(u),h=`${a}-${d}`,f={...u,versionId:h},y=await e.signer.sign({document:f,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod"}}),g=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod",proofValue:y.proofValue}];if(f.proof=g,!await Bt(f,r.updateKeys,r.witness,!0,e.verifier))throw Error(`version ${f.versionId} is invalid.`);let S={...r,versionId:f.versionId,updated:f.versionTime,prerotation:(s.nextKeyHashes?.length??0)>0,...s};return{did:f.state.id,doc:f.state,meta:S,log:[...t,f]}},Fh=async e=>{let t=e.log,n=t[t.length-1],r=(await Li(t,{verifier:e.verifier})).meta;if(r.deactivated)throw Error("DID already deactivated");let a=t.length+1,o=zr(),i={updateKeys:e.updateKeys??r.updateKeys,deactivated:!0},s={versionId:De,versionTime:o,parameters:i,state:n.state},c=await ut(s),l=`${a}-${c}`,u={...s,versionId:l},d=await e.signer.sign({document:u,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod"}}),h=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod",proofValue:d.proofValue}];if(u.proof=h,!await Bt(u,r.updateKeys,r.witness,!0,e.verifier))throw Error(`version ${u.versionId} is invalid.`);let f={...r,versionId:u.versionId,updated:u.versionTime,deactivated:!0,updateKeys:i.updateKeys};return{did:u.state.id,doc:u.state,meta:f,log:[...t,u]}},Mh="0.5",Yf=`did:${Ui}:${Mh}`,Ch=async e=>{if(!e.updateKeys)throw Error("Update keys not supplied");e.witness&&e.witness.witnesses&&e.witness.witnesses.length>0&&Gs(e.witness);let t=encodeURIComponent(e.domain),n=e.paths?.join(":"),r=`did:${Ui}:${De}:${t}${n?`:${n}`:""}`,a=zr(e.created),o=e.verificationMethods?.map(g=>{if(g.secretKeyMultibase){console.warn("Warning: Removing secretKeyMultibase from verification method - secret keys should not be stored in DID documents");let{secretKeyMultibase:S,...B}=g;return B}return g}),{doc:i}=await Hi({...e,controller:r,verificationMethods:o}),s={scid:De,updateKeys:e.updateKeys,portable:e.portable??!1,nextKeyHashes:e.nextKeyHashes??[],watchers:e.watchers??null,...e.witness?{witness:e.witness}:{},deactivated:!1},c={versionId:De,versionTime:a,parameters:{method:Yf,...s},state:i},l=await ut(c);s.scid=await Ks(l),c.state=i;let u=JSON.parse(JSON.stringify(c).replaceAll(De,s.scid)),d=await ut(u);u.versionId=`1-${d}`;let h=await e.signer.sign({document:u,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:a,proofPurpose:"assertionMethod"}}),f=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:a,proofPurpose:"assertionMethod",proofValue:h.proofValue}];if(u.proof=f,!await Bt({...u,versionId:`1-${d}`,proof:u.proof},s.updateKeys,s.witness,!0,e.verifier))throw Error(`version ${u.versionId} is invalid.`);let y={};return s.witness&&(y={...s.witness,threshold:s.witness.threshold?.toString()||"0"}),{did:u.state.id,doc:u.state,meta:{versionId:u.versionId,created:u.versionTime,updated:u.versionTime,prerotation:(s.nextKeyHashes?.length??0)>0,...s,witness:y},log:[u]}},Di=async(e,t={})=>{if(t.verificationMethod&&(t.versionNumber||t.versionId))throw Error("Cannot specify both verificationMethod and version number/id");let n=e.map(g=>Xe(g)),r=n[0].parameters.method;if(r!==Yf)throw Error(`'${r}' protocol unknown.`);let a={},o="",i={versionId:"",created:"",updated:"",previousLogEntryHash:"",scid:"",prerotation:!1,portable:!1,nextKeyHashes:[],deactivated:!1,updateKeys:[],witness:void 0,watchers:null},s="",c=0,l=null,u=null,d=null,h=null;try{for(;c<n.length;){let{versionId:g,versionTime:S,parameters:B,state:I,proof:b}=n[c],[w,x]=g.split("-");if(parseInt(w)!==c+1)throw Error(`version '${w}' in log doesn't match expected '${c+1}'.`);i.versionId=g,i.updated=S;let _=I;if(w==="1"){i.created=S,_=I,s=_.id.split(":").at(-1),i.scid=B.scid,i.portable=B.portable??i.portable,i.updateKeys=B.updateKeys,i.nextKeyHashes=B.nextKeyHashes||[],i.prerotation=i.nextKeyHashes.length>0,i.witness=B.witness||i.witness,i.watchers=B.watchers??null,i.nextKeyHashes=B.nextKeyHashes??[];let k={versionId:De,versionTime:i.created,parameters:br(B,i.scid,De),state:br(_,i.scid,De)},T=await ut(k);if(i.previousLogEntryHash=T,!await Jf(i.scid,T))throw Error(`SCID '${i.scid}' not derived from logEntryHash '${T}'`);let L=br(k,De,i.scid),F=await ut(L);if(!await Bt({...L,versionId:`1-${F}`,proof:b},i.updateKeys,i.witness,!1,t.verifier))throw Error(`version ${i.versionId} failed verification of the proof.`)}else{let k=_.id.split(":").at(-1);if(!i.portable&&k!==s)throw Error("Cannot move DID: portability is disabled");k!==s&&(s=k);let T=i.prerotation?B.updateKeys:i.updateKeys;if(!await Bt(n[c],T,i.witness,!1,t.verifier))throw Error(`version ${i.versionId} failed verification of the proof.`);if(!Xf(`${c+1}-${x}`,g))throw Error(`Hash chain broken at '${i.versionId}'`);i.prerotation&&await zf(B.updateKeys??[],i.nextKeyHashes??[]),B.updateKeys&&(i.updateKeys=B.updateKeys),B.deactivated===!0&&(i.deactivated=!0),B.nextKeyHashes?(i.nextKeyHashes=B.nextKeyHashes,i.prerotation=!0):(i.nextKeyHashes=[],i.prerotation=!1),"witness"in B?i.witness=B.witness:B.witnesses&&(i.witness={witnesses:B.witnesses,threshold:B.witnessThreshold||B.witnesses.length.toString()}),"watchers"in B&&(i.watchers=B.watchers??null)}a=Xe(_),o=a.id,a.service=a.service||[];let N=js(o);if(a.service.some(k=>k.id==="#files")||a.service.push({id:"#files",type:"relativeRef",serviceEndpoint:N}),a.service.some(k=>k.id==="#whois")||a.service.push({"@context":"https://identity.foundation/linked-vp/contexts/v1",id:"#whois",type:"LinkedVerifiablePresentation",serviceEndpoint:`${N}/whois.vp`}),t.verificationMethod&&Vs(a,t.verificationMethod)&&(l||(l=Xe(a),u={...i})),(t.versionNumber===parseInt(w)||t.versionId===i.versionId)&&(l||(l=Xe(a),u={...i})),t.versionTime&&t.versionTime>new Date(i.updated)&&(n[c+1]&&t.versionTime<new Date(n[c+1].versionTime)?l||(l=Xe(a),u={...i}):n[c+1]||l||(l=Xe(a),u={...i})),i.witness&&c===n.length-1){t.witnessProofs||(t.witnessProofs=await Wf(o));let k=t.witnessProofs.filter(T=>T.versionId===i.versionId);if(k.length>0)await $f(n[c],k,i.witness,t.verifier);else if(i.witness&&i.witness.threshold&&parseInt(i.witness.threshold.toString())>0)throw Error("No witness proofs found for version "+i.versionId)}d=Xe(a),h={...i},c++}}catch(g){if(!l)throw g}if(!d||!h)throw Error("DID log is invalid");let f=l||d,y=u||h;return y.latestVersionId=h.versionId,y.witness&&(y.witness.threshold=y.witness.threshold?.toString()||"0"),{did:f.id,doc:f,meta:y}},jh=async e=>{let t=e.log,n=t[t.length-1],r=(await Di(t,{verifier:e.verifier,witnessProofs:e.witnessProofs})).meta;if(r.deactivated)throw Error("Cannot update deactivated DID");let a=t.length+1,o=zr(e.updated),i=e.watchers!==void 0?e.watchers:r.watchers,s={updateKeys:e.updateKeys??[],nextKeyHashes:e.nextKeyHashes??[],...e.witness===null?{witness:{}}:e.witness!==void 0?{witnesses:e.witness?.witnesses||[],threshold:e.witness?.threshold||"0"}:{},watchers:i??null},c=e.verificationMethods?.map(B=>{if(B.secretKeyMultibase){console.warn("Warning: Removing secretKeyMultibase from verification method - secret keys should not be stored in DID documents");let{secretKeyMultibase:I,...b}=B;return b}return B}),{doc:l}=await Hi({...e,controller:e.controller||n.state.id||"",context:e.context||n.state["@context"],domain:e.domain??n.state.id?.split(":").at(-1)??"",updateKeys:e.updateKeys??[],verificationMethods:c??[]});e.services&&e.services.length>0&&(l.service=e.services),e.assertionMethod&&(l.assertionMethod=e.assertionMethod),e.keyAgreement&&(l.keyAgreement=e.keyAgreement);let u={versionId:De,versionTime:o,parameters:s,state:l},d=await ut(u),h=`${a}-${d}`,f={...u,versionId:h},y=await e.signer.sign({document:f,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod"}}),g=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod",proofValue:y.proofValue}];if(f.proof=g,!await Bt(f,r.updateKeys,r.witness,!0,e.verifier))throw Error(`version ${f.versionId} is invalid.`);let S={...r,versionId:f.versionId,updated:f.versionTime,prerotation:(s.nextKeyHashes?.length??0)>0,...s};return{did:f.state.id,doc:f.state,meta:S,log:[...t,f]}},qh=async e=>{let t=e.log,n=t[t.length-1],r=(await Di(t,{verifier:e.verifier})).meta;if(r.deactivated)throw Error("DID already deactivated");let a=t.length+1,o=zr(),i={updateKeys:e.updateKeys??r.updateKeys,deactivated:!0},s={versionId:De,versionTime:o,parameters:i,state:n.state},c=await ut(s),l=`${a}-${c}`,u={...s,versionId:l},d=await e.signer.sign({document:u,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod"}}),h=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e.signer.getVerificationMethodId(),created:o,proofPurpose:"assertionMethod",proofValue:d.proofValue}];if(u.proof=h,!await Bt(u,r.updateKeys,r.witness,!0,e.verifier))throw Error(`version ${u.versionId} is invalid.`);let f={...r,versionId:u.versionId,updated:u.versionTime,deactivated:!0,updateKeys:i.updateKeys};return{did:u.state.id,doc:u.state,meta:f,log:[...t,u]}},bi="1.0";function Zf(e){if(!e)return bi;let t=e.match(/^did:webvh:(\d+\.\d+)$/);return t?t[1]:bi}function Ni(e){return e&&e.length>0&&e[0].parameters&&e[0].parameters.method?Zf(e[0].parameters.method):bi}function Ws(e){return e&&e.method?Zf(e.method):bi}var Kh=async e=>{let t=Ws(e)==="0.5"?await Ch(e):await Dh(e);return Vr(t.did,t.log),t},Vh=async(e,t={})=>{let n=(await Rh()).includes(e),r,a=e.split(":");a.length>2&&a[0]==="did"&&a[1]==="webvh"&&(r=a[2]);try{let o=await _h(e,n),i=Ni(o),s={...t,scid:r};if(i==="0.5"){let l=await Di(o,s);return Vr(l.did,o),{...l,controlled:n}}let c=await Li(o,s);return Vr(c.did,o),{...c,controlled:n}}catch(o){let i="INVALID_DID",s=o instanceof Error?o.message:String(o);return(/not found/i.test(s)||/404/.test(s))&&(i="notFound"),{did:e,doc:null,meta:{error:i,problemDetails:{type:i==="notFound"?"https://w3id.org/security#NOT_FOUND":"https://w3id.org/security#INVALID_CONTROLLED_IDENTIFIER_DOCUMENT_ID",title:i==="notFound"?"The DID Log or resource was not found.":"The resolved DID is invalid.",detail:s}},controlled:n}}},Qf=async(e,t={})=>{if(Ni(e)==="0.5"){let r=await Di(e,t);return Vr(r.did,e),r}let n=await Li(e,t);return Vr(n.did,e),n},Gh=async e=>{let t=(e.log?Ni(e.log):Ws(e))==="0.5"?await jh(e):await Nh(e);return Vr(t.did,t.log),t},Wh=async e=>{let t=(e.log?Ni(e.log):Ws(e))==="0.5"?await qh(e):await Fh(e);return Vr(t.did,t.log),t},$s=e=>({type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:e,created:zr(),proofPurpose:"assertionMethod"}),$h=async(e,t)=>{let n=await Er(Kr(e)),r=await Er(Kr(t));return Fs(r,n)};class Xh{verificationMethod;useStaticId;constructor(t){t.verificationMethod&&(this.verificationMethod=t.verificationMethod),this.useStaticId=t.useStaticId!==void 0?t.useStaticId:!0}getVerificationMethodId(){if(!this.verificationMethod)throw Error("Verification method not set");return this.useStaticId?`did:key:${this.verificationMethod.publicKeyMultibase}#${this.verificationMethod.publicKeyMultibase}`:this.verificationMethod.id||""}}var zh=(e,t)=>async n=>{try{let r=$s(t),a=await e.sign({document:n,proof:r});return r.proofValue=a.proofValue,{...n,proof:r}}catch(r){throw console.error(r),Error(`Document signing failure: ${r.message||r}`)}},Jh=(e,t=!0)=>(console.warn("createSigner is deprecated. Use createDocumentSigner with your own Signer implementation instead."),async n=>{try{let r=t?`did:key:${e.publicKeyMultibase}#${e.publicKeyMultibase}`:e.id||"",a=$s(r);throw Error("createSigner is deprecated. Implement your own Signer and use createDocumentSigner instead.")}catch(r){throw console.error(r),Error(`Document signing failure: ${r.message||r}`)}});const Ji=Object.freeze(Object.defineProperty({__proto__:null,AbstractCrypto:Xh,get MultibaseEncoding(){return Ff},createDID:Kh,createDocumentSigner:zh,createProof:$s,createSigner:Jh,deactivateDID:Wh,multibaseDecode:Mn,multibaseEncode:uh,prepareDataForSigning:$h,resolveDID:Vh,resolveDIDFromLog:Qf,updateDID:Gh},Symbol.toStringTag,{value:"Module"}));const el={p:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,n:0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,h:8n,a:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,d:0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,Gx:0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,Gy:0x6666666666666666666666666666666666666666666666666666666666666658n},{p:$e,n:gi,Gx:Ha,Gy:La,a:Yi,d:Zi}=el,Yh=8n,At=32,Cn=64,nt=(e="")=>{throw new Error(e)},Zh=e=>typeof e=="bigint",tl=e=>typeof e=="string",Qh=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",Gr=(e,t)=>!Qh(e)||typeof t=="number"&&t>0&&e.length!==t?nt("Uint8Array expected"):e,Fi=e=>new Uint8Array(e),Xs=e=>Uint8Array.from(e),rl=(e,t)=>e.toString(16).padStart(t,"0"),zs=e=>Array.from(Gr(e)).map(t=>rl(t,2)).join(""),Rt={_0:48,_9:57,A:65,F:70,a:97,f:102},Da=e=>{if(e>=Rt._0&&e<=Rt._9)return e-Rt._0;if(e>=Rt.A&&e<=Rt.F)return e-(Rt.A-10);if(e>=Rt.a&&e<=Rt.f)return e-(Rt.a-10)},Js=e=>{const t="hex invalid";if(!tl(e))return nt(t);const n=e.length,r=n/2;if(n%2)return nt(t);const a=Fi(r);for(let o=0,i=0;o<r;o++,i+=2){const s=Da(e.charCodeAt(i)),c=Da(e.charCodeAt(i+1));if(s===void 0||c===void 0)return nt(t);a[o]=s*16+c}return a},vr=(e,t)=>Gr(tl(e)?Js(e):Xs(Gr(e)),t),nl=()=>globalThis?.crypto,ep=()=>nl()?.subtle??nt("crypto.subtle must be defined"),jn=(...e)=>{const t=Fi(e.reduce((r,a)=>r+Gr(a).length,0));let n=0;return e.forEach(r=>{t.set(r,n),n+=r.length}),t},il=(e=At)=>nl().getRandomValues(Fi(e)),vi=BigInt,Hr=(e,t,n,r="bad number: out of range")=>Zh(e)&&t<=e&&e<n?e:nt(r),he=(e,t=$e)=>{const n=e%t;return n>=0n?n:t+n},ol=e=>he(e,gi),sl=(e,t)=>{(e===0n||t<=0n)&&nt("no inverse n="+e+" mod="+t);let n=he(e,t),r=t,a=0n,o=1n;for(;n!==0n;){const i=r/n,s=r%n,c=a-o*i;r=n,n=s,a=o,o=c}return r===1n?he(a,t):nt("no inverse")},tp=e=>{const t=na[e];return typeof t!="function"&&nt("hashes."+e+" not set"),t},Na=e=>e instanceof Kt?e:nt("Point expected"),Is=2n**256n;let Kt=class Lr{static BASE;static ZERO;ex;ey;ez;et;constructor(t,n,r,a){const o=Is;this.ex=Hr(t,0n,o),this.ey=Hr(n,0n,o),this.ez=Hr(r,1n,o),this.et=Hr(a,0n,o),Object.freeze(this)}static fromAffine(t){return new Lr(t.x,t.y,1n,he(t.x*t.y))}static fromBytes(t,n=!1){const r=Zi,a=Xs(Gr(t,At)),o=t[31];a[31]=o&-129;const i=Ys(a);Hr(i,0n,n?Is:$e);const c=he(i*i),l=he(c-1n),u=he(r*c+1n);let{isValid:d,value:h}=np(l,u);d||nt("bad point: y not sqrt");const f=(h&1n)===1n,y=(o&128)!==0;return!n&&h===0n&&y&&nt("bad point: x==0, isLastByteOdd"),y!==f&&(h=he(-h)),new Lr(h,i,1n,he(h*i))}assertValidity(){const t=Yi,n=Zi,r=this;if(r.is0())throw new Error("bad point: ZERO");const{ex:a,ey:o,ez:i,et:s}=r,c=he(a*a),l=he(o*o),u=he(i*i),d=he(u*u),h=he(c*t),f=he(u*he(h+l)),y=he(d+he(n*he(c*l)));if(f!==y)throw new Error("bad point: equation left != right (1)");const g=he(a*o),S=he(i*s);if(g!==S)throw new Error("bad point: equation left != right (2)");return this}equals(t){const{ex:n,ey:r,ez:a}=this,{ex:o,ey:i,ez:s}=Na(t),c=he(n*s),l=he(o*a),u=he(r*s),d=he(i*a);return c===l&&u===d}is0(){return this.equals(hn)}negate(){return new Lr(he(-this.ex),this.ey,this.ez,he(-this.et))}double(){const{ex:t,ey:n,ez:r}=this,a=Yi,o=he(t*t),i=he(n*n),s=he(2n*he(r*r)),c=he(a*o),l=t+n,u=he(he(l*l)-o-i),d=c+i,h=d-s,f=c-i,y=he(u*h),g=he(d*f),S=he(u*f),B=he(h*d);return new Lr(y,g,B,S)}add(t){const{ex:n,ey:r,ez:a,et:o}=this,{ex:i,ey:s,ez:c,et:l}=Na(t),u=Yi,d=Zi,h=he(n*i),f=he(r*s),y=he(o*d*l),g=he(a*c),S=he((n+r)*(i+s)-h-f),B=he(g-y),I=he(g+y),b=he(f-u*h),w=he(S*B),x=he(I*b),_=he(S*b),N=he(B*I);return new Lr(w,x,N,_)}multiply(t,n=!0){if(!n&&(t===0n||this.is0()))return hn;if(Hr(t,1n,gi),t===1n)return this;if(this.equals(Vt))return fp(t).p;let r=hn,a=Vt;for(let o=this;t>0n;o=o.double(),t>>=1n)t&1n?r=r.add(o):n&&(a=a.add(o));return r}toAffine(){const{ex:t,ey:n,ez:r}=this;if(this.equals(hn))return{x:0n,y:1n};const a=sl(r,$e);return he(r*a)!==1n&&nt("invalid inverse"),{x:he(t*a),y:he(n*a)}}toBytes(){const{x:t,y:n}=this.assertValidity().toAffine(),r=al(n);return r[31]|=t&1n?128:0,r}toHex(){return zs(this.toBytes())}clearCofactor(){return this.multiply(vi(Yh),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let t=this.multiply(gi/2n,!1).double();return gi%2n&&(t=t.add(this)),t.is0()}static fromHex(t,n){return Lr.fromBytes(vr(t),n)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}toRawBytes(){return this.toBytes()}};const Vt=new Kt(Ha,La,1n,he(Ha*La)),hn=new Kt(0n,1n,1n,0n);Kt.BASE=Vt;Kt.ZERO=hn;const al=e=>Js(rl(Hr(e,0n,Is),Cn)).reverse(),Ys=e=>vi("0x"+zs(Xs(Gr(e)).reverse())),xt=(e,t)=>{let n=e;for(;t-- >0n;)n*=n,n%=$e;return n},rp=e=>{const n=e*e%$e*e%$e,r=xt(n,2n)*n%$e,a=xt(r,1n)*e%$e,o=xt(a,5n)*a%$e,i=xt(o,10n)*o%$e,s=xt(i,20n)*i%$e,c=xt(s,40n)*s%$e,l=xt(c,80n)*c%$e,u=xt(l,80n)*c%$e,d=xt(u,10n)*o%$e;return{pow_p_5_8:xt(d,2n)*e%$e,b2:n}},Fa=0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n,np=(e,t)=>{const n=he(t*t*t),r=he(n*n*t),a=rp(e*r).pow_p_5_8;let o=he(e*n*a);const i=he(t*o*o),s=o,c=he(o*Fa),l=i===e,u=i===he(-e),d=i===he(-e*Fa);return l&&(o=s),(u||d)&&(o=c),(he(o)&1n)===1n&&(o=he(-o)),{isValid:l||u,value:o}},Ei=e=>ol(Ys(e)),Zs=(...e)=>na.sha512Async(...e),Qs=(...e)=>tp("sha512Sync")(...e),cl=e=>{const t=e.slice(0,At);t[0]&=248,t[31]&=127,t[31]|=64;const n=e.slice(At,Cn),r=Ei(t),a=Vt.multiply(r),o=a.toBytes();return{head:t,prefix:n,scalar:r,point:a,pointBytes:o}},ea=e=>Zs(vr(e,At)).then(cl),ta=e=>cl(Qs(vr(e,At))),ip=e=>ea(e).then(t=>t.pointBytes),op=e=>ta(e).pointBytes,ul=e=>Zs(e.hashable).then(e.finish),fl=e=>e.finish(Qs(e.hashable)),ll=(e,t,n)=>{const{pointBytes:r,scalar:a}=e,o=Ei(t),i=Vt.multiply(o).toBytes();return{hashable:jn(i,r,n),finish:l=>{const u=ol(o+Ei(l)*a);return Gr(jn(i,al(u)),Cn)}}},dl=async(e,t)=>{const n=vr(e),r=await ea(t),a=await Zs(r.prefix,n);return ul(ll(r,a,n))},sp=(e,t)=>{const n=vr(e),r=ta(t),a=Qs(r.prefix,n);return fl(ll(r,a,n))},ra={zip215:!0},hl=(e,t,n,r=ra)=>{e=vr(e,Cn),t=vr(t),n=vr(n,At);const{zip215:a}=r;let o,i,s,c,l=Uint8Array.of();try{o=Kt.fromHex(n,a),i=Kt.fromHex(e.slice(0,At),a),s=Ys(e.slice(At,Cn)),c=Vt.multiply(s,!1),l=jn(i.toBytes(),o.toBytes(),t)}catch{}return{hashable:l,finish:d=>{if(c==null||!a&&o.isSmallOrder())return!1;const h=Ei(d);return i.add(o.multiply(h,!1)).add(c.negate()).clearCofactor().is0()}}},pl=async(e,t,n,r=ra)=>ul(hl(e,t,n,r)),ap=(e,t,n,r=ra)=>fl(hl(e,t,n,r)),na={sha512Async:async(...e)=>{const t=ep(),n=jn(...e);return Fi(await t.digest("SHA-512",n.buffer))},sha512Sync:void 0,bytesToHex:zs,hexToBytes:Js,concatBytes:jn,mod:he,invert:sl,randomBytes:il},yl={getExtendedPublicKeyAsync:ea,getExtendedPublicKey:ta,randomPrivateKey:()=>il(At),precompute:(e=8,t=Vt)=>(t.multiply(3n),t)},xi=8,cp=256,gl=Math.ceil(cp/xi)+1,_s=2**(xi-1),up=()=>{const e=[];let t=Vt,n=t;for(let r=0;r<gl;r++){n=t,e.push(n);for(let a=1;a<_s;a++)n=n.add(t),e.push(n);t=n.double()}return e};let Ma;const Ca=(e,t)=>{const n=t.negate();return e?n:t},fp=e=>{const t=Ma||(Ma=up());let n=hn,r=Vt;const a=2**xi,o=a,i=vi(a-1),s=vi(xi);for(let c=0;c<gl;c++){let l=Number(e&i);e>>=s,l>_s&&(l-=o,e+=1n);const u=c*_s,d=u,h=u+Math.abs(l)-1,f=c%2!==0,y=l<0;l===0?r=r.add(Ca(f,t[d])):n=n.add(Ca(y,t[h]))}return{p:n,f:r}},wl=Object.freeze(Object.defineProperty({__proto__:null,CURVE:el,ExtendedPoint:Kt,Point:Kt,etc:na,getPublicKey:op,getPublicKeyAsync:ip,sign:sp,signAsync:dl,utils:yl,verify:ap,verifyAsync:pl},Symbol.toStringTag,{value:"Module"}));const ml={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:Cr,n:kt,Gx:lp,Gy:dp,b:bl}=ml,it=32,jr=64,Le=(e="")=>{throw new Error(e)},vl=e=>typeof e=="bigint",El=e=>typeof e=="string",hp=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",Wr=(e,t)=>!hp(e)||typeof t=="number"&&t>0&&e.length!==t?Le("Uint8Array expected"):e,qr=e=>new Uint8Array(e),pp=e=>Uint8Array.from(e),xl=(e,t)=>e.toString(16).padStart(t,"0"),Mi=e=>Array.from(Wr(e)).map(t=>xl(t,2)).join(""),Pt={_0:48,_9:57,A:65,F:70,a:97,f:102},ja=e=>{if(e>=Pt._0&&e<=Pt._9)return e-Pt._0;if(e>=Pt.A&&e<=Pt.F)return e-(Pt.A-10);if(e>=Pt.a&&e<=Pt.f)return e-(Pt.a-10)},ia=e=>{const t="hex invalid";if(!El(e))return Le(t);const n=e.length,r=n/2;if(n%2)return Le(t);const a=qr(r);for(let o=0,i=0;o<r;o++,i+=2){const s=ja(e.charCodeAt(i)),c=ja(e.charCodeAt(i+1));if(s===void 0||c===void 0)return Le(t);a[o]=s*16+c}return a},yt=(e,t)=>Wr(El(e)?ia(e):pp(Wr(e)),t),Sl=()=>globalThis?.crypto,yp=()=>Sl()?.subtle??Le("crypto.subtle must be defined"),$r=(...e)=>{const t=qr(e.reduce((r,a)=>r+Wr(a).length,0));let n=0;return e.forEach(r=>{t.set(r,n),n+=r.length}),t},oa=(e=it)=>Sl().getRandomValues(qr(e)),mn=BigInt,Kn=(e,t,n,r="bad number: out of range")=>vl(e)&&t<=e&&e<n?e:Le(r),ge=(e,t=Cr)=>{const n=e%t;return n>=0n?n:t+n},ct=e=>ge(e,kt),Vn=(e,t)=>{(e===0n||t<=0n)&&Le("no inverse n="+e+" mod="+t);let n=ge(e,t),r=t,a=0n,o=1n;for(;n!==0n;){const i=r/n,s=r%n,c=a-o*i;r=n,n=s,a=o,o=c}return r===1n?ge(a,t):Le("no inverse")},gp=e=>{const t=ca[e];return typeof t!="function"&&Le("hashes."+e+" not set"),t},qa=e=>e instanceof je?e:Le("Point expected"),Il=e=>ge(ge(e*e)*e+bl),Ka=e=>Kn(e,0n,Cr),Fn=e=>Kn(e,1n,Cr),As=e=>Kn(e,1n,kt),Ts=e=>(e&1n)===0n,pn=e=>Uint8Array.of(e),_l=e=>pn(Ts(e)?2:3),wp=e=>{const t=Il(Fn(e));let n=1n;for(let r=t,a=(Cr+1n)/4n;a>0n;a>>=1n)a&1n&&(n=n*r%Cr),r=r*r%Cr;return ge(n*n)===t?n:Le("sqrt invalid")};class je{static BASE;static ZERO;px;py;pz;constructor(t,n,r){this.px=Ka(t),this.py=Fn(n),this.pz=Ka(r),Object.freeze(this)}static fromBytes(t){Wr(t);let n;const r=t[0],a=t.subarray(1),o=Si(a,0,it),i=t.length;if(i===it+1&&[2,3].includes(r)){let s=wp(o);const c=Ts(s);Ts(mn(r))!==c&&(s=ge(-s)),n=new je(o,s,1n)}return i===jr+1&&r===4&&(n=new je(o,Si(a,it,jr),1n)),n?n.assertValidity():Le("bad point: not on curve")}equals(t){const{px:n,py:r,pz:a}=this,{px:o,py:i,pz:s}=qa(t),c=ge(n*s),l=ge(o*a),u=ge(r*s),d=ge(i*a);return c===l&&u===d}is0(){return this.equals(Dr)}negate(){return new je(this.px,ge(-this.py),this.pz)}double(){return this.add(this)}add(t){const{px:n,py:r,pz:a}=this,{px:o,py:i,pz:s}=qa(t),c=0n,l=bl;let u=0n,d=0n,h=0n;const f=ge(l*3n);let y=ge(n*o),g=ge(r*i),S=ge(a*s),B=ge(n+r),I=ge(o+i);B=ge(B*I),I=ge(y+g),B=ge(B-I),I=ge(n+a);let b=ge(o+s);return I=ge(I*b),b=ge(y+S),I=ge(I-b),b=ge(r+a),u=ge(i+s),b=ge(b*u),u=ge(g+S),b=ge(b-u),h=ge(c*I),u=ge(f*S),h=ge(u+h),u=ge(g-h),h=ge(g+h),d=ge(u*h),g=ge(y+y),g=ge(g+y),S=ge(c*S),I=ge(f*I),g=ge(g+S),S=ge(y-S),S=ge(c*S),I=ge(I+S),y=ge(g*I),d=ge(d+y),y=ge(b*I),u=ge(B*u),u=ge(u-y),y=ge(B*g),h=ge(b*h),h=ge(h+y),new je(u,d,h)}multiply(t,n=!0){if(!n&&t===0n)return Dr;if(As(t),t===1n)return this;if(this.equals(Tt))return kp(t).p;let r=Dr,a=Tt;for(let o=this;t>0n;o=o.double(),t>>=1n)t&1n?r=r.add(o):n&&(a=a.add(o));return r}toAffine(){const{px:t,py:n,pz:r}=this;if(this.equals(Dr))return{x:0n,y:0n};if(r===1n)return{x:t,y:n};const a=Vn(r,Cr);return ge(r*a)!==1n&&Le("inverse invalid"),{x:ge(t*a),y:ge(n*a)}}assertValidity(){const{x:t,y:n}=this.toAffine();return Fn(t),Fn(n),ge(n*n)===Il(t)?this:Le("bad point: not on curve")}toBytes(t=!0){const{x:n,y:r}=this.assertValidity().toAffine(),a=xr(n);return t?$r(_l(r),a):$r(pn(4),a,xr(r))}static fromAffine(t){const{x:n,y:r}=t;return n===0n&&r===0n?Dr:new je(n,r,1n)}toHex(t){return Mi(this.toBytes(t))}static fromPrivateKey(t){return Tt.multiply(bn(t))}static fromHex(t){return je.fromBytes(yt(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}toRawBytes(t){return this.toBytes(t)}}const Tt=new je(lp,dp,1n),Dr=new je(0n,1n,0n);je.BASE=Tt;je.ZERO=Dr;const Al=(e,t,n)=>Tt.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),Gn=e=>mn("0x"+(Mi(e)||"0")),Si=(e,t,n)=>Gn(e.subarray(t,n)),mp=2n**256n,xr=e=>ia(xl(Kn(e,0n,mp),jr)),bn=e=>{const t=vl(e)?e:Gn(yt(e,it));return Kn(t,1n,kt,"private key invalid 3")},Ii=e=>e>kt>>1n,Tl=(e,t=!0)=>Tt.multiply(bn(e)).toBytes(t);class jt{r;s;recovery;constructor(t,n,r){this.r=As(t),this.s=As(n),r!=null&&(this.recovery=r),Object.freeze(this)}static fromBytes(t){Wr(t,jr);const n=Si(t,0,it),r=Si(t,it,jr);return new jt(n,r)}toBytes(){const{r:t,s:n}=this;return $r(xr(t),xr(n))}addRecoveryBit(t){return new jt(this.r,this.s,t)}hasHighS(){return Ii(this.s)}toCompactRawBytes(){return this.toBytes()}toCompactHex(){return Mi(this.toBytes())}recoverPublicKey(t){return Sp(this,t)}static fromCompact(t){return jt.fromBytes(yt(t,jr))}assertValidity(){return this}normalizeS(){const{r:t,s:n,recovery:r}=this;return Ii(n)?new jt(t,ct(-n),r):this}}const Bl=e=>{const t=e.length*8-256;t>1024&&Le("msg invalid");const n=Gn(e);return t>0?n>>mn(t):n},sa=e=>ct(Bl(Wr(e))),aa={lowS:!0},bp={lowS:!0},kl=(e,t,n=aa)=>{["der","recovered","canonical"].some(h=>h in n)&&Le("option not supported");let{lowS:r,extraEntropy:a}=n;r==null&&(r=!0);const o=xr,i=sa(yt(e)),s=o(i),c=bn(t),l=[o(c),s];a&&l.push(a===!0?oa(it):yt(a));const u=i,d=h=>{const f=Bl(h);if(!(1n<=f&&f<kt))return;const y=Tt.multiply(f).toAffine(),g=ct(y.x);if(g===0n)return;const S=Vn(f,kt),B=ct(S*ct(u+ct(c*g)));if(B===0n)return;let I=B,b=(y.x===g?0:2)|Number(y.y&1n);return r&&Ii(B)&&(I=ct(-B),b^=1),new jt(g,I,b)};return{seed:$r(...l),k2sig:d}},Ol=e=>{let t=qr(it),n=qr(it),r=0;const a=qr(0),o=()=>{t.fill(1),n.fill(0),r=0},i=1e3,s="drbg: tried 1000 values";if(e){const c=(...d)=>ca.hmacSha256Async(n,t,...d),l=async(d=a)=>{n=await c(pn(0),d),t=await c(),d.length!==0&&(n=await c(pn(1),d),t=await c())},u=async()=>(r++>=i&&Le(s),t=await c(),t);return async(d,h)=>{o(),await l(d);let f;for(;!(f=h(await u()));)await l();return o(),f}}else{const c=(...d)=>gp("hmacSha256Sync")(n,t,...d),l=(d=a)=>{n=c(pn(0),d),t=c(),d.length!==0&&(n=c(pn(1),d),t=c())},u=()=>(r++>=i&&Le(s),t=c(),t);return(d,h)=>{o(),l(d);let f;for(;!(f=h(u()));)l();return o(),f}}},vp=async(e,t,n=aa)=>{const{seed:r,k2sig:a}=kl(e,t,n);return await Ol(!0)(r,a)},Ep=(e,t,n=aa)=>{const{seed:r,k2sig:a}=kl(e,t,n);return Ol(!1)(r,a)},xp=(e,t,n,r=bp)=>{let{lowS:a}=r;a==null&&(a=!0),"strict"in r&&Le("option not supported");let o;const i=e&&typeof e=="object"&&"r"in e;!i&&yt(e).length!==jr&&Le("signature must be 64 bytes");try{o=i?new jt(e.r,e.s):jt.fromCompact(e);const s=sa(yt(t)),c=je.fromBytes(yt(n)),{r:l,s:u}=o;if(a&&Ii(u))return!1;const d=Vn(u,kt),h=ct(s*d),f=ct(l*d),y=Al(c,h,f).toAffine();return ct(y.x)===l}catch{return!1}},Sp=(e,t)=>{const{r:n,s:r,recovery:a}=e;[0,1,2,3].includes(a)||Le("recovery id invalid");const o=sa(yt(t,it)),i=a===2||a===3?n+kt:n;Fn(i);const s=_l(mn(a)),c=$r(s,xr(i)),l=je.fromBytes(c),u=Vn(i,kt),d=ct(-o*u),h=ct(r*u);return Al(l,d,h)},Ip=(e,t,n=!0)=>je.fromBytes(yt(t)).multiply(bn(e)).toBytes(n),Rl=e=>{e=yt(e),(e.length<it+8||e.length>1024)&&Le("expected 40-1024b");const t=ge(Gn(e),kt-1n);return xr(t+1n)},_p=()=>Rl(oa(it+16)),Ap="SHA-256",ca={hexToBytes:ia,bytesToHex:Mi,concatBytes:$r,bytesToNumberBE:Gn,numberToBytesBE:xr,mod:ge,invert:Vn,hmacSha256Async:async(e,...t)=>{const n=yp(),r="HMAC",a=await n.importKey("raw",e,{name:r,hash:{name:Ap}},!1,["sign"]);return qr(await n.sign(r,a,$r(...t)))},hmacSha256Sync:void 0,hashToPrivateKey:Rl,randomBytes:oa},Pl={normPrivateKeyToScalar:bn,isValidPrivateKey:e=>{try{return!!bn(e)}catch{return!1}},randomPrivateKey:_p,precompute:(e=8,t=Tt)=>(t.multiply(3n),t)},_i=8,Tp=256,Ul=Math.ceil(Tp/_i)+1,Bs=2**(_i-1),Bp=()=>{const e=[];let t=Tt,n=t;for(let r=0;r<Ul;r++){n=t,e.push(n);for(let a=1;a<Bs;a++)n=n.add(t),e.push(n);t=n.double()}return e};let Va;const Ga=(e,t)=>{const n=t.negate();return e?n:t},kp=e=>{const t=Va||(Va=Bp());let n=Dr,r=Tt;const a=2**_i,o=a,i=mn(a-1),s=mn(_i);for(let c=0;c<Ul;c++){let l=Number(e&i);e>>=s,l>Bs&&(l-=o,e+=1n);const u=c*Bs,d=u,h=u+Math.abs(l)-1,f=c%2!==0,y=l<0;l===0?r=r.add(Ga(f,t[d])):n=n.add(Ga(y,t[h]))}return{p:n,f:r}},Op=Object.freeze(Object.defineProperty({__proto__:null,CURVE:ml,Point:je,ProjectivePoint:je,Signature:jt,etc:ca,getPublicKey:Tl,getSharedSecret:Ip,sign:Ep,signAsync:vp,utils:Pl,verify:xp},Symbol.toStringTag,{value:"Module"}));function Rp(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Wa(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function qn(e,t,n=""){const r=Rp(e),a=e?.length,o=t!==void 0;if(!r||o&&a!==t){const i=n&&`"${n}" `,s=o?` of length ${t}`:"",c=r?`length=${a}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+s+", got "+c)}return e}function Pp(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Wa(e.outputLen),Wa(e.blockLen)}function Ai(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Up(e,t){qn(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function vn(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function Qi(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function St(e,t){return e<<32-t|e>>>t}function Hl(...e){let t=0;for(let r=0;r<e.length;r++){const a=e[r];qn(a),t+=a.length}const n=new Uint8Array(t);for(let r=0,a=0;r<e.length;r++){const o=e[r];n.set(o,a),a+=o.length}return n}function Ll(e,t={}){const n=(a,o)=>e(o).update(a).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=a=>e(a),Object.assign(n,t),Object.freeze(n)}const Dl=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Hp(e,t,n){return e&t^~e&n}function Lp(e,t,n){return e&t^e&n^t&n}let Nl=class{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,n,r,a){this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=a,this.buffer=new Uint8Array(t),this.view=Qi(this.buffer)}update(t){Ai(this),qn(t);const{view:n,buffer:r,blockLen:a}=this,o=t.length;for(let i=0;i<o;){const s=Math.min(a-this.pos,o-i);if(s===a){const c=Qi(t);for(;a<=o-i;i+=a)this.process(c,i);continue}r.set(t.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===a&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ai(this),Up(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:a,isLE:o}=this;let{pos:i}=this;n[i++]=128,vn(this.buffer.subarray(i)),this.padOffset>a-i&&(this.process(r,0),i=0);for(let d=i;d<a;d++)n[d]=0;r.setBigUint64(a-8,BigInt(this.length*8),o),this.process(r,0);const s=Qi(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)s.setUint32(4*d,u[d],o)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:n,buffer:r,length:a,finished:o,destroyed:i,pos:s}=this;return t.destroyed=i,t.finished=o,t.length=a,t.pos=s,a%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}};const Yt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ke=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Zn=BigInt(2**32-1),$a=BigInt(32);function Dp(e,t=!1){return t?{h:Number(e&Zn),l:Number(e>>$a&Zn)}:{h:Number(e>>$a&Zn)|0,l:Number(e&Zn)|0}}function Np(e,t=!1){const n=e.length;let r=new Uint32Array(n),a=new Uint32Array(n);for(let o=0;o<n;o++){const{h:i,l:s}=Dp(e[o],t);[r[o],a[o]]=[i,s]}return[r,a]}const Xa=(e,t,n)=>e>>>n,za=(e,t,n)=>e<<32-n|t>>>n,rn=(e,t,n)=>e>>>n|t<<32-n,nn=(e,t,n)=>e<<32-n|t>>>n,Qn=(e,t,n)=>e<<64-n|t>>>n-32,ei=(e,t,n)=>e>>>n-32|t<<64-n;function Ut(e,t,n,r){const a=(t>>>0)+(r>>>0);return{h:e+n+(a/2**32|0)|0,l:a|0}}const Fp=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Mp=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,Cp=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),jp=(e,t,n,r,a)=>t+n+r+a+(e/2**32|0)|0,qp=(e,t,n,r,a)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(a>>>0),Kp=(e,t,n,r,a,o)=>t+n+r+a+o+(e/2**32|0)|0,Vp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Zt=new Uint32Array(64);class Gp extends Nl{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:n,C:r,D:a,E:o,F:i,G:s,H:c}=this;return[t,n,r,a,o,i,s,c]}set(t,n,r,a,o,i,s,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=a|0,this.E=o|0,this.F=i|0,this.G=s|0,this.H=c|0}process(t,n){for(let d=0;d<16;d++,n+=4)Zt[d]=t.getUint32(n,!1);for(let d=16;d<64;d++){const h=Zt[d-15],f=Zt[d-2],y=St(h,7)^St(h,18)^h>>>3,g=St(f,17)^St(f,19)^f>>>10;Zt[d]=g+Zt[d-7]+y+Zt[d-16]|0}let{A:r,B:a,C:o,D:i,E:s,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const h=St(s,6)^St(s,11)^St(s,25),f=u+h+Hp(s,c,l)+Vp[d]+Zt[d]|0,g=(St(r,2)^St(r,13)^St(r,22))+Lp(r,a,o)|0;u=l,l=c,c=s,s=i+f|0,i=o,o=a,a=r,r=f+g|0}r=r+this.A|0,a=a+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(r,a,o,i,s,c,l,u)}roundClean(){vn(Zt)}destroy(){this.set(0,0,0,0,0,0,0,0),vn(this.buffer)}}class Wp extends Gp{A=Yt[0]|0;B=Yt[1]|0;C=Yt[2]|0;D=Yt[3]|0;E=Yt[4]|0;F=Yt[5]|0;G=Yt[6]|0;H=Yt[7]|0;constructor(){super(32)}}const Fl=Np(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),$p=Fl[0],Xp=Fl[1],Qt=new Uint32Array(80),er=new Uint32Array(80);class zp extends Nl{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:n,Bh:r,Bl:a,Ch:o,Cl:i,Dh:s,Dl:c,Eh:l,El:u,Fh:d,Fl:h,Gh:f,Gl:y,Hh:g,Hl:S}=this;return[t,n,r,a,o,i,s,c,l,u,d,h,f,y,g,S]}set(t,n,r,a,o,i,s,c,l,u,d,h,f,y,g,S){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=a|0,this.Ch=o|0,this.Cl=i|0,this.Dh=s|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=h|0,this.Gh=f|0,this.Gl=y|0,this.Hh=g|0,this.Hl=S|0}process(t,n){for(let b=0;b<16;b++,n+=4)Qt[b]=t.getUint32(n),er[b]=t.getUint32(n+=4);for(let b=16;b<80;b++){const w=Qt[b-15]|0,x=er[b-15]|0,_=rn(w,x,1)^rn(w,x,8)^Xa(w,x,7),N=nn(w,x,1)^nn(w,x,8)^za(w,x,7),k=Qt[b-2]|0,T=er[b-2]|0,L=rn(k,T,19)^Qn(k,T,61)^Xa(k,T,6),F=nn(k,T,19)^ei(k,T,61)^za(k,T,6),O=Cp(N,F,er[b-7],er[b-16]),R=jp(O,_,L,Qt[b-7],Qt[b-16]);Qt[b]=R|0,er[b]=O|0}let{Ah:r,Al:a,Bh:o,Bl:i,Ch:s,Cl:c,Dh:l,Dl:u,Eh:d,El:h,Fh:f,Fl:y,Gh:g,Gl:S,Hh:B,Hl:I}=this;for(let b=0;b<80;b++){const w=rn(d,h,14)^rn(d,h,18)^Qn(d,h,41),x=nn(d,h,14)^nn(d,h,18)^ei(d,h,41),_=d&f^~d&g,N=h&y^~h&S,k=qp(I,x,N,Xp[b],er[b]),T=Kp(k,B,w,_,$p[b],Qt[b]),L=k|0,F=rn(r,a,28)^Qn(r,a,34)^Qn(r,a,39),O=nn(r,a,28)^ei(r,a,34)^ei(r,a,39),R=r&o^r&s^o&s,P=a&i^a&c^i&c;B=g|0,I=S|0,g=f|0,S=y|0,f=d|0,y=h|0,{h:d,l:h}=Ut(l|0,u|0,T|0,L|0),l=s|0,u=c|0,s=o|0,c=i|0,o=r|0,i=a|0;const K=Fp(L,O,P);r=Mp(K,T,F,R),a=K|0}({h:r,l:a}=Ut(this.Ah|0,this.Al|0,r|0,a|0)),{h:o,l:i}=Ut(this.Bh|0,this.Bl|0,o|0,i|0),{h:s,l:c}=Ut(this.Ch|0,this.Cl|0,s|0,c|0),{h:l,l:u}=Ut(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:h}=Ut(this.Eh|0,this.El|0,d|0,h|0),{h:f,l:y}=Ut(this.Fh|0,this.Fl|0,f|0,y|0),{h:g,l:S}=Ut(this.Gh|0,this.Gl|0,g|0,S|0),{h:B,l:I}=Ut(this.Hh|0,this.Hl|0,B|0,I|0),this.set(r,a,o,i,s,c,l,u,d,h,f,y,g,S,B,I)}roundClean(){vn(Qt,er)}destroy(){vn(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Jp extends zp{Ah=Ke[0]|0;Al=Ke[1]|0;Bh=Ke[2]|0;Bl=Ke[3]|0;Ch=Ke[4]|0;Cl=Ke[5]|0;Dh=Ke[6]|0;Dl=Ke[7]|0;Eh=Ke[8]|0;El=Ke[9]|0;Fh=Ke[10]|0;Fl=Ke[11]|0;Gh=Ke[12]|0;Gl=Ke[13]|0;Hh=Ke[14]|0;Hl=Ke[15]|0;constructor(){super(64)}}const Yp=Ll(()=>new Wp,Dl(1)),Zp=Ll(()=>new Jp,Dl(3));class Ml{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,n){if(Pp(t),qn(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,a=new Uint8Array(r);a.set(n.length>r?t.create().update(n).digest():n);for(let o=0;o<a.length;o++)a[o]^=54;this.iHash.update(a),this.oHash=t.create();for(let o=0;o<a.length;o++)a[o]^=106;this.oHash.update(a),vn(a)}update(t){return Ai(this),this.iHash.update(t),this}digestInto(t){Ai(this),qn(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:n,iHash:r,finished:a,destroyed:o,blockLen:i,outputLen:s}=this;return t=t,t.finished=a,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Cl=(e,t,n)=>new Ml(e,t).update(n).digest();Cl.create=(e,t)=>new Ml(e,t);const Ja=(...e)=>Zp(Hl(...e)),Qp=(e,...t)=>Cl(Yp,e,Hl(...t));function ks(e,t,n,r){try{return e[t]=n,!0}catch{try{return Object.defineProperty(e,t,{value:n,writable:r?.writable??!0,configurable:r?.configurable??!0}),!0}catch{return!1}}}function e0(){const e=Op;if(!e?.utils)try{e.utils={}}catch{Object.defineProperty(e,"utils",{value:{},writable:!0,configurable:!0})}typeof e.utils.hmacSha256Sync!="function"&&ks(e.utils,"hmacSha256Sync",Qp)}function t0(){const e=wl;if(e?.etc&&typeof e.etc.sha512Sync!="function"&&ks(e.etc,"sha512Sync",Ja),!e?.utils)try{e.utils={}}catch{Object.defineProperty(e,"utils",{value:{},writable:!0,configurable:!0})}typeof e.utils.sha512Sync!="function"&&ks(e.utils,"sha512Sync",Ja)}function r0(){e0(),t0()}r0();const n0={magby:{name:"magby",domain:"magby.originals.build",stability:"patch",description:"Development network - accepts all patch versions (most unstable)",contextUrl:"https://magby.originals.build/context",bitcoinNetwork:"regtest"},cleffa:{name:"cleffa",domain:"cleffa.originals.build",stability:"minor",description:"Staging network - accepts minor releases",contextUrl:"https://cleffa.originals.build/context",bitcoinNetwork:"signet"},pichu:{name:"pichu",domain:"pichu.originals.build",stability:"major",description:"Production network - accepts major releases only (most stable)",contextUrl:"https://pichu.originals.build/context",bitcoinNetwork:"mainnet"}},Ya="pichu";function jl(e){const t=n0[e];if(!t)throw new Error(`Invalid WebVH network: ${e}. Valid networks: magby, cleffa, pichu`);return t}function Za(e){return jl(e).domain}function i0(e){return jl(e).bitcoinNetwork}class o0{constructor(t={}){this.options=t}parseBtcoDid(t){const n=/^did:btco(?::(reg|sig))?:([0-9]+)(?:\/(.+))?$/,r=t.match(n);if(!r)return null;const[,a,o,i]=r;return{satNumber:o,path:i,network:a||"mainnet"}}getDidPrefix(t){switch(t){case"reg":case"regtest":return"did:btco:reg";case"sig":case"signet":return"did:btco:sig";default:return"did:btco"}}async resolve(t,n={}){const r=this.parseBtcoDid(t);if(!r)return this.createErrorResult("invalidDid",`Invalid BTCO DID format: ${t}`);const{satNumber:a,network:o}=r,i=n.provider||this.options.provider;if(!i)return this.createErrorResult("noProvider","No provider supplied");let s=[];try{s=(await i.getSatInfo(a))?.inscription_ids||[]}catch(f){const y=f instanceof Error?f.message:String(f);return this.createErrorResult("notFound",`Failed to retrieve inscriptions for satoshi ${a}: ${y}`)}if(s.length===0)return this.createErrorResult("notFound",`No inscriptions found on satoshi ${a}`);const c=`${this.getDidPrefix(o)}:${a}`,l=new RegExp(`^(?:BTCO DID: )?(${c.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")})`,"i"),u=[];for(const f of s){const y={inscriptionId:f,content:"",metadata:null};try{const g=await i.resolveInscription(f);if(!g){y.error=`Inscription ${f} not found`,u.push(y);continue}y.contentUrl=g.content_url,y.contentType=g.content_type;try{const S=n.fetchFn||this.options.fetchFn||fetch,B=n.timeout||this.options.timeout||1e4,I=new AbortController,b=setTimeout(()=>I.abort(),B);try{const w=await S(g.content_url);if(clearTimeout(b),!w.ok)throw new Error(`HTTP ${w.status}: ${w.statusText}`);y.content=await w.text()}finally{clearTimeout(b)}}catch(S){const B=S instanceof Error?S.message:String(S);y.error=`Failed to fetch content: ${B}`,u.push(y);continue}try{y.metadata=await i.getMetadata(f)}catch{y.metadata=null}if(y.isValidDid=l.test(y.content),y.isValidDid&&y.metadata){const S=y.metadata;this.isValidDidDocument(S)&&S.id===c?y.didDocument=S:y.error="Invalid DID document structure or mismatched ID"}y.content.includes("")&&(y.didDocument=null,y.error||(y.error="DID has been deactivated"))}catch(g){const S=g instanceof Error?g.message:String(g);y.error=`Failed to process inscription: ${S}`}u.push(y)}let d=null,h;for(let f=u.length-1;f>=0;f--){const y=u[f];if(y.didDocument&&!y.error){d=y.didDocument,h=y.inscriptionId;break}}return{didDocument:d,inscriptions:u,resolutionMetadata:{inscriptionId:h,satNumber:a,network:o,totalInscriptions:u.length},didDocumentMetadata:{inscriptionId:h,network:o}}}isValidDidDocument(t){if(!t||typeof t!="object")return!1;const n=t;if(!n.id||typeof n.id!="string"||!n["@context"])return!1;const r=Array.isArray(n["@context"])?n["@context"]:[n["@context"]];return!(!r.includes("https://www.w3.org/ns/did/v1")&&!r.includes("https://w3id.org/did/v1")||n.verificationMethod&&!Array.isArray(n.verificationMethod)||n.authentication&&!Array.isArray(n.authentication))}createErrorResult(t,n){return{didDocument:null,resolutionMetadata:{error:t,message:n},didDocumentMetadata:{}}}}var wi={exports:{}},s0=wi.exports,Qa;function a0(){return Qa||(Qa=1,(function(e){(function(t,n){var r=Math.pow(2,-24),a=Math.pow(2,32),o=Math.pow(2,53);function i(l){var u=new ArrayBuffer(256),d=new DataView(u),h,f=0;function y(F){for(var O=u.byteLength,R=f+F;O<R;)O*=2;if(O!==u.byteLength){var P=d;u=new ArrayBuffer(O),d=new DataView(u);for(var K=f+3>>2,U=0;U<K;++U)d.setUint32(U*4,P.getUint32(U*4))}return h=F,d}function g(){f+=h}function S(F){g(y(8).setFloat64(f,F))}function B(F){g(y(1).setUint8(f,F))}function I(F){for(var O=y(F.length),R=0;R<F.length;++R)O.setUint8(f+R,F[R]);g()}function b(F){g(y(2).setUint16(f,F))}function w(F){g(y(4).setUint32(f,F))}function x(F){var O=F%a,R=(F-O)/a,P=y(8);P.setUint32(f,R),P.setUint32(f+4,O),g()}function _(F,O){O<24?B(F<<5|O):O<256?(B(F<<5|24),B(O)):O<65536?(B(F<<5|25),b(O)):O<4294967296?(B(F<<5|26),w(O)):(B(F<<5|27),x(O))}function N(F){var O;if(F===!1)return B(244);if(F===!0)return B(245);if(F===null)return B(246);if(F===n)return B(247);switch(typeof F){case"number":if(Math.floor(F)===F){if(0<=F&&F<=o)return _(0,F);if(-o<=F&&F<0)return _(1,-(F+1))}return B(251),S(F);case"string":var R=[];for(O=0;O<F.length;++O){var P=F.charCodeAt(O);P<128?R.push(P):P<2048?(R.push(192|P>>6),R.push(128|P&63)):P<55296?(R.push(224|P>>12),R.push(128|P>>6&63),R.push(128|P&63)):(P=(P&1023)<<10,P|=F.charCodeAt(++O)&1023,P+=65536,R.push(240|P>>18),R.push(128|P>>12&63),R.push(128|P>>6&63),R.push(128|P&63))}return _(3,R.length),I(R);default:var K;if(Array.isArray(F))for(K=F.length,_(4,K),O=0;O<K;++O)N(F[O]);else if(F instanceof Uint8Array)_(2,F.length),I(F);else{var U=Object.keys(F);for(K=U.length,_(5,K),O=0;O<K;++O){var V=U[O];N(V),N(F[V])}}}}if(N(l),"slice"in u)return u.slice(0,f);for(var k=new ArrayBuffer(f),T=new DataView(k),L=0;L<f;++L)T.setUint8(L,d.getUint8(L));return k}function s(l,u,d){var h=new DataView(l),f=0;typeof u!="function"&&(u=function(R){return R}),typeof d!="function"&&(d=function(){return n});function y(R,P){return f+=P,R}function g(R){return y(new Uint8Array(l,f,R),R)}function S(){var R=new ArrayBuffer(4),P=new DataView(R),K=w(),U=K&32768,V=K&31744,C=K&1023;if(V===31744)V=261120;else if(V!==0)V+=114688;else if(C!==0)return C*r;return P.setUint32(0,U<<16|V<<13|C<<13),P.getFloat32(0)}function B(){return y(h.getFloat32(f),4)}function I(){return y(h.getFloat64(f),8)}function b(){return y(h.getUint8(f),1)}function w(){return y(h.getUint16(f),2)}function x(){return y(h.getUint32(f),4)}function _(){return x()*a+x()}function N(){return h.getUint8(f)!==255?!1:(f+=1,!0)}function k(R){if(R<24)return R;if(R===24)return b();if(R===25)return w();if(R===26)return x();if(R===27)return _();if(R===31)return-1;throw"Invalid length encoding"}function T(R){var P=b();if(P===255)return-1;var K=k(P&31);if(K<0||P>>5!==R)throw"Invalid indefinite length element";return K}function L(R,P){for(var K=0;K<P;++K){var U=b();U&128&&(U<224?(U=(U&31)<<6|b()&63,P-=1):U<240?(U=(U&15)<<12|(b()&63)<<6|b()&63,P-=2):(U=(U&15)<<18|(b()&63)<<12|(b()&63)<<6|b()&63,P-=3)),U<65536?R.push(U):(U-=65536,R.push(55296|U>>10),R.push(56320|U&1023))}}function F(){var R=b(),P=R>>5,K=R&31,U,V;if(P===7)switch(K){case 25:return S();case 26:return B();case 27:return I()}if(V=k(K),V<0&&(P<2||6<P))throw"Invalid length";switch(P){case 0:return V;case 1:return-1-V;case 2:if(V<0){for(var C=[],H=0;(V=T(P))>=0;)H+=V,C.push(g(V));var D=new Uint8Array(H),W=0;for(U=0;U<C.length;++U)D.set(C[U],W),W+=C[U].length;return D}return g(V);case 3:var J=[];if(V<0)for(;(V=T(P))>=0;)L(J,V);else L(J,V);return String.fromCharCode.apply(null,J);case 4:var re;if(V<0)for(re=[];!N();)re.push(F());else for(re=new Array(V),U=0;U<V;++U)re[U]=F();return re;case 5:var se={};for(U=0;U<V||V<0&&!N();++U){var z=F();se[z]=F()}return se;case 6:return u(F(),V);case 7:switch(V){case 20:return!1;case 21:return!0;case 22:return null;case 23:return n;default:return d(V)}}}var O=F();if(f!==l.byteLength)throw"Remaining bytes";return O}var c={encode:i,decode:s};e.exports?e.exports=c:t.CBOR||(t.CBOR=c)})(s0)})(wi)),wi.exports}var ql=a0();const c0=Kd(ql),u0=Gd({__proto__:null,default:c0},[ql]);function f0(e){const t=u0;let n;if(e instanceof ArrayBuffer)n=e;else if(e instanceof Uint8Array)n=e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength);else{const r=e;n=r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}return t.decode(n)}var ti={exports:{}},eo={},ec;function Ci(){return ec||(ec=1,(function(e){Object.defineProperties(e,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});var t={},n={};n.byteLength=u,n.toByteArray=h,n.fromByteArray=g;for(var r=[],a=[],o=typeof Uint8Array<"u"?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,c=i.length;s<c;++s)r[s]=i[s],a[i.charCodeAt(s)]=s;a[45]=62,a[95]=63;function l(I){var b=I.length;if(b%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var w=I.indexOf("=");w===-1&&(w=b);var x=w===b?0:4-w%4;return[w,x]}function u(I){var b=l(I),w=b[0],x=b[1];return(w+x)*3/4-x}function d(I,b,w){return(b+w)*3/4-w}function h(I){var b,w=l(I),x=w[0],_=w[1],N=new o(d(I,x,_)),k=0,T=_>0?x-4:x,L;for(L=0;L<T;L+=4)b=a[I.charCodeAt(L)]<<18|a[I.charCodeAt(L+1)]<<12|a[I.charCodeAt(L+2)]<<6|a[I.charCodeAt(L+3)],N[k++]=b>>16&255,N[k++]=b>>8&255,N[k++]=b&255;return _===2&&(b=a[I.charCodeAt(L)]<<2|a[I.charCodeAt(L+1)]>>4,N[k++]=b&255),_===1&&(b=a[I.charCodeAt(L)]<<10|a[I.charCodeAt(L+1)]<<4|a[I.charCodeAt(L+2)]>>2,N[k++]=b>>8&255,N[k++]=b&255),N}function f(I){return r[I>>18&63]+r[I>>12&63]+r[I>>6&63]+r[I&63]}function y(I,b,w){for(var x,_=[],N=b;N<w;N+=3)x=(I[N]<<16&16711680)+(I[N+1]<<8&65280)+(I[N+2]&255),_.push(f(x));return _.join("")}function g(I){for(var b,w=I.length,x=w%3,_=[],N=16383,k=0,T=w-x;k<T;k+=N)_.push(y(I,k,k+N>T?T:k+N));return x===1?(b=I[w-1],_.push(r[b>>2]+r[b<<4&63]+"==")):x===2&&(b=(I[w-2]<<8)+I[w-1],_.push(r[b>>10]+r[b>>4&63]+r[b<<2&63]+"=")),_.join("")}var S={};S.read=function(I,b,w,x,_){var N,k,T=_*8-x-1,L=(1<<T)-1,F=L>>1,O=-7,R=w?_-1:0,P=w?-1:1,K=I[b+R];for(R+=P,N=K&(1<<-O)-1,K>>=-O,O+=T;O>0;N=N*256+I[b+R],R+=P,O-=8);for(k=N&(1<<-O)-1,N>>=-O,O+=x;O>0;k=k*256+I[b+R],R+=P,O-=8);if(N===0)N=1-F;else{if(N===L)return k?NaN:(K?-1:1)*(1/0);k=k+Math.pow(2,x),N=N-F}return(K?-1:1)*k*Math.pow(2,N-x)},S.write=function(I,b,w,x,_,N){var k,T,L,F=N*8-_-1,O=(1<<F)-1,R=O>>1,P=_===23?Math.pow(2,-24)-Math.pow(2,-77):0,K=x?0:N-1,U=x?1:-1,V=b<0||b===0&&1/b<0?1:0;for(b=Math.abs(b),isNaN(b)||b===1/0?(T=isNaN(b)?1:0,k=O):(k=Math.floor(Math.log(b)/Math.LN2),b*(L=Math.pow(2,-k))<1&&(k--,L*=2),k+R>=1?b+=P/L:b+=P*Math.pow(2,1-R),b*L>=2&&(k++,L/=2),k+R>=O?(T=0,k=O):k+R>=1?(T=(b*L-1)*Math.pow(2,_),k=k+R):(T=b*Math.pow(2,R-1)*Math.pow(2,_),k=0));_>=8;I[w+K]=T&255,K+=U,T/=256,_-=8);for(k=k<<_|T,F+=_;F>0;I[w+K]=k&255,K+=U,k/=256,F-=8);I[w+K-U]|=V*128};(function(I){const b=n,w=S,x=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;I.Buffer=O,I.SlowBuffer=re,I.INSPECT_MAX_BYTES=50;const _=2147483647;I.kMaxLength=_;const{Uint8Array:N,ArrayBuffer:k,SharedArrayBuffer:T}=globalThis;O.TYPED_ARRAY_SUPPORT=L(),!O.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function L(){try{const q=new N(1),E={foo:function(){return 42}};return Object.setPrototypeOf(E,N.prototype),Object.setPrototypeOf(q,E),q.foo()===42}catch{return!1}}Object.defineProperty(O.prototype,"parent",{enumerable:!0,get:function(){if(O.isBuffer(this))return this.buffer}}),Object.defineProperty(O.prototype,"offset",{enumerable:!0,get:function(){if(O.isBuffer(this))return this.byteOffset}});function F(q){if(q>_)throw new RangeError('The value "'+q+'" is invalid for option "size"');const E=new N(q);return Object.setPrototypeOf(E,O.prototype),E}function O(q,E,A){if(typeof q=="number"){if(typeof E=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return U(q)}return R(q,E,A)}O.poolSize=8192;function R(q,E,A){if(typeof q=="string")return V(q,E);if(k.isView(q))return H(q);if(q==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof q);if(Me(q,k)||q&&Me(q.buffer,k)||typeof T<"u"&&(Me(q,T)||q&&Me(q.buffer,T)))return D(q,E,A);if(typeof q=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const $=q.valueOf&&q.valueOf();if($!=null&&$!==q)return O.from($,E,A);const Q=W(q);if(Q)return Q;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof q[Symbol.toPrimitive]=="function")return O.from(q[Symbol.toPrimitive]("string"),E,A);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof q)}O.from=function(q,E,A){return R(q,E,A)},Object.setPrototypeOf(O.prototype,N.prototype),Object.setPrototypeOf(O,N);function P(q){if(typeof q!="number")throw new TypeError('"size" argument must be of type number');if(q<0)throw new RangeError('The value "'+q+'" is invalid for option "size"')}function K(q,E,A){return P(q),q<=0?F(q):E!==void 0?typeof A=="string"?F(q).fill(E,A):F(q).fill(E):F(q)}O.alloc=function(q,E,A){return K(q,E,A)};function U(q){return P(q),F(q<0?0:J(q)|0)}O.allocUnsafe=function(q){return U(q)},O.allocUnsafeSlow=function(q){return U(q)};function V(q,E){if((typeof E!="string"||E==="")&&(E="utf8"),!O.isEncoding(E))throw new TypeError("Unknown encoding: "+E);const A=se(q,E)|0;let $=F(A);const Q=$.write(q,E);return Q!==A&&($=$.slice(0,Q)),$}function C(q){const E=q.length<0?0:J(q.length)|0,A=F(E);for(let $=0;$<E;$+=1)A[$]=q[$]&255;return A}function H(q){if(Me(q,N)){const E=new N(q);return D(E.buffer,E.byteOffset,E.byteLength)}return C(q)}function D(q,E,A){if(E<0||q.byteLength<E)throw new RangeError('"offset" is outside of buffer bounds');if(q.byteLength<E+(A||0))throw new RangeError('"length" is outside of buffer bounds');let $;return E===void 0&&A===void 0?$=new N(q):A===void 0?$=new N(q,E):$=new N(q,E,A),Object.setPrototypeOf($,O.prototype),$}function W(q){if(O.isBuffer(q)){const E=J(q.length)|0,A=F(E);return A.length===0||q.copy(A,0,0,E),A}if(q.length!==void 0)return typeof q.length!="number"||$i(q.length)?F(0):C(q);if(q.type==="Buffer"&&Array.isArray(q.data))return C(q.data)}function J(q){if(q>=_)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+_.toString(16)+" bytes");return q|0}function re(q){return+q!=q&&(q=0),O.alloc(+q)}O.isBuffer=function(E){return E!=null&&E._isBuffer===!0&&E!==O.prototype},O.compare=function(E,A){if(Me(E,N)&&(E=O.from(E,E.offset,E.byteLength)),Me(A,N)&&(A=O.from(A,A.offset,A.byteLength)),!O.isBuffer(E)||!O.isBuffer(A))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(E===A)return 0;let $=E.length,Q=A.length;for(let ie=0,ue=Math.min($,Q);ie<ue;++ie)if(E[ie]!==A[ie]){$=E[ie],Q=A[ie];break}return $<Q?-1:Q<$?1:0},O.isEncoding=function(E){switch(String(E).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},O.concat=function(E,A){if(!Array.isArray(E))throw new TypeError('"list" argument must be an Array of Buffers');if(E.length===0)return O.alloc(0);let $;if(A===void 0)for(A=0,$=0;$<E.length;++$)A+=E[$].length;const Q=O.allocUnsafe(A);let ie=0;for($=0;$<E.length;++$){let ue=E[$];if(Me(ue,N))ie+ue.length>Q.length?(O.isBuffer(ue)||(ue=O.from(ue)),ue.copy(Q,ie)):N.prototype.set.call(Q,ue,ie);else if(O.isBuffer(ue))ue.copy(Q,ie);else throw new TypeError('"list" argument must be an Array of Buffers');ie+=ue.length}return Q};function se(q,E){if(O.isBuffer(q))return q.length;if(k.isView(q)||Me(q,k))return q.byteLength;if(typeof q!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof q);const A=q.length,$=arguments.length>2&&arguments[2]===!0;if(!$&&A===0)return 0;let Q=!1;for(;;)switch(E){case"ascii":case"latin1":case"binary":return A;case"utf8":case"utf-8":return we(q).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A*2;case"hex":return A>>>1;case"base64":return Ee(q).length;default:if(Q)return $?-1:we(q).length;E=(""+E).toLowerCase(),Q=!0}}O.byteLength=se;function z(q,E,A){let $=!1;if((E===void 0||E<0)&&(E=0),E>this.length||((A===void 0||A>this.length)&&(A=this.length),A<=0)||(A>>>=0,E>>>=0,A<=E))return"";for(q||(q="utf8");;)switch(q){case"hex":return dt(this,E,A);case"utf8":case"utf-8":return Ie(this,E,A);case"ascii":return mt(this,E,A);case"latin1":case"binary":return bt(this,E,A);case"base64":return ye(this,E,A);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return $t(this,E,A);default:if($)throw new TypeError("Unknown encoding: "+q);q=(q+"").toLowerCase(),$=!0}}O.prototype._isBuffer=!0;function X(q,E,A){const $=q[E];q[E]=q[A],q[A]=$}O.prototype.swap16=function(){const E=this.length;if(E%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let A=0;A<E;A+=2)X(this,A,A+1);return this},O.prototype.swap32=function(){const E=this.length;if(E%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let A=0;A<E;A+=4)X(this,A,A+3),X(this,A+1,A+2);return this},O.prototype.swap64=function(){const E=this.length;if(E%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let A=0;A<E;A+=8)X(this,A,A+7),X(this,A+1,A+6),X(this,A+2,A+5),X(this,A+3,A+4);return this},O.prototype.toString=function(){const E=this.length;return E===0?"":arguments.length===0?Ie(this,0,E):z.apply(this,arguments)},O.prototype.toLocaleString=O.prototype.toString,O.prototype.equals=function(E){if(!O.isBuffer(E))throw new TypeError("Argument must be a Buffer");return this===E?!0:O.compare(this,E)===0},O.prototype.inspect=function(){let E="";const A=I.INSPECT_MAX_BYTES;return E=this.toString("hex",0,A).replace(/(.{2})/g,"$1 ").trim(),this.length>A&&(E+=" ... "),"<Buffer "+E+">"},x&&(O.prototype[x]=O.prototype.inspect),O.prototype.compare=function(E,A,$,Q,ie){if(Me(E,N)&&(E=O.from(E,E.offset,E.byteLength)),!O.isBuffer(E))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof E);if(A===void 0&&(A=0),$===void 0&&($=E?E.length:0),Q===void 0&&(Q=0),ie===void 0&&(ie=this.length),A<0||$>E.length||Q<0||ie>this.length)throw new RangeError("out of range index");if(Q>=ie&&A>=$)return 0;if(Q>=ie)return-1;if(A>=$)return 1;if(A>>>=0,$>>>=0,Q>>>=0,ie>>>=0,this===E)return 0;let ue=ie-Q,Se=$-A;const Ue=Math.min(ue,Se),Pe=this.slice(Q,ie),He=E.slice(A,$);for(let Be=0;Be<Ue;++Be)if(Pe[Be]!==He[Be]){ue=Pe[Be],Se=He[Be];break}return ue<Se?-1:Se<ue?1:0};function Y(q,E,A,$,Q){if(q.length===0)return-1;if(typeof A=="string"?($=A,A=0):A>2147483647?A=2147483647:A<-2147483648&&(A=-2147483648),A=+A,$i(A)&&(A=Q?0:q.length-1),A<0&&(A=q.length+A),A>=q.length){if(Q)return-1;A=q.length-1}else if(A<0)if(Q)A=0;else return-1;if(typeof E=="string"&&(E=O.from(E,$)),O.isBuffer(E))return E.length===0?-1:ae(q,E,A,$,Q);if(typeof E=="number")return E=E&255,typeof N.prototype.indexOf=="function"?Q?N.prototype.indexOf.call(q,E,A):N.prototype.lastIndexOf.call(q,E,A):ae(q,[E],A,$,Q);throw new TypeError("val must be string, number or Buffer")}function ae(q,E,A,$,Q){let ie=1,ue=q.length,Se=E.length;if($!==void 0&&($=String($).toLowerCase(),$==="ucs2"||$==="ucs-2"||$==="utf16le"||$==="utf-16le")){if(q.length<2||E.length<2)return-1;ie=2,ue/=2,Se/=2,A/=2}function Ue(He,Be){return ie===1?He[Be]:He.readUInt16BE(Be*ie)}let Pe;if(Q){let He=-1;for(Pe=A;Pe<ue;Pe++)if(Ue(q,Pe)===Ue(E,He===-1?0:Pe-He)){if(He===-1&&(He=Pe),Pe-He+1===Se)return He*ie}else He!==-1&&(Pe-=Pe-He),He=-1}else for(A+Se>ue&&(A=ue-Se),Pe=A;Pe>=0;Pe--){let He=!0;for(let Be=0;Be<Se;Be++)if(Ue(q,Pe+Be)!==Ue(E,Be)){He=!1;break}if(He)return Pe}return-1}O.prototype.includes=function(E,A,$){return this.indexOf(E,A,$)!==-1},O.prototype.indexOf=function(E,A,$){return Y(this,E,A,$,!0)},O.prototype.lastIndexOf=function(E,A,$){return Y(this,E,A,$,!1)};function ce(q,E,A,$){A=Number(A)||0;const Q=q.length-A;$?($=Number($),$>Q&&($=Q)):$=Q;const ie=E.length;$>ie/2&&($=ie/2);let ue;for(ue=0;ue<$;++ue){const Se=parseInt(E.substr(ue*2,2),16);if($i(Se))return ue;q[A+ue]=Se}return ue}function oe(q,E,A,$){return Ae(we(E,q.length-A),q,A,$)}function de(q,E,A,$){return Ae(me(E),q,A,$)}function pe(q,E,A,$){return Ae(Ee(E),q,A,$)}function fe(q,E,A,$){return Ae(ve(E,q.length-A),q,A,$)}O.prototype.write=function(E,A,$,Q){if(A===void 0)Q="utf8",$=this.length,A=0;else if($===void 0&&typeof A=="string")Q=A,$=this.length,A=0;else if(isFinite(A))A=A>>>0,isFinite($)?($=$>>>0,Q===void 0&&(Q="utf8")):(Q=$,$=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const ie=this.length-A;if(($===void 0||$>ie)&&($=ie),E.length>0&&($<0||A<0)||A>this.length)throw new RangeError("Attempt to write outside buffer bounds");Q||(Q="utf8");let ue=!1;for(;;)switch(Q){case"hex":return ce(this,E,A,$);case"utf8":case"utf-8":return oe(this,E,A,$);case"ascii":case"latin1":case"binary":return de(this,E,A,$);case"base64":return pe(this,E,A,$);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return fe(this,E,A,$);default:if(ue)throw new TypeError("Unknown encoding: "+Q);Q=(""+Q).toLowerCase(),ue=!0}},O.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function ye(q,E,A){return E===0&&A===q.length?b.fromByteArray(q):b.fromByteArray(q.slice(E,A))}function Ie(q,E,A){A=Math.min(q.length,A);const $=[];let Q=E;for(;Q<A;){const ie=q[Q];let ue=null,Se=ie>239?4:ie>223?3:ie>191?2:1;if(Q+Se<=A){let Ue,Pe,He,Be;switch(Se){case 1:ie<128&&(ue=ie);break;case 2:Ue=q[Q+1],(Ue&192)===128&&(Be=(ie&31)<<6|Ue&63,Be>127&&(ue=Be));break;case 3:Ue=q[Q+1],Pe=q[Q+2],(Ue&192)===128&&(Pe&192)===128&&(Be=(ie&15)<<12|(Ue&63)<<6|Pe&63,Be>2047&&(Be<55296||Be>57343)&&(ue=Be));break;case 4:Ue=q[Q+1],Pe=q[Q+2],He=q[Q+3],(Ue&192)===128&&(Pe&192)===128&&(He&192)===128&&(Be=(ie&15)<<18|(Ue&63)<<12|(Pe&63)<<6|He&63,Be>65535&&Be<1114112&&(ue=Be))}}ue===null?(ue=65533,Se=1):ue>65535&&(ue-=65536,$.push(ue>>>10&1023|55296),ue=56320|ue&1023),$.push(ue),Q+=Se}return _e($)}const xe=4096;function _e(q){const E=q.length;if(E<=xe)return String.fromCharCode.apply(String,q);let A="",$=0;for(;$<E;)A+=String.fromCharCode.apply(String,q.slice($,$+=xe));return A}function mt(q,E,A){let $="";A=Math.min(q.length,A);for(let Q=E;Q<A;++Q)$+=String.fromCharCode(q[Q]&127);return $}function bt(q,E,A){let $="";A=Math.min(q.length,A);for(let Q=E;Q<A;++Q)$+=String.fromCharCode(q[Q]);return $}function dt(q,E,A){const $=q.length;(!E||E<0)&&(E=0),(!A||A<0||A>$)&&(A=$);let Q="";for(let ie=E;ie<A;++ie)Q+=jd[q[ie]];return Q}function $t(q,E,A){const $=q.slice(E,A);let Q="";for(let ie=0;ie<$.length-1;ie+=2)Q+=String.fromCharCode($[ie]+$[ie+1]*256);return Q}O.prototype.slice=function(E,A){const $=this.length;E=~~E,A=A===void 0?$:~~A,E<0?(E+=$,E<0&&(E=0)):E>$&&(E=$),A<0?(A+=$,A<0&&(A=0)):A>$&&(A=$),A<E&&(A=E);const Q=this.subarray(E,A);return Object.setPrototypeOf(Q,O.prototype),Q};function Te(q,E,A){if(q%1!==0||q<0)throw new RangeError("offset is not uint");if(q+E>A)throw new RangeError("Trying to access beyond buffer length")}O.prototype.readUintLE=O.prototype.readUIntLE=function(E,A,$){E=E>>>0,A=A>>>0,$||Te(E,A,this.length);let Q=this[E],ie=1,ue=0;for(;++ue<A&&(ie*=256);)Q+=this[E+ue]*ie;return Q},O.prototype.readUintBE=O.prototype.readUIntBE=function(E,A,$){E=E>>>0,A=A>>>0,$||Te(E,A,this.length);let Q=this[E+--A],ie=1;for(;A>0&&(ie*=256);)Q+=this[E+--A]*ie;return Q},O.prototype.readUint8=O.prototype.readUInt8=function(E,A){return E=E>>>0,A||Te(E,1,this.length),this[E]},O.prototype.readUint16LE=O.prototype.readUInt16LE=function(E,A){return E=E>>>0,A||Te(E,2,this.length),this[E]|this[E+1]<<8},O.prototype.readUint16BE=O.prototype.readUInt16BE=function(E,A){return E=E>>>0,A||Te(E,2,this.length),this[E]<<8|this[E+1]},O.prototype.readUint32LE=O.prototype.readUInt32LE=function(E,A){return E=E>>>0,A||Te(E,4,this.length),(this[E]|this[E+1]<<8|this[E+2]<<16)+this[E+3]*16777216},O.prototype.readUint32BE=O.prototype.readUInt32BE=function(E,A){return E=E>>>0,A||Te(E,4,this.length),this[E]*16777216+(this[E+1]<<16|this[E+2]<<8|this[E+3])},O.prototype.readBigUInt64LE=Xt(function(E){E=E>>>0,G(E,"offset");const A=this[E],$=this[E+7];(A===void 0||$===void 0)&&Z(E,this.length-8);const Q=A+this[++E]*2**8+this[++E]*2**16+this[++E]*2**24,ie=this[++E]+this[++E]*2**8+this[++E]*2**16+$*2**24;return BigInt(Q)+(BigInt(ie)<<BigInt(32))}),O.prototype.readBigUInt64BE=Xt(function(E){E=E>>>0,G(E,"offset");const A=this[E],$=this[E+7];(A===void 0||$===void 0)&&Z(E,this.length-8);const Q=A*2**24+this[++E]*2**16+this[++E]*2**8+this[++E],ie=this[++E]*2**24+this[++E]*2**16+this[++E]*2**8+$;return(BigInt(Q)<<BigInt(32))+BigInt(ie)}),O.prototype.readIntLE=function(E,A,$){E=E>>>0,A=A>>>0,$||Te(E,A,this.length);let Q=this[E],ie=1,ue=0;for(;++ue<A&&(ie*=256);)Q+=this[E+ue]*ie;return ie*=128,Q>=ie&&(Q-=Math.pow(2,8*A)),Q},O.prototype.readIntBE=function(E,A,$){E=E>>>0,A=A>>>0,$||Te(E,A,this.length);let Q=A,ie=1,ue=this[E+--Q];for(;Q>0&&(ie*=256);)ue+=this[E+--Q]*ie;return ie*=128,ue>=ie&&(ue-=Math.pow(2,8*A)),ue},O.prototype.readInt8=function(E,A){return E=E>>>0,A||Te(E,1,this.length),this[E]&128?(255-this[E]+1)*-1:this[E]},O.prototype.readInt16LE=function(E,A){E=E>>>0,A||Te(E,2,this.length);const $=this[E]|this[E+1]<<8;return $&32768?$|4294901760:$},O.prototype.readInt16BE=function(E,A){E=E>>>0,A||Te(E,2,this.length);const $=this[E+1]|this[E]<<8;return $&32768?$|4294901760:$},O.prototype.readInt32LE=function(E,A){return E=E>>>0,A||Te(E,4,this.length),this[E]|this[E+1]<<8|this[E+2]<<16|this[E+3]<<24},O.prototype.readInt32BE=function(E,A){return E=E>>>0,A||Te(E,4,this.length),this[E]<<24|this[E+1]<<16|this[E+2]<<8|this[E+3]},O.prototype.readBigInt64LE=Xt(function(E){E=E>>>0,G(E,"offset");const A=this[E],$=this[E+7];(A===void 0||$===void 0)&&Z(E,this.length-8);const Q=this[E+4]+this[E+5]*2**8+this[E+6]*2**16+($<<24);return(BigInt(Q)<<BigInt(32))+BigInt(A+this[++E]*2**8+this[++E]*2**16+this[++E]*2**24)}),O.prototype.readBigInt64BE=Xt(function(E){E=E>>>0,G(E,"offset");const A=this[E],$=this[E+7];(A===void 0||$===void 0)&&Z(E,this.length-8);const Q=(A<<24)+this[++E]*2**16+this[++E]*2**8+this[++E];return(BigInt(Q)<<BigInt(32))+BigInt(this[++E]*2**24+this[++E]*2**16+this[++E]*2**8+$)}),O.prototype.readFloatLE=function(E,A){return E=E>>>0,A||Te(E,4,this.length),w.read(this,E,!0,23,4)},O.prototype.readFloatBE=function(E,A){return E=E>>>0,A||Te(E,4,this.length),w.read(this,E,!1,23,4)},O.prototype.readDoubleLE=function(E,A){return E=E>>>0,A||Te(E,8,this.length),w.read(this,E,!0,52,8)},O.prototype.readDoubleBE=function(E,A){return E=E>>>0,A||Te(E,8,this.length),w.read(this,E,!1,52,8)};function Ne(q,E,A,$,Q,ie){if(!O.isBuffer(q))throw new TypeError('"buffer" argument must be a Buffer instance');if(E>Q||E<ie)throw new RangeError('"value" argument is out of bounds');if(A+$>q.length)throw new RangeError("Index out of range")}O.prototype.writeUintLE=O.prototype.writeUIntLE=function(E,A,$,Q){if(E=+E,A=A>>>0,$=$>>>0,!Q){const Se=Math.pow(2,8*$)-1;Ne(this,E,A,$,Se,0)}let ie=1,ue=0;for(this[A]=E&255;++ue<$&&(ie*=256);)this[A+ue]=E/ie&255;return A+$},O.prototype.writeUintBE=O.prototype.writeUIntBE=function(E,A,$,Q){if(E=+E,A=A>>>0,$=$>>>0,!Q){const Se=Math.pow(2,8*$)-1;Ne(this,E,A,$,Se,0)}let ie=$-1,ue=1;for(this[A+ie]=E&255;--ie>=0&&(ue*=256);)this[A+ie]=E/ue&255;return A+$},O.prototype.writeUint8=O.prototype.writeUInt8=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,1,255,0),this[A]=E&255,A+1},O.prototype.writeUint16LE=O.prototype.writeUInt16LE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,2,65535,0),this[A]=E&255,this[A+1]=E>>>8,A+2},O.prototype.writeUint16BE=O.prototype.writeUInt16BE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,2,65535,0),this[A]=E>>>8,this[A+1]=E&255,A+2},O.prototype.writeUint32LE=O.prototype.writeUInt32LE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,4,4294967295,0),this[A+3]=E>>>24,this[A+2]=E>>>16,this[A+1]=E>>>8,this[A]=E&255,A+4},O.prototype.writeUint32BE=O.prototype.writeUInt32BE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,4,4294967295,0),this[A]=E>>>24,this[A+1]=E>>>16,this[A+2]=E>>>8,this[A+3]=E&255,A+4};function st(q,E,A,$,Q){M(E,$,Q,q,A,7);let ie=Number(E&BigInt(4294967295));q[A++]=ie,ie=ie>>8,q[A++]=ie,ie=ie>>8,q[A++]=ie,ie=ie>>8,q[A++]=ie;let ue=Number(E>>BigInt(32)&BigInt(4294967295));return q[A++]=ue,ue=ue>>8,q[A++]=ue,ue=ue>>8,q[A++]=ue,ue=ue>>8,q[A++]=ue,A}function Fe(q,E,A,$,Q){M(E,$,Q,q,A,7);let ie=Number(E&BigInt(4294967295));q[A+7]=ie,ie=ie>>8,q[A+6]=ie,ie=ie>>8,q[A+5]=ie,ie=ie>>8,q[A+4]=ie;let ue=Number(E>>BigInt(32)&BigInt(4294967295));return q[A+3]=ue,ue=ue>>8,q[A+2]=ue,ue=ue>>8,q[A+1]=ue,ue=ue>>8,q[A]=ue,A+8}O.prototype.writeBigUInt64LE=Xt(function(E,A=0){return st(this,E,A,BigInt(0),BigInt("0xffffffffffffffff"))}),O.prototype.writeBigUInt64BE=Xt(function(E,A=0){return Fe(this,E,A,BigInt(0),BigInt("0xffffffffffffffff"))}),O.prototype.writeIntLE=function(E,A,$,Q){if(E=+E,A=A>>>0,!Q){const Ue=Math.pow(2,8*$-1);Ne(this,E,A,$,Ue-1,-Ue)}let ie=0,ue=1,Se=0;for(this[A]=E&255;++ie<$&&(ue*=256);)E<0&&Se===0&&this[A+ie-1]!==0&&(Se=1),this[A+ie]=(E/ue>>0)-Se&255;return A+$},O.prototype.writeIntBE=function(E,A,$,Q){if(E=+E,A=A>>>0,!Q){const Ue=Math.pow(2,8*$-1);Ne(this,E,A,$,Ue-1,-Ue)}let ie=$-1,ue=1,Se=0;for(this[A+ie]=E&255;--ie>=0&&(ue*=256);)E<0&&Se===0&&this[A+ie+1]!==0&&(Se=1),this[A+ie]=(E/ue>>0)-Se&255;return A+$},O.prototype.writeInt8=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,1,127,-128),E<0&&(E=255+E+1),this[A]=E&255,A+1},O.prototype.writeInt16LE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,2,32767,-32768),this[A]=E&255,this[A+1]=E>>>8,A+2},O.prototype.writeInt16BE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,2,32767,-32768),this[A]=E>>>8,this[A+1]=E&255,A+2},O.prototype.writeInt32LE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,4,2147483647,-2147483648),this[A]=E&255,this[A+1]=E>>>8,this[A+2]=E>>>16,this[A+3]=E>>>24,A+4},O.prototype.writeInt32BE=function(E,A,$){return E=+E,A=A>>>0,$||Ne(this,E,A,4,2147483647,-2147483648),E<0&&(E=4294967295+E+1),this[A]=E>>>24,this[A+1]=E>>>16,this[A+2]=E>>>8,this[A+3]=E&255,A+4},O.prototype.writeBigInt64LE=Xt(function(E,A=0){return st(this,E,A,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),O.prototype.writeBigInt64BE=Xt(function(E,A=0){return Fe(this,E,A,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Ot(q,E,A,$,Q,ie){if(A+$>q.length)throw new RangeError("Index out of range");if(A<0)throw new RangeError("Index out of range")}function vt(q,E,A,$,Q){return E=+E,A=A>>>0,Q||Ot(q,E,A,4),w.write(q,E,A,$,23,4),A+4}O.prototype.writeFloatLE=function(E,A,$){return vt(this,E,A,!0,$)},O.prototype.writeFloatBE=function(E,A,$){return vt(this,E,A,!1,$)};function ne(q,E,A,$,Q){return E=+E,A=A>>>0,Q||Ot(q,E,A,8),w.write(q,E,A,$,52,8),A+8}O.prototype.writeDoubleLE=function(E,A,$){return ne(this,E,A,!0,$)},O.prototype.writeDoubleBE=function(E,A,$){return ne(this,E,A,!1,$)},O.prototype.copy=function(E,A,$,Q){if(!O.isBuffer(E))throw new TypeError("argument should be a Buffer");if($||($=0),!Q&&Q!==0&&(Q=this.length),A>=E.length&&(A=E.length),A||(A=0),Q>0&&Q<$&&(Q=$),Q===$||E.length===0||this.length===0)return 0;if(A<0)throw new RangeError("targetStart out of bounds");if($<0||$>=this.length)throw new RangeError("Index out of range");if(Q<0)throw new RangeError("sourceEnd out of bounds");Q>this.length&&(Q=this.length),E.length-A<Q-$&&(Q=E.length-A+$);const ie=Q-$;return this===E&&typeof N.prototype.copyWithin=="function"?this.copyWithin(A,$,Q):N.prototype.set.call(E,this.subarray($,Q),A),ie},O.prototype.fill=function(E,A,$,Q){if(typeof E=="string"){if(typeof A=="string"?(Q=A,A=0,$=this.length):typeof $=="string"&&(Q=$,$=this.length),Q!==void 0&&typeof Q!="string")throw new TypeError("encoding must be a string");if(typeof Q=="string"&&!O.isEncoding(Q))throw new TypeError("Unknown encoding: "+Q);if(E.length===1){const ue=E.charCodeAt(0);(Q==="utf8"&&ue<128||Q==="latin1")&&(E=ue)}}else typeof E=="number"?E=E&255:typeof E=="boolean"&&(E=Number(E));if(A<0||this.length<A||this.length<$)throw new RangeError("Out of range index");if($<=A)return this;A=A>>>0,$=$===void 0?this.length:$>>>0,E||(E=0);let ie;if(typeof E=="number")for(ie=A;ie<$;++ie)this[ie]=E;else{const ue=O.isBuffer(E)?E:O.from(E,Q),Se=ue.length;if(Se===0)throw new TypeError('The value "'+E+'" is invalid for argument "value"');for(ie=0;ie<$-A;++ie)this[ie+A]=ue[ie%Se]}return this};const j={};function v(q,E,A){j[q]=class extends A{constructor(){super(),Object.defineProperty(this,"message",{value:E.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${q}]`,this.stack,delete this.name}get code(){return q}set code(Q){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:Q,writable:!0})}toString(){return`${this.name} [${q}]: ${this.message}`}}}v("ERR_BUFFER_OUT_OF_BOUNDS",function(q){return q?`${q} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),v("ERR_INVALID_ARG_TYPE",function(q,E){return`The "${q}" argument must be of type number. Received type ${typeof E}`},TypeError),v("ERR_OUT_OF_RANGE",function(q,E,A){let $=`The value of "${q}" is out of range.`,Q=A;return Number.isInteger(A)&&Math.abs(A)>2**32?Q=p(String(A)):typeof A=="bigint"&&(Q=String(A),(A>BigInt(2)**BigInt(32)||A<-(BigInt(2)**BigInt(32)))&&(Q=p(Q)),Q+="n"),$+=` It must be ${E}. Received ${Q}`,$},RangeError);function p(q){let E="",A=q.length;const $=q[0]==="-"?1:0;for(;A>=$+4;A-=3)E=`_${q.slice(A-3,A)}${E}`;return`${q.slice(0,A)}${E}`}function m(q,E,A){G(E,"offset"),(q[E]===void 0||q[E+A]===void 0)&&Z(E,q.length-(A+1))}function M(q,E,A,$,Q,ie){if(q>A||q<E){const ue=typeof E=="bigint"?"n":"";let Se;throw E===0||E===BigInt(0)?Se=`>= 0${ue} and < 2${ue} ** ${(ie+1)*8}${ue}`:Se=`>= -(2${ue} ** ${(ie+1)*8-1}${ue}) and < 2 ** ${(ie+1)*8-1}${ue}`,new j.ERR_OUT_OF_RANGE("value",Se,q)}m($,Q,ie)}function G(q,E){if(typeof q!="number")throw new j.ERR_INVALID_ARG_TYPE(E,"number",q)}function Z(q,E,A){throw Math.floor(q)!==q?(G(q,A),new j.ERR_OUT_OF_RANGE("offset","an integer",q)):E<0?new j.ERR_BUFFER_OUT_OF_BOUNDS:new j.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${E}`,q)}const ee=/[^+/0-9A-Za-z-_]/g;function le(q){if(q=q.split("=")[0],q=q.trim().replace(ee,""),q.length<2)return"";for(;q.length%4!==0;)q=q+"=";return q}function we(q,E){E=E||1/0;let A;const $=q.length;let Q=null;const ie=[];for(let ue=0;ue<$;++ue){if(A=q.charCodeAt(ue),A>55295&&A<57344){if(!Q){if(A>56319){(E-=3)>-1&&ie.push(239,191,189);continue}else if(ue+1===$){(E-=3)>-1&&ie.push(239,191,189);continue}Q=A;continue}if(A<56320){(E-=3)>-1&&ie.push(239,191,189),Q=A;continue}A=(Q-55296<<10|A-56320)+65536}else Q&&(E-=3)>-1&&ie.push(239,191,189);if(Q=null,A<128){if((E-=1)<0)break;ie.push(A)}else if(A<2048){if((E-=2)<0)break;ie.push(A>>6|192,A&63|128)}else if(A<65536){if((E-=3)<0)break;ie.push(A>>12|224,A>>6&63|128,A&63|128)}else if(A<1114112){if((E-=4)<0)break;ie.push(A>>18|240,A>>12&63|128,A>>6&63|128,A&63|128)}else throw new Error("Invalid code point")}return ie}function me(q){const E=[];for(let A=0;A<q.length;++A)E.push(q.charCodeAt(A)&255);return E}function ve(q,E){let A,$,Q;const ie=[];for(let ue=0;ue<q.length&&!((E-=2)<0);++ue)A=q.charCodeAt(ue),$=A>>8,Q=A%256,ie.push(Q),ie.push($);return ie}function Ee(q){return b.toByteArray(le(q))}function Ae(q,E,A,$){let Q;for(Q=0;Q<$&&!(Q+A>=E.length||Q>=q.length);++Q)E[Q+A]=q[Q];return Q}function Me(q,E){return q instanceof E||q!=null&&q.constructor!=null&&q.constructor.name!=null&&q.constructor.name===E.name}function $i(q){return q!==q}const jd=(function(){const q="0123456789abcdef",E=new Array(256);for(let A=0;A<16;++A){const $=A*16;for(let Q=0;Q<16;++Q)E[$+Q]=q[A]+q[Q]}return E})();function Xt(q){return typeof BigInt>"u"?qd:q}function qd(){throw new Error("BigInt not supported")}})(t);const B=t.Buffer;e.Blob=t.Blob,e.BlobOptions=t.BlobOptions,e.Buffer=t.Buffer,e.File=t.File,e.FileOptions=t.FileOptions,e.INSPECT_MAX_BYTES=t.INSPECT_MAX_BYTES,e.SlowBuffer=t.SlowBuffer,e.TranscodeEncoding=t.TranscodeEncoding,e.atob=t.atob,e.btoa=t.btoa,e.constants=t.constants,e.default=B,e.isAscii=t.isAscii,e.isUtf8=t.isUtf8,e.kMaxLength=t.kMaxLength,e.kStringMaxLength=t.kStringMaxLength,e.resolveObjectURL=t.resolveObjectURL,e.transcode=t.transcode})(eo)),eo}var tc;function Kl(){return tc||(tc=1,(function(e,t){var n=Ci(),r=n.Buffer;function a(i,s){for(var c in i)s[c]=i[c]}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?e.exports=n:(a(n,t),t.Buffer=o);function o(i,s,c){return r(i,s,c)}o.prototype=Object.create(r.prototype),a(r,o),o.from=function(i,s,c){if(typeof i=="number")throw new TypeError("Argument must not be a number");return r(i,s,c)},o.alloc=function(i,s,c){if(typeof i!="number")throw new TypeError("Argument must be a number");var l=r(i);return s!==void 0?typeof c=="string"?l.fill(s,c):l.fill(s):l.fill(0),l},o.allocUnsafe=function(i){if(typeof i!="number")throw new TypeError("Argument must be a number");return r(i)},o.allocUnsafeSlow=function(i){if(typeof i!="number")throw new TypeError("Argument must be a number");return n.SlowBuffer(i)}})(ti,ti.exports)),ti.exports}var to,rc;function l0(){if(rc)return to;rc=1;var e=Kl().Buffer;function t(n){if(n.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),a=0;a<r.length;a++)r[a]=255;for(var o=0;o<n.length;o++){var i=n.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var c=n.length,l=n.charAt(0),u=Math.log(c)/Math.log(256),d=Math.log(256)/Math.log(c);function h(g){if((Array.isArray(g)||g instanceof Uint8Array)&&(g=e.from(g)),!e.isBuffer(g))throw new TypeError("Expected Buffer");if(g.length===0)return"";for(var S=0,B=0,I=0,b=g.length;I!==b&&g[I]===0;)I++,S++;for(var w=(b-I)*d+1>>>0,x=new Uint8Array(w);I!==b;){for(var _=g[I],N=0,k=w-1;(_!==0||N<B)&&k!==-1;k--,N++)_+=256*x[k]>>>0,x[k]=_%c>>>0,_=_/c>>>0;if(_!==0)throw new Error("Non-zero carry");B=N,I++}for(var T=w-B;T!==w&&x[T]===0;)T++;for(var L=l.repeat(S);T<w;++T)L+=n.charAt(x[T]);return L}function f(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return e.alloc(0);for(var S=0,B=0,I=0;g[S]===l;)B++,S++;for(var b=(g.length-S)*u+1>>>0,w=new Uint8Array(b);S<g.length;){var x=g.charCodeAt(S);if(x>255)return;var _=r[x];if(_===255)return;for(var N=0,k=b-1;(_!==0||N<I)&&k!==-1;k--,N++)_+=c*w[k]>>>0,w[k]=_%256>>>0,_=_/256>>>0;if(_!==0)throw new Error("Non-zero carry");I=N,S++}for(var T=b-I;T!==b&&w[T]===0;)T++;var L=e.allocUnsafe(B+(b-T));L.fill(0,0,B);for(var F=B;T!==b;)L[F++]=w[T++];return L}function y(g){var S=f(g);if(S)return S;throw new Error("Non-base"+c+" character")}return{encode:h,decodeUnsafe:f,decode:y}}return to=t,to}var ro,nc;function d0(){if(nc)return ro;nc=1;var e=l0(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return ro=e(t),ro}d0();function h0(e){const t=e.startsWith("0x")?e.slice(2):e;if(t.length%2!==0)throw new Error("Invalid hex string length");const n=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2){const a=t.substring(r,r+2),o=parseInt(a,16);if(Number.isNaN(o))throw new Error("Invalid hex string");n[r/2]=o}return n}class p0{constructor(t,n){this.rpcUrl=t,this.network=n}async getInscriptionById(t){return t?this.resolveInscription(t):null}async getInscriptionsBySatoshi(t){const n=await this.getSatInfo(t);return n.inscription_ids.length?(await Promise.all(n.inscription_ids.map(a=>this.resolveInscription(a)))).filter(a=>a!==null):[]}broadcastTransaction(t){return Promise.resolve(t.txid||"txid")}getTransactionStatus(t){return Promise.resolve({confirmed:!1})}estimateFee(t=1){return Promise.resolve(Math.max(1,t)*10)}async getSatInfo(t){const n=await this.fetchJson(`/sat/${t}`);return n?{inscription_ids:Array.isArray(n.inscription_ids)?n.inscription_ids:[]}:{inscription_ids:[]}}async resolveInscription(t){if(!t)return null;const n=await this.fetchJson(`/inscription/${t}`);if(!n)return null;const r=n.content_url||`${this.rpcUrl}/content/${t}`,a=await fetch(String(r));if(!a.ok)throw new Error(`Failed to fetch inscription content: ${a.status}`);const o=await a.arrayBuffer(),i=te.from(new Uint8Array(o));let s="unknown",c=0;if(typeof n.owner_output=="string"&&n.owner_output.includes(":")){const[d,h]=n.owner_output.split(":");s=d,c=Number(h)||0}return{satoshi:String(n.sat??""),inscriptionId:n.inscription_id||t,content:i,contentType:n.content_type||"application/octet-stream",txid:s,vout:c,blockHeight:n.block_height}}async getMetadata(t){if(!t)return null;const n=this.rpcUrl.replace(/\/$/,""),r=await fetch(`${n}/r/metadata/${t}`,{headers:{Accept:"application/json"}});if(!r.ok)return null;let a=(await r.text()).trim();if(a.startsWith('"')&&a.endsWith('"'))try{a=JSON.parse(a)}catch{}try{const o=h0(a);return f0(o)}catch{return null}}async fetchJson(t){const n=`${this.rpcUrl.replace(/\/$/,"")}${t}`,r=await fetch(n,{headers:{Accept:"application/json"}});if(!r.ok)return null;const a=await r.json();return a&&typeof a=="object"&&"data"in a?a.data:a}}function y0(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Vl(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function Os(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Gl(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function Rs(e){if(!Array.isArray(e))throw new Error("array expected")}function Wl(e,t){if(!Vl(!0,t))throw new Error(`${e}: array of strings expected`)}function g0(e,t){if(!Vl(!1,t))throw new Error(`${e}: array of numbers expected`)}function w0(...e){const t=o=>o,n=(o,i)=>s=>o(i(s)),r=e.map(o=>o.encode).reduceRight(n,t),a=e.map(o=>o.decode).reduce(n,t);return{encode:r,decode:a}}function m0(e){const t=typeof e=="string"?e.split(""):e,n=t.length;Wl("alphabet",t);const r=new Map(t.map((a,o)=>[a,o]));return{encode:a=>(Rs(a),a.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);return t[o]})),decode:a=>(Rs(a),a.map(o=>{Os("alphabet.decode",o);const i=r.get(o);if(i===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);return i}))}}function b0(e=""){return Os("join",e),{encode:t=>(Wl("join.decode",t),t.join(e)),decode:t=>(Os("join.decode",t),t.split(e))}}function ic(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(Rs(e),!e.length)return[];let r=0;const a=[],o=Array.from(e,s=>{if(Gl(s),s<0||s>=t)throw new Error(`invalid integer: ${s}`);return s}),i=o.length;for(;;){let s=0,c=!0;for(let l=r;l<i;l++){const u=o[l],d=t*s,h=d+u;if(!Number.isSafeInteger(h)||d/t!==s||h-u!==d)throw new Error("convertRadix: carry overflow");const f=h/n;s=h%n;const y=Math.floor(f);if(o[l]=y,!Number.isSafeInteger(y)||y*n+s!==h)throw new Error("convertRadix: carry overflow");if(c)y?c=!1:r=l;else continue}if(a.push(s),c)break}for(let s=0;s<e.length-1&&e[s]===0;s++)a.push(0);return a.reverse()}function v0(e){Gl(e);const t=2**8;return{encode:n=>{if(!y0(n))throw new Error("radix.encode input should be Uint8Array");return ic(Array.from(n),t,e)},decode:n=>(g0("radix.decode",n),Uint8Array.from(ic(n,e,t)))}}const E0=e=>w0(v0(58),m0(e),b0("")),Sn=E0("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),no=new Uint8Array([237,1]),io=new Uint8Array([128,38]),oo=new Uint8Array([231,1]),so=new Uint8Array([19,1]),ao=new Uint8Array([235,1]),co=new Uint8Array([130,38]),uo=new Uint8Array([128,36]),fo=new Uint8Array([129,38]);function oc(e,t){const n=new Uint8Array(e.length+t.length);return n.set(e,0),n.set(t,e.length),n}const Ze={encodePublicKey:(e,t)=>{const r=oc(t==="Ed25519"?no:t==="Secp256k1"?oo:t==="Bls12381G2"?ao:uo,e);return"z"+Sn.encode(r)},encodePrivateKey:(e,t)=>{const r=oc(t==="Ed25519"?io:t==="Secp256k1"?so:t==="Bls12381G2"?co:fo,e);return"z"+Sn.encode(r)},encodeMultibase:e=>"z"+Sn.encode(e instanceof te?new Uint8Array(e):e),decodePublicKey:e=>{if(!e||e[0]!=="z")throw new Error("Invalid Multibase encoding");const t=Sn.decode(e.slice(1)),n=t.slice(0,2),r=t.slice(2);if(n[0]===no[0]&&n[1]===no[1])return{key:r,type:"Ed25519"};if(n[0]===oo[0]&&n[1]===oo[1])return{key:r,type:"Secp256k1"};if(n[0]===ao[0]&&n[1]===ao[1])return{key:r,type:"Bls12381G2"};if(n[0]===uo[0]&&n[1]===uo[1])return{key:r,type:"P256"};throw new Error("Unsupported key type")},decodePrivateKey:e=>{if(!e||e[0]!=="z")throw new Error("Invalid Multibase encoding");const t=Sn.decode(e.slice(1)),n=t.slice(0,2),r=t.slice(2);if(n[0]===io[0]&&n[1]===io[1])return{key:r,type:"Ed25519"};if(n[0]===so[0]&&n[1]===so[1])return{key:r,type:"Secp256k1"};if(n[0]===co[0]&&n[1]===co[1])return{key:r,type:"Bls12381G2"};if(n[0]===fo[0]&&n[1]===fo[1])return{key:r,type:"P256"};throw new Error("Unsupported key type")}},Ti=21e14;function $l(e){if(e==null||e==="")return{valid:!1,error:"Satoshi identifier cannot be null, undefined, or empty string"};const t=String(e).trim();if(t==="")return{valid:!1,error:"Satoshi identifier cannot be empty or whitespace-only string"};if(!/^[0-9]+$/.test(t))return{valid:!1,error:"Satoshi identifier must be a non-negative integer (no decimals, no scientific notation, no non-numeric characters)"};const n=Number(t);return Number.isFinite(n)?n!==Math.floor(n)?{valid:!1,error:"Satoshi identifier cannot contain decimal places"}:n<0?{valid:!1,error:"Satoshi identifier must be non-negative (>= 0)"}:n>Ti?{valid:!1,error:`Satoshi identifier must be within Bitcoin's total supply (0 to ${Ti.toLocaleString()})`}:{valid:!0}:{valid:!1,error:"Satoshi identifier must be a finite number"}}function x0(e){if(e==="mainnet")return"did:btco";if(e==="signet")return"did:btco:sig";if(e==="regtest")return"did:btco:reg";const t=e;throw new Error(`Unsupported Bitcoin network: ${String(t)}`)}function S0(e,t){const r=`${e}#0`,a=t.controller??e;return{id:r,type:"Multikey",controller:a,publicKeyMultibase:Ze.encodePublicKey(t.publicKey,t.keyType)}}function sc(e,t,n){const r=$l(e);if(!r.valid)throw new Error(`Invalid satoshi number: ${r.error}`);const a=`${x0(t)}:${String(e)}`,o=S0(a,n);return{"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/multikey/v1"],id:a,verificationMethod:[o],authentication:[o.id],assertionMethod:[o.id]}}class I0{constructor(t,n){this.client=t,typeof n=="string"?this.config={baseUrl:n}:this.config=n}async getSatInfo(t){return this.client.getSatInfo(t)}async resolveInscription(t){const n=(this.config.baseUrl||"").replace(/\/$/,"");if(!n)throw new Error("OrdinalsClientProviderAdapter requires a baseUrl");try{const r=this.config.fetchFn||fetch,a=this.config.timeout||1e4,o={headers:{Accept:"application/json"},signal:AbortSignal.timeout(a)},i=await r(`${n}/inscription/${t}`,o);if(!i.ok)throw console.warn(`Failed to resolve inscription ${t}: HTTP ${i.status}`),new Error(`HTTP ${i.status}: ${i.statusText}`);const s=await i.json();return{id:s.inscription_id||t,sat:typeof s.sat=="number"?s.sat:Number(s.sat||0),content_type:s.content_type||"text/plain",content_url:s.content_url||`${n}/content/${t}`}}catch(r){throw console.warn(`Failed to resolve inscription ${t}:`,r.message||String(r)),new Error(`Failed to resolve inscription: ${t}`)}}async getMetadata(t){return this.client.getMetadata(t)}}const on=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function ji(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ps(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Jr(e,...t){if(!ji(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function Xl(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Ps(e.outputLen),Ps(e.blockLen)}function Bi(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function _0(e,t){Jr(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function En(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function lo(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function It(e,t){return e<<32-t|e>>>t}const zl=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",A0=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function gn(e){if(Jr(e),zl)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=A0[e[n]];return t}const Ht={_0:48,_9:57,A:65,F:70,a:97,f:102};function ac(e){if(e>=Ht._0&&e<=Ht._9)return e-Ht._0;if(e>=Ht.A&&e<=Ht.F)return e-(Ht.A-10);if(e>=Ht.a&&e<=Ht.f)return e-(Ht.a-10)}function ki(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(zl)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let a=0,o=0;a<n;a++,o+=2){const i=ac(e.charCodeAt(o)),s=ac(e.charCodeAt(o+1));if(i===void 0||s===void 0){const c=e[o]+e[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}r[a]=i*16+s}return r}function T0(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function ua(e){return typeof e=="string"&&(e=T0(e)),Jr(e),e}function mr(...e){let t=0;for(let r=0;r<e.length;r++){const a=e[r];Jr(a),t+=a.length}const n=new Uint8Array(t);for(let r=0,a=0;r<e.length;r++){const o=e[r];n.set(o,a),a+=o.length}return n}class Jl{}function fa(e){const t=r=>e().update(ua(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function Yl(e=32){if(on&&typeof on.getRandomValues=="function")return on.getRandomValues(new Uint8Array(e));if(on&&typeof on.randomBytes=="function")return Uint8Array.from(on.randomBytes(e));throw new Error("crypto.getRandomValues must be defined")}const la=BigInt(0),Us=BigInt(1);function Oi(e,t=""){if(typeof e!="boolean"){const n=t&&`"${t}"`;throw new Error(n+"expected boolean, got type="+typeof e)}return e}function Nr(e,t,n=""){const r=ji(e),a=e?.length,o=t!==void 0;if(!r||o&&a!==t){const i=n&&`"${n}" `,s=o?` of length ${t}`:"",c=r?`length=${a}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+s+", got "+c)}return e}function ri(e){const t=e.toString(16);return t.length&1?"0"+t:t}function Zl(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?la:BigInt("0x"+e)}function qi(e){return Zl(gn(e))}function Ql(e){return Jr(e),Zl(gn(Uint8Array.from(e).reverse()))}function da(e,t){return ki(e.toString(16).padStart(t*2,"0"))}function ed(e,t){return da(e,t).reverse()}function tt(e,t,n){let r;if(typeof t=="string")try{r=ki(t)}catch(a){throw new Error(e+" must be hex string or Uint8Array, cause: "+a)}else if(ji(t))r=Uint8Array.from(t);else throw new Error(e+" must be hex string or Uint8Array");return r.length,r}const ho=e=>typeof e=="bigint"&&la<=e;function B0(e,t,n){return ho(e)&&ho(t)&&ho(n)&&t<=e&&e<n}function k0(e,t,n,r){if(!B0(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function td(e){let t;for(t=0;e>la;e>>=Us,t+=1);return t}const Wn=e=>(Us<<BigInt(e))-Us;function O0(e,t,n){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");const r=f=>new Uint8Array(f),a=f=>Uint8Array.of(f);let o=r(e),i=r(e),s=0;const c=()=>{o.fill(1),i.fill(0),s=0},l=(...f)=>n(i,o,...f),u=(f=r(0))=>{i=l(a(0),f),o=l(),f.length!==0&&(i=l(a(1),f),o=l())},d=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const y=[];for(;f<t;){o=l();const g=o.slice();y.push(g),f+=o.length}return mr(...y)};return(f,y)=>{c(),u(f);let g;for(;!(g=y(d()));)u();return c(),g}}function ha(e,t,n={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(a,o,i){const s=e[a];if(i&&s===void 0)return;const c=typeof s;if(c!==o||s===null)throw new Error(`param "${a}" is invalid: expected ${o}, got ${c}`)}Object.entries(t).forEach(([a,o])=>r(a,o,!1)),Object.entries(n).forEach(([a,o])=>r(a,o,!0))}function cc(e){const t=new WeakMap;return(n,...r)=>{const a=t.get(n);if(a!==void 0)return a;const o=e(n,...r);return t.set(n,o),o}}const rt=BigInt(0),Qe=BigInt(1),Fr=BigInt(2),rd=BigInt(3),nd=BigInt(4),id=BigInt(5),R0=BigInt(7),od=BigInt(8),P0=BigInt(9),sd=BigInt(16);function pt(e,t){const n=e%t;return n>=rt?n:t+n}function uc(e,t){if(e===rt)throw new Error("invert: expected non-zero number");if(t<=rt)throw new Error("invert: expected positive modulus, got "+t);let n=pt(e,t),r=t,a=rt,o=Qe;for(;n!==rt;){const s=r/n,c=r%n,l=a-o*s;r=n,n=c,a=o,o=l}if(r!==Qe)throw new Error("invert: does not exist");return pt(a,t)}function pa(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function ad(e,t){const n=(e.ORDER+Qe)/nd,r=e.pow(t,n);return pa(e,r,t),r}function U0(e,t){const n=(e.ORDER-id)/od,r=e.mul(t,Fr),a=e.pow(r,n),o=e.mul(t,a),i=e.mul(e.mul(o,Fr),a),s=e.mul(o,e.sub(i,e.ONE));return pa(e,s,t),s}function H0(e){const t=Yr(e),n=cd(e),r=n(t,t.neg(t.ONE)),a=n(t,r),o=n(t,t.neg(r)),i=(e+R0)/sd;return(s,c)=>{let l=s.pow(c,i),u=s.mul(l,r);const d=s.mul(l,a),h=s.mul(l,o),f=s.eql(s.sqr(u),c),y=s.eql(s.sqr(d),c);l=s.cmov(l,u,f),u=s.cmov(h,d,y);const g=s.eql(s.sqr(u),c),S=s.cmov(l,u,g);return pa(s,S,c),S}}function cd(e){if(e<rd)throw new Error("sqrt is not defined for small field");let t=e-Qe,n=0;for(;t%Fr===rt;)t/=Fr,n++;let r=Fr;const a=Yr(e);for(;fc(a,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return ad;let o=a.pow(r,t);const i=(t+Qe)/Fr;return function(c,l){if(c.is0(l))return l;if(fc(c,l)!==1)throw new Error("Cannot find square root");let u=n,d=c.mul(c.ONE,o),h=c.pow(l,t),f=c.pow(l,i);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let y=1,g=c.sqr(h);for(;!c.eql(g,c.ONE);)if(y++,g=c.sqr(g),y===u)throw new Error("Cannot find square root");const S=Qe<<BigInt(u-y-1),B=c.pow(d,S);u=y,d=c.sqr(B),h=c.mul(h,d),f=c.mul(f,B)}return f}}function L0(e){return e%nd===rd?ad:e%od===id?U0:e%sd===P0?H0(e):cd(e)}const D0=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function N0(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},n=D0.reduce((r,a)=>(r[a]="function",r),t);return ha(e,n),e}function F0(e,t,n){if(n<rt)throw new Error("invalid exponent, negatives unsupported");if(n===rt)return e.ONE;if(n===Qe)return t;let r=e.ONE,a=t;for(;n>rt;)n&Qe&&(r=e.mul(r,a)),a=e.sqr(a),n>>=Qe;return r}function ud(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),a=t.reduce((i,s,c)=>e.is0(s)?i:(r[c]=i,e.mul(i,s)),e.ONE),o=e.inv(a);return t.reduceRight((i,s,c)=>e.is0(s)?i:(r[c]=e.mul(i,r[c]),e.mul(i,s)),o),r}function fc(e,t){const n=(e.ORDER-Qe)/Fr,r=e.pow(t,n),a=e.eql(r,e.ONE),o=e.eql(r,e.ZERO),i=e.eql(r,e.neg(e.ONE));if(!a&&!o&&!i)throw new Error("invalid Legendre symbol result");return a?1:o?0:-1}function fd(e,t){t!==void 0&&Ps(t);const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Yr(e,t,n=!1,r={}){if(e<=rt)throw new Error("invalid field: expected ORDER > 0, got "+e);let a,o,i=!1,s;if(typeof t=="object"&&t!=null){if(r.sqrt||n)throw new Error("cannot specify opts in two arguments");const h=t;h.BITS&&(a=h.BITS),h.sqrt&&(o=h.sqrt),typeof h.isLE=="boolean"&&(n=h.isLE),typeof h.modFromBytes=="boolean"&&(i=h.modFromBytes),s=h.allowedLengths}else typeof t=="number"&&(a=t),r.sqrt&&(o=r.sqrt);const{nBitLength:c,nByteLength:l}=fd(e,a);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let u;const d=Object.freeze({ORDER:e,isLE:n,BITS:c,BYTES:l,MASK:Wn(c),ZERO:rt,ONE:Qe,allowedLengths:s,create:h=>pt(h,e),isValid:h=>{if(typeof h!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof h);return rt<=h&&h<e},is0:h=>h===rt,isValidNot0:h=>!d.is0(h)&&d.isValid(h),isOdd:h=>(h&Qe)===Qe,neg:h=>pt(-h,e),eql:(h,f)=>h===f,sqr:h=>pt(h*h,e),add:(h,f)=>pt(h+f,e),sub:(h,f)=>pt(h-f,e),mul:(h,f)=>pt(h*f,e),pow:(h,f)=>F0(d,h,f),div:(h,f)=>pt(h*uc(f,e),e),sqrN:h=>h*h,addN:(h,f)=>h+f,subN:(h,f)=>h-f,mulN:(h,f)=>h*f,inv:h=>uc(h,e),sqrt:o||(h=>(u||(u=L0(e)),u(d,h))),toBytes:h=>n?ed(h,l):da(h,l),fromBytes:(h,f=!0)=>{if(s){if(!s.includes(h.length)||h.length>l)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+h.length);const g=new Uint8Array(l);g.set(h,n?0:g.length-h.length),h=g}if(h.length!==l)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+h.length);let y=n?Ql(h):qi(h);if(i&&(y=pt(y,e)),!f&&!d.isValid(y))throw new Error("invalid field element: outside of range 0..ORDER");return y},invertBatch:h=>ud(d,h),cmov:(h,f,y)=>y?f:h});return Object.freeze(d)}function ld(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function dd(e){const t=ld(e);return t+Math.ceil(t/2)}function M0(e,t,n=!1){const r=e.length,a=ld(t),o=dd(t);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const i=n?Ql(e):qi(e),s=pt(i,t-Qe)+Qe;return n?ed(s,a):da(s,a)}function C0(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const a=BigInt(32),o=BigInt(4294967295),i=Number(n>>a&o),s=Number(n&o),c=r?4:0,l=r?0:4;e.setUint32(t+c,i,r),e.setUint32(t+l,s,r)}function j0(e,t,n){return e&t^~e&n}function q0(e,t,n){return e&t^e&n^t&n}class hd extends Jl{constructor(t,n,r,a){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=a,this.buffer=new Uint8Array(t),this.view=lo(this.buffer)}update(t){Bi(this),t=ua(t),Jr(t);const{view:n,buffer:r,blockLen:a}=this,o=t.length;for(let i=0;i<o;){const s=Math.min(a-this.pos,o-i);if(s===a){const c=lo(t);for(;a<=o-i;i+=a)this.process(c,i);continue}r.set(t.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===a&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Bi(this),_0(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:a,isLE:o}=this;let{pos:i}=this;n[i++]=128,En(this.buffer.subarray(i)),this.padOffset>a-i&&(this.process(r,0),i=0);for(let d=i;d<a;d++)n[d]=0;C0(r,a-8,BigInt(this.length*8),o),this.process(r,0);const s=lo(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)s.setUint32(4*d,u[d],o)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:a,finished:o,destroyed:i,pos:s}=this;return t.destroyed=i,t.finished=o,t.length=a,t.pos=s,a%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const tr=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ve=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),Ge=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),ni=BigInt(2**32-1),lc=BigInt(32);function K0(e,t=!1){return t?{h:Number(e&ni),l:Number(e>>lc&ni)}:{h:Number(e>>lc&ni)|0,l:Number(e&ni)|0}}function V0(e,t=!1){const n=e.length;let r=new Uint32Array(n),a=new Uint32Array(n);for(let o=0;o<n;o++){const{h:i,l:s}=K0(e[o],t);[r[o],a[o]]=[i,s]}return[r,a]}const dc=(e,t,n)=>e>>>n,hc=(e,t,n)=>e<<32-n|t>>>n,sn=(e,t,n)=>e>>>n|t<<32-n,an=(e,t,n)=>e<<32-n|t>>>n,ii=(e,t,n)=>e<<64-n|t>>>n-32,oi=(e,t,n)=>e>>>n-32|t<<64-n;function Lt(e,t,n,r){const a=(t>>>0)+(r>>>0);return{h:e+n+(a/2**32|0)|0,l:a|0}}const G0=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),W0=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,$0=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),X0=(e,t,n,r,a)=>t+n+r+a+(e/2**32|0)|0,z0=(e,t,n,r,a)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(a>>>0),J0=(e,t,n,r,a,o)=>t+n+r+a+o+(e/2**32|0)|0,Y0=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),rr=new Uint32Array(64);class Z0 extends hd{constructor(t=32){super(64,t,8,!1),this.A=tr[0]|0,this.B=tr[1]|0,this.C=tr[2]|0,this.D=tr[3]|0,this.E=tr[4]|0,this.F=tr[5]|0,this.G=tr[6]|0,this.H=tr[7]|0}get(){const{A:t,B:n,C:r,D:a,E:o,F:i,G:s,H:c}=this;return[t,n,r,a,o,i,s,c]}set(t,n,r,a,o,i,s,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=a|0,this.E=o|0,this.F=i|0,this.G=s|0,this.H=c|0}process(t,n){for(let d=0;d<16;d++,n+=4)rr[d]=t.getUint32(n,!1);for(let d=16;d<64;d++){const h=rr[d-15],f=rr[d-2],y=It(h,7)^It(h,18)^h>>>3,g=It(f,17)^It(f,19)^f>>>10;rr[d]=g+rr[d-7]+y+rr[d-16]|0}let{A:r,B:a,C:o,D:i,E:s,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const h=It(s,6)^It(s,11)^It(s,25),f=u+h+j0(s,c,l)+Y0[d]+rr[d]|0,g=(It(r,2)^It(r,13)^It(r,22))+q0(r,a,o)|0;u=l,l=c,c=s,s=i+f|0,i=o,o=a,a=r,r=f+g|0}r=r+this.A|0,a=a+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(r,a,o,i,s,c,l,u)}roundClean(){En(rr)}destroy(){this.set(0,0,0,0,0,0,0,0),En(this.buffer)}}const pd=V0(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),Q0=pd[0],ey=pd[1],nr=new Uint32Array(80),ir=new Uint32Array(80);class yd extends hd{constructor(t=64){super(128,t,16,!1),this.Ah=Ge[0]|0,this.Al=Ge[1]|0,this.Bh=Ge[2]|0,this.Bl=Ge[3]|0,this.Ch=Ge[4]|0,this.Cl=Ge[5]|0,this.Dh=Ge[6]|0,this.Dl=Ge[7]|0,this.Eh=Ge[8]|0,this.El=Ge[9]|0,this.Fh=Ge[10]|0,this.Fl=Ge[11]|0,this.Gh=Ge[12]|0,this.Gl=Ge[13]|0,this.Hh=Ge[14]|0,this.Hl=Ge[15]|0}get(){const{Ah:t,Al:n,Bh:r,Bl:a,Ch:o,Cl:i,Dh:s,Dl:c,Eh:l,El:u,Fh:d,Fl:h,Gh:f,Gl:y,Hh:g,Hl:S}=this;return[t,n,r,a,o,i,s,c,l,u,d,h,f,y,g,S]}set(t,n,r,a,o,i,s,c,l,u,d,h,f,y,g,S){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=a|0,this.Ch=o|0,this.Cl=i|0,this.Dh=s|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=h|0,this.Gh=f|0,this.Gl=y|0,this.Hh=g|0,this.Hl=S|0}process(t,n){for(let b=0;b<16;b++,n+=4)nr[b]=t.getUint32(n),ir[b]=t.getUint32(n+=4);for(let b=16;b<80;b++){const w=nr[b-15]|0,x=ir[b-15]|0,_=sn(w,x,1)^sn(w,x,8)^dc(w,x,7),N=an(w,x,1)^an(w,x,8)^hc(w,x,7),k=nr[b-2]|0,T=ir[b-2]|0,L=sn(k,T,19)^ii(k,T,61)^dc(k,T,6),F=an(k,T,19)^oi(k,T,61)^hc(k,T,6),O=$0(N,F,ir[b-7],ir[b-16]),R=X0(O,_,L,nr[b-7],nr[b-16]);nr[b]=R|0,ir[b]=O|0}let{Ah:r,Al:a,Bh:o,Bl:i,Ch:s,Cl:c,Dh:l,Dl:u,Eh:d,El:h,Fh:f,Fl:y,Gh:g,Gl:S,Hh:B,Hl:I}=this;for(let b=0;b<80;b++){const w=sn(d,h,14)^sn(d,h,18)^ii(d,h,41),x=an(d,h,14)^an(d,h,18)^oi(d,h,41),_=d&f^~d&g,N=h&y^~h&S,k=z0(I,x,N,ey[b],ir[b]),T=J0(k,B,w,_,Q0[b],nr[b]),L=k|0,F=sn(r,a,28)^ii(r,a,34)^ii(r,a,39),O=an(r,a,28)^oi(r,a,34)^oi(r,a,39),R=r&o^r&s^o&s,P=a&i^a&c^i&c;B=g|0,I=S|0,g=f|0,S=y|0,f=d|0,y=h|0,{h:d,l:h}=Lt(l|0,u|0,T|0,L|0),l=s|0,u=c|0,s=o|0,c=i|0,o=r|0,i=a|0;const K=G0(L,O,P);r=W0(K,T,F,R),a=K|0}({h:r,l:a}=Lt(this.Ah|0,this.Al|0,r|0,a|0)),{h:o,l:i}=Lt(this.Bh|0,this.Bl|0,o|0,i|0),{h:s,l:c}=Lt(this.Ch|0,this.Cl|0,s|0,c|0),{h:l,l:u}=Lt(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:h}=Lt(this.Eh|0,this.El|0,d|0,h|0),{h:f,l:y}=Lt(this.Fh|0,this.Fl|0,f|0,y|0),{h:g,l:S}=Lt(this.Gh|0,this.Gl|0,g|0,S|0),{h:B,l:I}=Lt(this.Hh|0,this.Hl|0,B|0,I|0),this.set(r,a,o,i,s,c,l,u,d,h,f,y,g,S,B,I)}roundClean(){En(nr,ir)}destroy(){En(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class ty extends yd{constructor(){super(48),this.Ah=Ve[0]|0,this.Al=Ve[1]|0,this.Bh=Ve[2]|0,this.Bl=Ve[3]|0,this.Ch=Ve[4]|0,this.Cl=Ve[5]|0,this.Dh=Ve[6]|0,this.Dl=Ve[7]|0,this.Eh=Ve[8]|0,this.El=Ve[9]|0,this.Fh=Ve[10]|0,this.Fl=Ve[11]|0,this.Gh=Ve[12]|0,this.Gl=Ve[13]|0,this.Hh=Ve[14]|0,this.Hl=Ve[15]|0}}const ry=fa(()=>new Z0),ny=fa(()=>new yd),iy=fa(()=>new ty);class gd extends Jl{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,Xl(t);const r=ua(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const a=this.blockLen,o=new Uint8Array(a);o.set(r.length>a?t.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=t.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),En(o)}update(t){return Bi(this),this.iHash.update(t),this}digestInto(t){Bi(this),Jr(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:a,destroyed:o,blockLen:i,outputLen:s}=this;return t=t,t.finished=a,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const wd=(e,t,n)=>new gd(e,t).update(n).digest();wd.create=(e,t)=>new gd(e,t);const xn=BigInt(0),Mr=BigInt(1);function Ri(e,t){const n=t.negate();return e?n:t}function po(e,t){const n=ud(e.Fp,t.map(r=>r.Z));return t.map((r,a)=>e.fromAffine(r.toAffine(n[a])))}function md(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function yo(e,t){md(e,t);const n=Math.ceil(t/e)+1,r=2**(e-1),a=2**e,o=Wn(e),i=BigInt(e);return{windows:n,windowSize:r,mask:o,maxNumber:a,shiftBy:i}}function pc(e,t,n){const{windowSize:r,mask:a,maxNumber:o,shiftBy:i}=n;let s=Number(e&a),c=e>>i;s>r&&(s-=o,c+=Mr);const l=t*r,u=l+Math.abs(s)-1,d=s===0,h=s<0,f=t%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:f,offsetF:l}}function oy(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((n,r)=>{if(!(n instanceof t))throw new Error("invalid point at index "+r)})}function sy(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((n,r)=>{if(!t.isValid(n))throw new Error("invalid scalar at index "+r)})}const go=new WeakMap,bd=new WeakMap;function wo(e){return bd.get(e)||1}function yc(e){if(e!==xn)throw new Error("invalid wNAF")}class ay{constructor(t,n){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let a=t;for(;n>xn;)n&Mr&&(r=r.add(a)),a=a.double(),n>>=Mr;return r}precomputeWindow(t,n){const{windows:r,windowSize:a}=yo(n,this.bits),o=[];let i=t,s=i;for(let c=0;c<r;c++){s=i,o.push(s);for(let l=1;l<a;l++)s=s.add(i),o.push(s);i=s.double()}return o}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let a=this.ZERO,o=this.BASE;const i=yo(t,this.bits);for(let s=0;s<i.windows;s++){const{nextN:c,offset:l,isZero:u,isNeg:d,isNegF:h,offsetF:f}=pc(r,s,i);r=c,u?o=o.add(Ri(h,n[f])):a=a.add(Ri(d,n[l]))}return yc(r),{p:a,f:o}}wNAFUnsafe(t,n,r,a=this.ZERO){const o=yo(t,this.bits);for(let i=0;i<o.windows&&r!==xn;i++){const{nextN:s,offset:c,isZero:l,isNeg:u}=pc(r,i,o);if(r=s,!l){const d=n[c];a=a.add(u?d.negate():d)}}return yc(r),a}getPrecomputes(t,n,r){let a=go.get(n);return a||(a=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(a=r(a)),go.set(n,a))),a}cached(t,n,r){const a=wo(t);return this.wNAF(a,this.getPrecomputes(a,t,r),n)}unsafe(t,n,r,a){const o=wo(t);return o===1?this._unsafeLadder(t,n,a):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),n,a)}createCache(t,n){md(n,this.bits),bd.set(t,n),go.delete(t)}hasCache(t){return wo(t)!==1}}function cy(e,t,n,r){let a=t,o=e.ZERO,i=e.ZERO;for(;n>xn||r>xn;)n&Mr&&(o=o.add(a)),r&Mr&&(i=i.add(a)),a=a.double(),n>>=Mr,r>>=Mr;return{p1:o,p2:i}}function uy(e,t,n,r){oy(n,e),sy(r,t);const a=n.length,o=r.length;if(a!==o)throw new Error("arrays of points and scalars must have equal length");const i=e.ZERO,s=td(BigInt(a));let c=1;s>12?c=s-3:s>4?c=s-2:s>0&&(c=2);const l=Wn(c),u=new Array(Number(l)+1).fill(i),d=Math.floor((t.BITS-1)/c)*c;let h=i;for(let f=d;f>=0;f-=c){u.fill(i);for(let g=0;g<o;g++){const S=r[g],B=Number(S>>BigInt(f)&l);u[B]=u[B].add(n[g])}let y=i;for(let g=u.length-1,S=i;g>0;g--)S=S.add(u[g]),y=y.add(S);if(h=h.add(y),f!==0)for(let g=0;g<c;g++)h=h.double()}return h}function gc(e,t,n){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return N0(t),t}else return Yr(e,{isLE:n})}function fy(e,t,n={},r){if(r===void 0&&(r=e==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${e} CURVE object`);for(const c of["p","n","h"]){const l=t[c];if(!(typeof l=="bigint"&&l>xn))throw new Error(`CURVE.${c} must be positive bigint`)}const a=gc(t.p,n.Fp,r),o=gc(t.n,n.Fn,r),s=["Gx","Gy","a","b"];for(const c of s)if(!a.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:a,Fn:o}}const wc=(e,t)=>(e+(e>=0?t:-t)/vd)/t;function ly(e,t,n){const[[r,a],[o,i]]=t,s=wc(i*e,n),c=wc(-a*e,n);let l=e-s*r-c*o,u=-s*a-c*i;const d=l<qt,h=u<qt;d&&(l=-l),h&&(u=-u);const f=Wn(Math.ceil(td(n)/2))+wn;if(l<qt||l>=f||u<qt||u>=f)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:d,k1:l,k2neg:h,k2:u}}function Hs(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function mo(e,t){const n={};for(let r of Object.keys(t))n[r]=e[r]===void 0?t[r]:e[r];return Oi(n.lowS,"lowS"),Oi(n.prehash,"prehash"),n.format!==void 0&&Hs(n.format),n}class dy extends Error{constructor(t=""){super(t)}}const Ct={Err:dy,_tlv:{encode:(e,t)=>{const{Err:n}=Ct;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length&1)throw new n("tlv.encode: unpadded data");const r=t.length/2,a=ri(r);if(a.length/2&128)throw new n("tlv.encode: long form length too big");const o=r>127?ri(a.length/2|128):"";return ri(e)+o+a+t},decode(e,t){const{Err:n}=Ct;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const a=t[r++],o=!!(a&128);let i=0;if(!o)i=a;else{const c=a&127;if(!c)throw new n("tlv.decode(long): indefinite length not supported");if(c>4)throw new n("tlv.decode(long): byte length is too big");const l=t.subarray(r,r+c);if(l.length!==c)throw new n("tlv.decode: length bytes not complete");if(l[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const u of l)i=i<<8|u;if(r+=c,i<128)throw new n("tlv.decode(long): not minimal encoding")}const s=t.subarray(r,r+i);if(s.length!==i)throw new n("tlv.decode: wrong value length");return{v:s,l:t.subarray(r+i)}}},_int:{encode(e){const{Err:t}=Ct;if(e<qt)throw new t("integer: negative integers are not allowed");let n=ri(e);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Ct;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return qi(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=Ct,a=tt("signature",e),{v:o,l:i}=r.decode(48,a);if(i.length)throw new t("invalid signature: left bytes after parsing");const{v:s,l:c}=r.decode(2,o),{v:l,l:u}=r.decode(2,c);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(s),s:n.decode(l)}},hexFromSig(e){const{_tlv:t,_int:n}=Ct,r=t.encode(2,n.encode(e.r)),a=t.encode(2,n.encode(e.s)),o=r+a;return t.encode(48,o)}},qt=BigInt(0),wn=BigInt(1),vd=BigInt(2),si=BigInt(3),hy=BigInt(4);function yn(e,t){const{BYTES:n}=e;let r;if(typeof t=="bigint")r=t;else{let a=tt("private key",t);try{r=e.fromBytes(a)}catch{throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof t}`)}}if(!e.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function py(e,t={}){const n=fy("weierstrass",e,t),{Fp:r,Fn:a}=n;let o=n.CURVE;const{h:i,n:s}=o;ha(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=t;if(c&&(!r.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const l=xd(r,a);function u(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(O,R,P){const{x:K,y:U}=R.toAffine(),V=r.toBytes(K);if(Oi(P,"isCompressed"),P){u();const C=!r.isOdd(U);return mr(Ed(C),V)}else return mr(Uint8Array.of(4),V,r.toBytes(U))}function h(O){Nr(O,void 0,"Point");const{publicKey:R,publicKeyUncompressed:P}=l,K=O.length,U=O[0],V=O.subarray(1);if(K===R&&(U===2||U===3)){const C=r.fromBytes(V);if(!r.isValid(C))throw new Error("bad point: is not on curve, wrong x");const H=g(C);let D;try{D=r.sqrt(H)}catch(re){const se=re instanceof Error?": "+re.message:"";throw new Error("bad point: is not on curve, sqrt error"+se)}u();const W=r.isOdd(D);return(U&1)===1!==W&&(D=r.neg(D)),{x:C,y:D}}else if(K===P&&U===4){const C=r.BYTES,H=r.fromBytes(V.subarray(0,C)),D=r.fromBytes(V.subarray(C,C*2));if(!S(H,D))throw new Error("bad point: is not on curve");return{x:H,y:D}}else throw new Error(`bad point: got length ${K}, expected compressed=${R} or uncompressed=${P}`)}const f=t.toBytes||d,y=t.fromBytes||h;function g(O){const R=r.sqr(O),P=r.mul(R,O);return r.add(r.add(P,r.mul(O,o.a)),o.b)}function S(O,R){const P=r.sqr(R),K=g(O);return r.eql(P,K)}if(!S(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const B=r.mul(r.pow(o.a,si),hy),I=r.mul(r.sqr(o.b),BigInt(27));if(r.is0(r.add(B,I)))throw new Error("bad curve params: a or b");function b(O,R,P=!1){if(!r.isValid(R)||P&&r.is0(R))throw new Error(`bad point coordinate ${O}`);return R}function w(O){if(!(O instanceof T))throw new Error("ProjectivePoint expected")}function x(O){if(!c||!c.basises)throw new Error("no endo");return ly(O,c.basises,a.ORDER)}const _=cc((O,R)=>{const{X:P,Y:K,Z:U}=O;if(r.eql(U,r.ONE))return{x:P,y:K};const V=O.is0();R==null&&(R=V?r.ONE:r.inv(U));const C=r.mul(P,R),H=r.mul(K,R),D=r.mul(U,R);if(V)return{x:r.ZERO,y:r.ZERO};if(!r.eql(D,r.ONE))throw new Error("invZ was invalid");return{x:C,y:H}}),N=cc(O=>{if(O.is0()){if(t.allowInfinityPoint&&!r.is0(O.Y))return;throw new Error("bad point: ZERO")}const{x:R,y:P}=O.toAffine();if(!r.isValid(R)||!r.isValid(P))throw new Error("bad point: x or y not field elements");if(!S(R,P))throw new Error("bad point: equation left != right");if(!O.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function k(O,R,P,K,U){return P=new T(r.mul(P.X,O),P.Y,P.Z),R=Ri(K,R),P=Ri(U,P),R.add(P)}class T{constructor(R,P,K){this.X=b("x",R),this.Y=b("y",P,!0),this.Z=b("z",K),Object.freeze(this)}static CURVE(){return o}static fromAffine(R){const{x:P,y:K}=R||{};if(!R||!r.isValid(P)||!r.isValid(K))throw new Error("invalid affine point");if(R instanceof T)throw new Error("projective point not allowed");return r.is0(P)&&r.is0(K)?T.ZERO:new T(P,K,r.ONE)}static fromBytes(R){const P=T.fromAffine(y(Nr(R,void 0,"point")));return P.assertValidity(),P}static fromHex(R){return T.fromBytes(tt("pointHex",R))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(R=8,P=!0){return F.createCache(this,R),P||this.multiply(si),this}assertValidity(){N(this)}hasEvenY(){const{y:R}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(R)}equals(R){w(R);const{X:P,Y:K,Z:U}=this,{X:V,Y:C,Z:H}=R,D=r.eql(r.mul(P,H),r.mul(V,U)),W=r.eql(r.mul(K,H),r.mul(C,U));return D&&W}negate(){return new T(this.X,r.neg(this.Y),this.Z)}double(){const{a:R,b:P}=o,K=r.mul(P,si),{X:U,Y:V,Z:C}=this;let H=r.ZERO,D=r.ZERO,W=r.ZERO,J=r.mul(U,U),re=r.mul(V,V),se=r.mul(C,C),z=r.mul(U,V);return z=r.add(z,z),W=r.mul(U,C),W=r.add(W,W),H=r.mul(R,W),D=r.mul(K,se),D=r.add(H,D),H=r.sub(re,D),D=r.add(re,D),D=r.mul(H,D),H=r.mul(z,H),W=r.mul(K,W),se=r.mul(R,se),z=r.sub(J,se),z=r.mul(R,z),z=r.add(z,W),W=r.add(J,J),J=r.add(W,J),J=r.add(J,se),J=r.mul(J,z),D=r.add(D,J),se=r.mul(V,C),se=r.add(se,se),J=r.mul(se,z),H=r.sub(H,J),W=r.mul(se,re),W=r.add(W,W),W=r.add(W,W),new T(H,D,W)}add(R){w(R);const{X:P,Y:K,Z:U}=this,{X:V,Y:C,Z:H}=R;let D=r.ZERO,W=r.ZERO,J=r.ZERO;const re=o.a,se=r.mul(o.b,si);let z=r.mul(P,V),X=r.mul(K,C),Y=r.mul(U,H),ae=r.add(P,K),ce=r.add(V,C);ae=r.mul(ae,ce),ce=r.add(z,X),ae=r.sub(ae,ce),ce=r.add(P,U);let oe=r.add(V,H);return ce=r.mul(ce,oe),oe=r.add(z,Y),ce=r.sub(ce,oe),oe=r.add(K,U),D=r.add(C,H),oe=r.mul(oe,D),D=r.add(X,Y),oe=r.sub(oe,D),J=r.mul(re,ce),D=r.mul(se,Y),J=r.add(D,J),D=r.sub(X,J),J=r.add(X,J),W=r.mul(D,J),X=r.add(z,z),X=r.add(X,z),Y=r.mul(re,Y),ce=r.mul(se,ce),X=r.add(X,Y),Y=r.sub(z,Y),Y=r.mul(re,Y),ce=r.add(ce,Y),z=r.mul(X,ce),W=r.add(W,z),z=r.mul(oe,ce),D=r.mul(ae,D),D=r.sub(D,z),z=r.mul(ae,X),J=r.mul(oe,J),J=r.add(J,z),new T(D,W,J)}subtract(R){return this.add(R.negate())}is0(){return this.equals(T.ZERO)}multiply(R){const{endo:P}=t;if(!a.isValidNot0(R))throw new Error("invalid scalar: out of range");let K,U;const V=C=>F.cached(this,C,H=>po(T,H));if(P){const{k1neg:C,k1:H,k2neg:D,k2:W}=x(R),{p:J,f:re}=V(H),{p:se,f:z}=V(W);U=re.add(z),K=k(P.beta,J,se,C,D)}else{const{p:C,f:H}=V(R);K=C,U=H}return po(T,[K,U])[0]}multiplyUnsafe(R){const{endo:P}=t,K=this;if(!a.isValid(R))throw new Error("invalid scalar: out of range");if(R===qt||K.is0())return T.ZERO;if(R===wn)return K;if(F.hasCache(this))return this.multiply(R);if(P){const{k1neg:U,k1:V,k2neg:C,k2:H}=x(R),{p1:D,p2:W}=cy(T,K,V,H);return k(P.beta,D,W,U,C)}else return F.unsafe(K,R)}multiplyAndAddUnsafe(R,P,K){const U=this.multiplyUnsafe(P).add(R.multiplyUnsafe(K));return U.is0()?void 0:U}toAffine(R){return _(this,R)}isTorsionFree(){const{isTorsionFree:R}=t;return i===wn?!0:R?R(T,this):F.unsafe(this,s).is0()}clearCofactor(){const{clearCofactor:R}=t;return i===wn?this:R?R(T,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(R=!0){return Oi(R,"isCompressed"),this.assertValidity(),f(T,this,R)}toHex(R=!0){return gn(this.toBytes(R))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(R=!0){return this.toBytes(R)}_setWindowSize(R){this.precompute(R)}static normalizeZ(R){return po(T,R)}static msm(R,P){return uy(T,a,R,P)}static fromPrivateKey(R){return T.BASE.multiply(yn(a,R))}}T.BASE=new T(o.Gx,o.Gy,r.ONE),T.ZERO=new T(r.ZERO,r.ONE,r.ZERO),T.Fp=r,T.Fn=a;const L=a.BITS,F=new ay(T,t.endo?Math.ceil(L/2):L);return T.BASE.precompute(8),T}function Ed(e){return Uint8Array.of(e?2:3)}function xd(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function yy(e,t={}){const{Fn:n}=e,r=t.randomBytes||Yl,a=Object.assign(xd(e.Fp,n),{seed:dd(n.ORDER)});function o(f){try{return!!yn(n,f)}catch{return!1}}function i(f,y){const{publicKey:g,publicKeyUncompressed:S}=a;try{const B=f.length;return y===!0&&B!==g||y===!1&&B!==S?!1:!!e.fromBytes(f)}catch{return!1}}function s(f=r(a.seed)){return M0(Nr(f,a.seed,"seed"),n.ORDER)}function c(f,y=!0){return e.BASE.multiply(yn(n,f)).toBytes(y)}function l(f){const y=s(f);return{secretKey:y,publicKey:c(y)}}function u(f){if(typeof f=="bigint")return!1;if(f instanceof e)return!0;const{secretKey:y,publicKey:g,publicKeyUncompressed:S}=a;if(n.allowedLengths||y===g)return;const B=tt("key",f).length;return B===g||B===S}function d(f,y,g=!0){if(u(f)===!0)throw new Error("first arg must be private key");if(u(y)===!1)throw new Error("second arg must be public key");const S=yn(n,f);return e.fromHex(y).multiply(S).toBytes(g)}return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:l,Point:e,utils:{isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:s,isValidPrivateKey:o,randomPrivateKey:s,normPrivateKeyToScalar:f=>yn(n,f),precompute(f=8,y=e.BASE){return y.precompute(f,!1)}},lengths:a})}function gy(e,t,n={}){Xl(t),ha(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||Yl,a=n.hmac||((P,...K)=>wd(t,P,mr(...K))),{Fp:o,Fn:i}=e,{ORDER:s,BITS:c}=i,{keygen:l,getPublicKey:u,getSharedSecret:d,utils:h,lengths:f}=yy(e,n),y={prehash:!1,lowS:typeof n.lowS=="boolean"?n.lowS:!1,format:void 0,extraEntropy:!1},g="compact";function S(P){const K=s>>wn;return P>K}function B(P,K){if(!i.isValidNot0(K))throw new Error(`invalid signature ${P}: out of range 1..Point.Fn.ORDER`);return K}function I(P,K){Hs(K);const U=f.signature,V=K==="compact"?U:K==="recovered"?U+1:void 0;return Nr(P,V,`${K} signature`)}class b{constructor(K,U,V){this.r=B("r",K),this.s=B("s",U),V!=null&&(this.recovery=V),Object.freeze(this)}static fromBytes(K,U=g){I(K,U);let V;if(U==="der"){const{r:W,s:J}=Ct.toSig(Nr(K));return new b(W,J)}U==="recovered"&&(V=K[0],U="compact",K=K.subarray(1));const C=i.BYTES,H=K.subarray(0,C),D=K.subarray(C,C*2);return new b(i.fromBytes(H),i.fromBytes(D),V)}static fromHex(K,U){return this.fromBytes(ki(K),U)}addRecoveryBit(K){return new b(this.r,this.s,K)}recoverPublicKey(K){const U=o.ORDER,{r:V,s:C,recovery:H}=this;if(H==null||![0,1,2,3].includes(H))throw new Error("recovery id invalid");if(s*vd<U&&H>1)throw new Error("recovery id is ambiguous for h>1 curve");const W=H===2||H===3?V+s:V;if(!o.isValid(W))throw new Error("recovery id 2 or 3 invalid");const J=o.toBytes(W),re=e.fromBytes(mr(Ed((H&1)===0),J)),se=i.inv(W),z=x(tt("msgHash",K)),X=i.create(-z*se),Y=i.create(C*se),ae=e.BASE.multiplyUnsafe(X).add(re.multiplyUnsafe(Y));if(ae.is0())throw new Error("point at infinify");return ae.assertValidity(),ae}hasHighS(){return S(this.s)}toBytes(K=g){if(Hs(K),K==="der")return ki(Ct.hexFromSig(this));const U=i.toBytes(this.r),V=i.toBytes(this.s);if(K==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return mr(Uint8Array.of(this.recovery),U,V)}return mr(U,V)}toHex(K){return gn(this.toBytes(K))}assertValidity(){}static fromCompact(K){return b.fromBytes(tt("sig",K),"compact")}static fromDER(K){return b.fromBytes(tt("sig",K),"der")}normalizeS(){return this.hasHighS()?new b(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return gn(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return gn(this.toBytes("compact"))}}const w=n.bits2int||function(K){if(K.length>8192)throw new Error("input is too large");const U=qi(K),V=K.length*8-c;return V>0?U>>BigInt(V):U},x=n.bits2int_modN||function(K){return i.create(w(K))},_=Wn(c);function N(P){return k0("num < 2^"+c,P,qt,_),i.toBytes(P)}function k(P,K){return Nr(P,void 0,"message"),K?Nr(t(P),void 0,"prehashed message"):P}function T(P,K,U){if(["recovered","canonical"].some(X=>X in U))throw new Error("sign() legacy options not supported");const{lowS:V,prehash:C,extraEntropy:H}=mo(U,y);P=k(P,C);const D=x(P),W=yn(i,K),J=[N(W),N(D)];if(H!=null&&H!==!1){const X=H===!0?r(f.secretKey):H;J.push(tt("extraEntropy",X))}const re=mr(...J),se=D;function z(X){const Y=w(X);if(!i.isValidNot0(Y))return;const ae=i.inv(Y),ce=e.BASE.multiply(Y).toAffine(),oe=i.create(ce.x);if(oe===qt)return;const de=i.create(ae*i.create(se+oe*W));if(de===qt)return;let pe=(ce.x===oe?0:2)|Number(ce.y&wn),fe=de;return V&&S(de)&&(fe=i.neg(de),pe^=1),new b(oe,fe,pe)}return{seed:re,k2sig:z}}function L(P,K,U={}){P=tt("message",P);const{seed:V,k2sig:C}=T(P,K,U);return O0(t.outputLen,i.BYTES,a)(V,C)}function F(P){let K;const U=typeof P=="string"||ji(P),V=!U&&P!==null&&typeof P=="object"&&typeof P.r=="bigint"&&typeof P.s=="bigint";if(!U&&!V)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(V)K=new b(P.r,P.s);else if(U){try{K=b.fromBytes(tt("sig",P),"der")}catch(C){if(!(C instanceof Ct.Err))throw C}if(!K)try{K=b.fromBytes(tt("sig",P),"compact")}catch{return!1}}return K||!1}function O(P,K,U,V={}){const{lowS:C,prehash:H,format:D}=mo(V,y);if(U=tt("publicKey",U),K=k(tt("message",K),H),"strict"in V)throw new Error("options.strict was renamed to lowS");const W=D===void 0?F(P):b.fromBytes(tt("sig",P),D);if(W===!1)return!1;try{const J=e.fromBytes(U);if(C&&W.hasHighS())return!1;const{r:re,s:se}=W,z=x(K),X=i.inv(se),Y=i.create(z*X),ae=i.create(re*X),ce=e.BASE.multiplyUnsafe(Y).add(J.multiplyUnsafe(ae));return ce.is0()?!1:i.create(ce.x)===re}catch{return!1}}function R(P,K,U={}){const{prehash:V}=mo(U,y);return K=k(K,V),b.fromBytes(P,"recovered").recoverPublicKey(K).toBytes()}return Object.freeze({keygen:l,getPublicKey:u,getSharedSecret:d,utils:h,lengths:f,Point:e,sign:L,verify:O,recoverPublicKey:R,Signature:b,hash:t})}function wy(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},n=e.Fp;let r=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0;const a=Yr(t.n,{BITS:e.nBitLength,allowedLengths:r,modFromBytes:e.wrapPrivateKey}),o={Fp:n,Fn:a,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:t,curveOpts:o}}function my(e){const{CURVE:t,curveOpts:n}=wy(e),r={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:n,hash:e.hash,ecdsaOpts:r}}function by(e,t){const n=t.Point;return Object.assign({},t,{ProjectivePoint:n,CURVE:Object.assign({},e,fd(n.Fn.ORDER,n.Fn.BITS))})}function vy(e){const{CURVE:t,curveOpts:n,hash:r,ecdsaOpts:a}=my(e),o=py(t,n),i=gy(o,r,a);return by(e,i)}function ya(e,t){const n=r=>vy({...e,hash:r});return{...n(t),create:n}}const Sd={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},Id={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},_d={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},Ey=Yr(Sd.p),xy=Yr(Id.p),Sy=Yr(_d.p),Iy=ya({...Sd,Fp:Ey,lowS:!1},ry);ya({...Id,Fp:xy,lowS:!1},iy);ya({..._d,Fp:Sy,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},ny);const mc=Iy;function _y(e){if(e==="ES256K")return"Secp256k1";if(e==="Ed25519")return"Ed25519";if(e==="ES256")return"P256";const t=e;throw new Error(`Unsupported key type: ${String(t)}`)}function bc(e){if(e==="Secp256k1")return"ES256K";if(e==="Ed25519")return"Ed25519";if(e==="P256")return"ES256";throw new Error("Unsupported key type")}class vc{constructor(){}async generateKeyPair(t){if(t==="ES256K"){const r=Pl.randomPrivateKey(),a=Tl(r,!0);return{privateKey:Ze.encodePrivateKey(r,"Secp256k1"),publicKey:Ze.encodePublicKey(a,"Secp256k1")}}if(t==="Ed25519"){const r=yl.randomPrivateKey(),o=await wl.getPublicKeyAsync(r);return{privateKey:Ze.encodePrivateKey(r,"Ed25519"),publicKey:Ze.encodePublicKey(o,"Ed25519")}}if(t==="ES256"){const r=mc.utils.randomPrivateKey(),a=mc.getPublicKey(r,!0);return{privateKey:Ze.encodePrivateKey(r,"P256"),publicKey:Ze.encodePublicKey(a,"P256")}}const n=t;throw new Error(`Unsupported key type: ${String(n)}`)}rotateKeys(t,n){const r="https://w3id.org/security/multikey/v1",a="https://w3id.org/security/v1",o=[...t["@context"]];o.includes(r)||o.push(r),o.includes(a)||o.push(a);const i=t.verificationMethod||[],s=i.length,c=`${t.id}#keys-${s}`,l=new Date().toISOString(),u=i.map(y=>({...y,revoked:l})),d={id:c,type:"Multikey",controller:t.id,publicKeyMultibase:n.publicKey},h=c,f={...t,"@context":o,verificationMethod:[...u,d],authentication:[h],assertionMethod:[h]};return t.keyAgreement&&(f.keyAgreement=t.keyAgreement),t.capabilityInvocation&&(f.capabilityInvocation=t.capabilityInvocation),t.capabilityDelegation&&(f.capabilityDelegation=t.capabilityDelegation),t.service&&(f.service=t.service),f}async recoverFromCompromise(t){let n="Ed25519";if(t.verificationMethod&&t.verificationMethod.length>0)try{const B=t.verificationMethod[0],I=Ze.decodePublicKey(B.publicKeyMultibase);n=bc(I.type)}catch{}const r=await this.generateKeyPair(n),a="https://w3id.org/security/multikey/v1",o="https://w3id.org/security/v1",i="https://www.w3.org/2018/credentials/v1",s=[...t["@context"]];s.includes(a)||s.push(a),s.includes(o)||s.push(o);const c=new Date().toISOString(),l=t.verificationMethod||[],u=l.map(B=>({...B,compromised:c})),d=l.map(B=>B.id),h=l.length,f=`${t.id}#keys-${h}`,y={id:f,type:"Multikey",controller:t.id,publicKeyMultibase:r.publicKey},g={...t,"@context":s,verificationMethod:[...u,y],authentication:[f],assertionMethod:[f]};t.keyAgreement&&(g.keyAgreement=t.keyAgreement),t.capabilityInvocation&&(g.capabilityInvocation=t.capabilityInvocation),t.capabilityDelegation&&(g.capabilityDelegation=t.capabilityDelegation),t.service&&(g.service=t.service);const S={"@context":[i,o],type:["VerifiableCredential","KeyRecoveryCredential"],issuer:t.id,issuanceDate:c,credentialSubject:{id:t.id,recoveredAt:c,recoveryReason:"key_compromise",previousVerificationMethods:d,newVerificationMethod:f}};return{didDocument:g,recoveryCredential:S,newKeyPair:r}}encodePublicKeyMultibase(t,n){const r=_y(n);return Ze.encodePublicKey(new Uint8Array(t),r)}decodePublicKeyMultibase(t){if(!t||typeof t!="string")throw new Error("Invalid multibase string");try{const n=Ze.decodePublicKey(t);return{key:te.from(n.key),type:bc(n.type)}}catch{throw new Error("Invalid multibase string")}}}class Ay{}class Ty extends Ay{async sign(t,n){if(!n||n[0]!=="z")throw new Error("Invalid multibase key format. Keys must use multicodec headers.");let r;try{r=Ze.decodePrivateKey(n)}catch(i){throw new Error(`Invalid multibase key format. Keys must use multicodec headers. ${i instanceof Error?i.message:String(i)}`)}if(r.type!=="Ed25519")throw new Error("Invalid key type for Ed25519");const a=r.key,o=await dl(t,a);return te.from(o)}async verify(t,n,r){if(!r||r[0]!=="z")throw new Error("Invalid multibase key format. Keys must use multicodec headers.");let a;try{a=Ze.decodePublicKey(r)}catch(i){throw new Error(`Invalid multibase key format. Keys must use multicodec headers. ${i instanceof Error?i.message:String(i)}`)}if(a.type!=="Ed25519")throw new Error("Invalid key type for Ed25519");const o=a.key;try{return await pl(n,t,o)}catch{return!1}}}const By={},Ad=Object.freeze(Object.defineProperty({__proto__:null,default:By},Symbol.toStringTag,{value:"Module"}));var bo,Ec;function ky(){if(Ec)return bo;Ec=1;function e(a){if(typeof a!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(a))}function t(a,o){for(var i="",s=0,c=-1,l=0,u,d=0;d<=a.length;++d){if(d<a.length)u=a.charCodeAt(d);else{if(u===47)break;u=47}if(u===47){if(!(c===d-1||l===1))if(c!==d-1&&l===2){if(i.length<2||s!==2||i.charCodeAt(i.length-1)!==46||i.charCodeAt(i.length-2)!==46){if(i.length>2){var h=i.lastIndexOf("/");if(h!==i.length-1){h===-1?(i="",s=0):(i=i.slice(0,h),s=i.length-1-i.lastIndexOf("/")),c=d,l=0;continue}}else if(i.length===2||i.length===1){i="",s=0,c=d,l=0;continue}}o&&(i.length>0?i+="/..":i="..",s=2)}else i.length>0?i+="/"+a.slice(c+1,d):i=a.slice(c+1,d),s=d-c-1;c=d,l=0}else u===46&&l!==-1?++l:l=-1}return i}function n(a,o){var i=o.dir||o.root,s=o.base||(o.name||"")+(o.ext||"");return i?i===o.root?i+s:i+a+s:s}var r={resolve:function(){for(var o="",i=!1,s,c=arguments.length-1;c>=-1&&!i;c--){var l;c>=0?l=arguments[c]:(s===void 0&&(s=dn.cwd()),l=s),e(l),l.length!==0&&(o=l+"/"+o,i=l.charCodeAt(0)===47)}return o=t(o,!i),i?o.length>0?"/"+o:"/":o.length>0?o:"."},normalize:function(o){if(e(o),o.length===0)return".";var i=o.charCodeAt(0)===47,s=o.charCodeAt(o.length-1)===47;return o=t(o,!i),o.length===0&&!i&&(o="."),o.length>0&&s&&(o+="/"),i?"/"+o:o},isAbsolute:function(o){return e(o),o.length>0&&o.charCodeAt(0)===47},join:function(){if(arguments.length===0)return".";for(var o,i=0;i<arguments.length;++i){var s=arguments[i];e(s),s.length>0&&(o===void 0?o=s:o+="/"+s)}return o===void 0?".":r.normalize(o)},relative:function(o,i){if(e(o),e(i),o===i||(o=r.resolve(o),i=r.resolve(i),o===i))return"";for(var s=1;s<o.length&&o.charCodeAt(s)===47;++s);for(var c=o.length,l=c-s,u=1;u<i.length&&i.charCodeAt(u)===47;++u);for(var d=i.length,h=d-u,f=l<h?l:h,y=-1,g=0;g<=f;++g){if(g===f){if(h>f){if(i.charCodeAt(u+g)===47)return i.slice(u+g+1);if(g===0)return i.slice(u+g)}else l>f&&(o.charCodeAt(s+g)===47?y=g:g===0&&(y=0));break}var S=o.charCodeAt(s+g),B=i.charCodeAt(u+g);if(S!==B)break;S===47&&(y=g)}var I="";for(g=s+y+1;g<=c;++g)(g===c||o.charCodeAt(g)===47)&&(I.length===0?I+="..":I+="/..");return I.length>0?I+i.slice(u+y):(u+=y,i.charCodeAt(u)===47&&++u,i.slice(u))},_makeLong:function(o){return o},dirname:function(o){if(e(o),o.length===0)return".";for(var i=o.charCodeAt(0),s=i===47,c=-1,l=!0,u=o.length-1;u>=1;--u)if(i=o.charCodeAt(u),i===47){if(!l){c=u;break}}else l=!1;return c===-1?s?"/":".":s&&c===1?"//":o.slice(0,c)},basename:function(o,i){if(i!==void 0&&typeof i!="string")throw new TypeError('"ext" argument must be a string');e(o);var s=0,c=-1,l=!0,u;if(i!==void 0&&i.length>0&&i.length<=o.length){if(i.length===o.length&&i===o)return"";var d=i.length-1,h=-1;for(u=o.length-1;u>=0;--u){var f=o.charCodeAt(u);if(f===47){if(!l){s=u+1;break}}else h===-1&&(l=!1,h=u+1),d>=0&&(f===i.charCodeAt(d)?--d===-1&&(c=u):(d=-1,c=h))}return s===c?c=h:c===-1&&(c=o.length),o.slice(s,c)}else{for(u=o.length-1;u>=0;--u)if(o.charCodeAt(u)===47){if(!l){s=u+1;break}}else c===-1&&(l=!1,c=u+1);return c===-1?"":o.slice(s,c)}},extname:function(o){e(o);for(var i=-1,s=0,c=-1,l=!0,u=0,d=o.length-1;d>=0;--d){var h=o.charCodeAt(d);if(h===47){if(!l){s=d+1;break}continue}c===-1&&(l=!1,c=d+1),h===46?i===-1?i=d:u!==1&&(u=1):i!==-1&&(u=-1)}return i===-1||c===-1||u===0||u===1&&i===c-1&&i===s+1?"":o.slice(i,c)},format:function(o){if(o===null||typeof o!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof o);return n("/",o)},parse:function(o){e(o);var i={root:"",dir:"",base:"",ext:"",name:""};if(o.length===0)return i;var s=o.charCodeAt(0),c=s===47,l;c?(i.root="/",l=1):l=0;for(var u=-1,d=0,h=-1,f=!0,y=o.length-1,g=0;y>=l;--y){if(s=o.charCodeAt(y),s===47){if(!f){d=y+1;break}continue}h===-1&&(f=!1,h=y+1),s===46?u===-1?u=y:g!==1&&(g=1):u!==-1&&(g=-1)}return u===-1||h===-1||g===0||g===1&&u===h-1&&u===d+1?h!==-1&&(d===0&&c?i.base=i.name=o.slice(1,h):i.base=i.name=o.slice(d,h)):(d===0&&c?(i.name=o.slice(1,u),i.base=o.slice(1,h)):(i.name=o.slice(d,u),i.base=o.slice(d,h)),i.ext=o.slice(u,h)),d>0?i.dir=o.slice(0,d-1):c&&(i.dir="/"),i},sep:"/",delimiter:":",win32:null,posix:null};return r.posix=r,bo=r,bo}var _r=ky();class Zg{constructor(t){this.config=t}async createDIDPeer(t,n){const r=new vc,a=this.config.defaultKeyType||"ES256K",o=await r.generateKeyPair(a),i=await ln(()=>import("./index-Yf-itXSD.js"),__vite__mapDeps([0,1])),s=await i.createNumAlgo4([{type:"Multikey",publicKeyMultibase:o.publicKey}],void 0,void 0),l=await i.resolve(s);l&&Array.isArray(l.verificationMethod)&&(l.verificationMethod=l.verificationMethod.map(d=>({controller:s,...d})));const u=Array.isArray(l?.verificationMethod)?l.verificationMethod.map(d=>d.id).filter(Boolean):[];return(!l.authentication||l.authentication.length===0)&&u.length>0&&(l.authentication=[u[0]]),(!l.assertionMethod||l.assertionMethod.length===0)&&(l.assertionMethod=l.authentication||(u.length>0?[u[0]]:[])),n?{didDocument:l,keyPair:o}:l}async migrateToDIDWebVH(t,n){const r=this.config.webvhNetwork||Ya,a=n||Za(r),o=String(a||"").trim().toLowerCase(),[i,s]=o.split(":");if(s&&(!/^\d+$/.test(s)||parseInt(s)<1||parseInt(s)>65535))throw new Error(`Invalid domain: ${n} - invalid port`);const c=i==="localhost",l=/^(\d{1,3}\.){3}\d{1,3}$/.test(i);if(!c&&!l){const g="[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?";if(!new RegExp(`^(?=.{1,253}$)(?:${g})(?:\\.(?:${g}))+?$`,"i").test(i))throw new Error("Invalid domain")}const u=(t.id||"").split(":"),f=((u.slice(0,2).join(":")==="did:peer"?u.slice(2).join(":"):u[u.length-1])||"").toString().trim().replace(/[^a-zA-Z0-9._-]/g,"-").toLowerCase(),y={...t,id:`did:webvh:${o}:${f}`};return await Promise.resolve(y)}async migrateToDIDBTCO(t,n){const r=$l(n);if(!r.valid)throw new Error(`Invalid satoshi identifier: ${r.error}`);const a=Number(n);if(a<0)throw new Error("Satoshi identifier must be positive (>= 0)");if(a>Ti)throw new Error(`Satoshi identifier must be within Bitcoin's total supply (0 to ${Ti.toLocaleString()})`);let o;this.config.webvhNetwork?o=i0(this.config.webvhNetwork):o=this.config.network||"mainnet";const i=t.verificationMethod?.[0];let s,c;try{if(i&&i.publicKeyMultibase){const u=Ze.decodePublicKey(i.publicKeyMultibase);s=u.key,c=u.type}}catch(u){this.config.enableLogging&&console.warn("Failed to decode verification method public key:",u)}let l;return s&&c?l=sc(n,o,{publicKey:s,keyType:c}):l={"@context":["https://www.w3.org/ns/did/v1"],id:(o==="mainnet"?"did:btco:":o==="regtest"?"did:btco:reg:":"did:btco:sig:")+String(n)},t.service&&t.service.length>0&&(l.service=t.service),await Promise.resolve(l)}async resolveDID(t){try{if(t.startsWith("did:peer:")){try{return await(await ln(()=>import("./index-Yf-itXSD.js"),__vite__mapDeps([0,1]))).resolve(t)}catch(n){this.config.enableLogging&&console.warn("Failed to resolve did:peer:",n)}return{"@context":["https://www.w3.org/ns/did/v1"],id:t}}if(t.startsWith("did:btco:")||t.startsWith("did:btco:test:")||t.startsWith("did:btco:sig:")){const n=this.config.bitcoinRpcUrl||"http://localhost:3000",r=this.config.network||"mainnet",a=new p0(n,r),o=new I0(a,n);return(await new o0({provider:o}).resolve(t)).didDocument||null}if(t.startsWith("did:webvh:")){try{const n=await ln(()=>Promise.resolve().then(()=>Ji),void 0);if(n&&typeof n.resolveDID=="function"){const r=await n.resolveDID(t);if(r&&r.doc)return r.doc}}catch(n){this.config.enableLogging&&console.warn("Failed to resolve did:webvh:",n)}return{"@context":["https://www.w3.org/ns/did/v1"],id:t}}return{"@context":["https://www.w3.org/ns/did/v1"],id:t}}catch(n){return this.config.enableLogging&&console.error("Failed to resolve DID:",n),null}}validateDIDDocument(t){return!!t.id&&Array.isArray(t["@context"])}getLayerFromDID(t){if(t.startsWith("did:peer:"))return"did:peer";if(t.startsWith("did:webvh:"))return"did:webvh";if(t.startsWith("did:btco:"))return"did:btco";throw new Error("Unsupported DID method")}createBtcoDidDocument(t,n,r){return sc(t,n,r)}async createDIDWebVH(t){const{domain:n,keyPair:r,paths:a=[],portable:o=!1,outputDir:i,externalSigner:s,externalVerifier:c,verificationMethods:l,updateKeys:u}=t,d=this.config.webvhNetwork||Ya,h=n||Za(d),f=await ln(()=>Promise.resolve().then(()=>Ji),void 0),{createDID:y,prepareDataForSigning:g}=f;if(typeof y!="function"||typeof g!="function")throw new Error("Failed to load didwebvh-ts: invalid module exports");let S,B,I,b,w;if(s){if(!l||l.length===0)throw new Error("verificationMethods are required when using externalSigner");if(!u||u.length===0)throw new Error("updateKeys are required when using externalSigner");S=s,B=c||s,b=l,w=u,I=void 0}else{const N=new vc;I=r||await N.generateKeyPair("Ed25519"),b=[{type:"Multikey",publicKeyMultibase:I.publicKey}];const k=new xc(I.privateKey,b[0],g,{verificationMethod:b[0]});S=k,B=k,w=[`did:key:${I.publicKey}`]}const x=await y({domain:h,signer:S,verifier:B,updateKeys:w,verificationMethods:b,context:["https://www.w3.org/ns/did/v1","https://w3id.org/security/multikey/v1"],paths:a,portable:o,authentication:["#key-0"],assertionMethod:["#key-0"]});if(!this.validateDIDDocument(x.doc))throw new Error("Invalid DID document returned from createDID");let _;return i&&(_=await this.saveDIDLog(x.did,x.log,i)),{did:x.did,didDocument:x.doc,log:x.log,keyPair:I||{publicKey:"",privateKey:""},logPath:_}}async updateDIDWebVH(t){const{did:n,currentLog:r,updates:a,signer:o,verifier:i,outputDir:s}=t,c=await ln(()=>Promise.resolve().then(()=>Ji),void 0),{updateDID:l,prepareDataForSigning:u}=c;if(typeof l!="function")throw new Error("Failed to load didwebvh-ts: invalid module exports");let d,h;if("sign"in o&&"getVerificationMethodId"in o)d=o,h=i;else{const I=o,b={type:"Multikey",publicKeyMultibase:I.publicKey},w=new xc(I.privateKey,b,u,{verificationMethod:b});d=w,h=w}const g={...r[r.length-1].state,...a,id:n},S=await l({log:r,doc:g,signer:d,verifier:h});if(!this.validateDIDDocument(S.doc))throw new Error("Invalid DID document returned from updateDID");let B;return s&&(B=await this.saveDIDLog(n,S.log,s)),{didDocument:S.doc,log:S.log,logPath:B}}async saveDIDLog(t,n,r){const a=t.split(":");if(a.length<3||a[0]!=="did"||a[1]!=="webvh")throw new Error("Invalid did:webvh format");const o=a.slice(3);for(const g of o)if(!this.isValidPathSegment(g))throw new Error(`Invalid path segment in DID: "${g}". Path segments cannot contain '.', '..', path separators, or be absolute paths.`);const i=decodeURIComponent(a[2]),s=i.toLowerCase().replace(/[^a-z0-9._-]/g,"_");if(!this.isValidPathSegment(s))throw new Error(`Invalid domain segment in DID: "${i}"`);const c=[s,...o],l=_r.join(r,"did",...c,"did.jsonl"),u=_r.resolve(r),d=_r.resolve(l),h=_r.relative(u,d);if(h.startsWith("..")||_r.isAbsolute(h))throw new Error("Invalid DID path: resolved path is outside base directory");const f=_r.dirname(l);await(void 0).mkdir(f,{recursive:!0});const y=n.map(g=>JSON.stringify(g)).join(`
`);return await(void 0).writeFile(l,y,"utf8"),l}async loadDIDLog(t){return(await(void 0).readFile(t,"utf8")).trim().split(`
`).map(a=>JSON.parse(a))}isValidPathSegment(t){return!(!t||t==="."||t===".."||t.includes("/")||t.includes("\\")||t.includes("\0")||_r.isAbsolute(t))}}class xc{constructor(t,n,r,a={}){this.privateKeyMultibase=t,this.verificationMethod=a.verificationMethod||n,this.useStaticId=a.useStaticId||!1,this.signer=new Ty,this.prepareDataForSigning=r}async sign(t){const n=await this.prepareDataForSigning(t.document,t.proof),r=await this.signer.sign(te.from(n),this.privateKeyMultibase);return{proofValue:Ze.encodeMultibase(r)}}async verify(t,n,r){const a=Ze.encodePublicKey(r,"Ed25519"),o=te.from(n),i=te.from(t);return this.signer.verify(o,i,a)}getVerificationMethodId(){const t=this.verificationMethod?.publicKeyMultibase;if(!t)throw new Error("Verification method must have publicKeyMultibase");return`did:key:${t}`}}var vo={},Eo,Sc;function ga(){return Sc||(Sc=1,Eo=class Td{constructor(t,n=new Map,r=0){this.prefix=t,this._existing=n,this.counter=r}clone(){const{prefix:t,_existing:n,counter:r}=this;return new Td(t,new Map(n),r)}getId(t){const n=t&&this._existing.get(t);if(n)return n;const r=this.prefix+this.counter;return this.counter++,t&&this._existing.set(t,r),r}hasId(t){return this._existing.has(t)}getOldIds(){return[...this._existing.keys()]}}),Eo}var xo={},Ic;function Oy(){return Ic||(Ic=1,(function(e,t){if(e.setImmediate)return;var n=1,r={},a=!1,o=e.document,i;function s(I){typeof I!="function"&&(I=new Function(""+I));for(var b=new Array(arguments.length-1),w=0;w<b.length;w++)b[w]=arguments[w+1];var x={callback:I,args:b};return r[n]=x,i(n),n++}function c(I){delete r[I]}function l(I){var b=I.callback,w=I.args;switch(w.length){case 0:b();break;case 1:b(w[0]);break;case 2:b(w[0],w[1]);break;case 3:b(w[0],w[1],w[2]);break;default:b.apply(t,w);break}}function u(I){if(a)setTimeout(u,0,I);else{var b=r[I];if(b){a=!0;try{l(b)}finally{c(I),a=!1}}}}function d(){i=function(I){dn.nextTick(function(){u(I)})}}function h(){if(e.postMessage&&!e.importScripts){var I=!0,b=e.onmessage;return e.onmessage=function(){I=!1},e.postMessage("","*"),e.onmessage=b,I}}function f(){var I="setImmediate$"+Math.random()+"$",b=function(w){w.source===e&&typeof w.data=="string"&&w.data.indexOf(I)===0&&u(+w.data.slice(I.length))};e.addEventListener?e.addEventListener("message",b,!1):e.attachEvent("onmessage",b),i=function(w){e.postMessage(I+w,"*")}}function y(){var I=new MessageChannel;I.port1.onmessage=function(b){var w=b.data;u(w)},i=function(b){I.port2.postMessage(b)}}function g(){var I=o.documentElement;i=function(b){var w=o.createElement("script");w.onreadystatechange=function(){u(b),w.onreadystatechange=null,I.removeChild(w),w=null},I.appendChild(w)}}function S(){i=function(I){setTimeout(u,0,I)}}var B=Object.getPrototypeOf&&Object.getPrototypeOf(e);B=B&&B.setTimeout?B:e,{}.toString.call(e.process)==="[object process]"?d():h()?f():e.MessageChannel?y():o&&"onreadystatechange"in o.createElement("script")?g():S(),B.setImmediate=s,B.clearImmediate=c})(typeof self>"u"?typeof ka>"u"?xo:ka:self)),xo}var So,_c;function Ki(){if(_c)return So;_c=1,Oy();const e=self.crypto||self.msCrypto;return So=class{constructor(n){if(!(e&&e.subtle))throw new Error("crypto.subtle not found.");if(n==="sha256")this.algorithm={name:"SHA-256"};else if(n==="sha1")this.algorithm={name:"SHA-1"};else throw new Error(`Unsupported algorithm "${n}".`);this._content=""}update(n){this._content+=n}async digest(){const n=new TextEncoder().encode(this._content),r=new Uint8Array(await e.subtle.digest(this.algorithm,n));let a="";for(let o=0;o<r.length;++o)a+=r[o].toString(16).padStart(2,"0");return a}},So}var Io,Ac;function Bd(){return Ac||(Ac=1,Io=class{constructor(t){this.current=t.sort(),this.done=!1,this.dir=new Map;for(let n=0;n<t.length;++n)this.dir.set(t[n],!0)}hasNext(){return!this.done}next(){const{current:t,dir:n}=this,r=t.slice();let a=null,o=0;const i=t.length;for(let s=0;s<i;++s){const c=t[s],l=n.get(c);(a===null||c>a)&&(l&&s>0&&c>t[s-1]||!l&&s<i-1&&c>t[s+1])&&(a=c,o=s)}if(a===null)this.done=!0;else{const s=n.get(a)?o-1:o+1;t[o]=t[s],t[s]=a;for(const c of t)c>a&&n.set(c,!n.get(c))}return r}}),Io}var _o,Tc;function wa(){if(Tc)return _o;Tc=1;const t="http://www.w3.org/1999/02/22-rdf-syntax-ns#"+"langString",n="http://www.w3.org/2001/XMLSchema#string",r="NamedNode",a="BlankNode",o="Literal",i="DefaultGraph",s={};(()=>{const f="(?:<([^:]+:[^>]*)>)",g="A-Za-z-----------"+"_",S=g+"0-9---",I="(_:(?:["+g+"0-9])(?:(?:["+S+".])*(?:["+S+"]))?)",b='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',w="(?:\\^\\^"+f+")",_="(?:"+b+"(?:"+w+"|"+"(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))"+")?)",N="[ \\t]+",k="[ \\t]*",T="(?:"+f+"|"+I+")"+N,L=f+N,F="(?:"+f+"|"+I+"|"+_+")"+k,O="(?:\\.|(?:(?:"+f+"|"+I+")"+k+"\\.))";s.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,s.empty=new RegExp("^"+k+"$"),s.quad=new RegExp("^"+k+T+L+F+O+k+"$")})(),_o=class mi{static parse(y){const g=[],S={},B=y.split(s.eoln);let I=0;for(const b of B){if(I++,s.empty.test(b))continue;const w=b.match(s.quad);if(w===null)throw new Error("N-Quads parse error on line "+I+".");const x={subject:null,predicate:null,object:null,graph:null};if(w[1]!==void 0?x.subject={termType:r,value:w[1]}:x.subject={termType:a,value:w[2]},x.predicate={termType:r,value:w[3]},w[4]!==void 0?x.object={termType:r,value:w[4]}:w[5]!==void 0?x.object={termType:a,value:w[5]}:(x.object={termType:o,value:void 0,datatype:{termType:r}},w[7]!==void 0?x.object.datatype.value=w[7]:w[8]!==void 0?(x.object.datatype.value=t,x.object.language=w[8]):x.object.datatype.value=n,x.object.value=h(w[6])),w[9]!==void 0?x.graph={termType:r,value:w[9]}:w[10]!==void 0?x.graph={termType:a,value:w[10]}:x.graph={termType:i,value:""},!(x.graph.value in S))S[x.graph.value]=[x],g.push(x);else{let _=!0;const N=S[x.graph.value];for(const k of N)if(c(k,x)){_=!1;break}_&&(N.push(x),g.push(x))}}return g}static serialize(y){Array.isArray(y)||(y=mi.legacyDatasetToQuads(y));const g=[];for(const S of y)g.push(mi.serializeQuad(S));return g.sort().join("")}static serializeQuadComponents(y,g,S,B){let I="";return y.termType===r?I+=`<${y.value}>`:I+=`${y.value}`,I+=` <${g.value}> `,S.termType===r?I+=`<${S.value}>`:S.termType===a?I+=S.value:(I+=`"${u(S.value)}"`,S.datatype.value===t?S.language&&(I+=`@${S.language}`):S.datatype.value!==n&&(I+=`^^<${S.datatype.value}>`)),B.termType===r?I+=` <${B.value}>`:B.termType===a&&(I+=` ${B.value}`),I+=` .
`,I}static serializeQuad(y){return mi.serializeQuadComponents(y.subject,y.predicate,y.object,y.graph)}static legacyDatasetToQuads(y){const g=[],S={"blank node":a,IRI:r,literal:o};for(const B in y)y[B].forEach(b=>{const w={};for(const x in b){const _=b[x],N={termType:S[_.type],value:_.value};N.termType===o&&(N.datatype={termType:r},"datatype"in _&&(N.datatype.value=_.datatype),"language"in _?("datatype"in _||(N.datatype.value=t),N.language=_.language):"datatype"in _||(N.datatype.value=n)),w[x]=N}B==="@default"?w.graph={termType:i,value:""}:w.graph={termType:B.startsWith("_:")?a:r,value:B},g.push(w)});return g}};function c(f,y){return!(f.subject.termType===y.subject.termType&&f.object.termType===y.object.termType)||!(f.subject.value===y.subject.value&&f.predicate.value===y.predicate.value&&f.object.value===y.object.value)?!1:f.object.termType!==o?!0:f.object.datatype.termType===y.object.datatype.termType&&f.object.language===y.object.language&&f.object.datatype.value===y.object.datatype.value}const l=/["\\\n\r]/g;function u(f){return f.replace(l,function(y){switch(y){case'"':return'\\"';case"\\":return"\\\\";case`
`:return"\\n";case"\r":return"\\r"}})}const d=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function h(f){return f.replace(d,function(y,g,S,B){if(g)switch(g){case"t":return"	";case"b":return"\b";case"n":return`
`;case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(S)return String.fromCharCode(parseInt(S,16));if(B)throw new Error("Unsupported U escape")})}return _o}var Ao,Bc;function kd(){if(Bc)return Ao;Bc=1;const e=ga(),t=Ki(),n=Bd(),r=wa();Ao=class{constructor({createMessageDigest:i=()=>new t("sha256"),canonicalIdMap:s=new Map,maxDeepIterations:c=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new e("_:c14n",s),this.createMessageDigest=i,this.maxDeepIterations=c,this.quads=null,this.deepIterations=null}async main(i){this.deepIterations=new Map,this.quads=i;for(const f of i)this._addBlankNodeQuadInfo({quad:f,component:f.subject}),this._addBlankNodeQuadInfo({quad:f,component:f.object}),this._addBlankNodeQuadInfo({quad:f,component:f.graph});const s=new Map,c=[...this.blankNodeInfo.keys()];let l=0;for(const f of c)++l%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:f,hashToBlankNodes:s});const u=[...s.keys()].sort(),d=[];for(const f of u){const y=s.get(f);if(y.length>1){d.push(y);continue}const g=y[0];this.canonicalIssuer.getId(g)}for(const f of d){const y=[];for(const g of f){if(this.canonicalIssuer.hasId(g))continue;const S=new e("_:b");S.getId(g);const B=await this.hashNDegreeQuads(g,S);y.push(B)}y.sort(a);for(const g of y){const S=g.issuer.getOldIds();for(const B of S)this.canonicalIssuer.getId(B)}}const h=[];for(const f of this.quads){const y=r.serializeQuadComponents(this._componentWithCanonicalId(f.subject),f.predicate,this._componentWithCanonicalId(f.object),this._componentWithCanonicalId(f.graph));h.push(y)}return h.sort(),h.join("")}async hashFirstDegreeQuads(i){const s=[],c=this.blankNodeInfo.get(i),l=c.quads;for(const d of l){const h={subject:null,predicate:d.predicate,object:null,graph:null};h.subject=this.modifyFirstDegreeComponent(i,d.subject,"subject"),h.object=this.modifyFirstDegreeComponent(i,d.object,"object"),h.graph=this.modifyFirstDegreeComponent(i,d.graph,"graph"),s.push(r.serializeQuad(h))}s.sort();const u=this.createMessageDigest();for(const d of s)u.update(d);return c.hash=await u.digest(),c.hash}async hashRelatedBlankNode(i,s,c,l){let u;this.canonicalIssuer.hasId(i)?u=this.canonicalIssuer.getId(i):c.hasId(i)?u=c.getId(i):u=this.blankNodeInfo.get(i).hash;const d=this.createMessageDigest();return d.update(l),l!=="g"&&d.update(this.getRelatedPredicate(s)),d.update(u),d.digest()}async hashNDegreeQuads(i,s){const c=this.deepIterations.get(i)||0;if(c>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(i,c+1);const l=this.createMessageDigest(),u=await this.createHashToRelated(i,s),d=[...u.keys()].sort();for(const h of d){l.update(h);let f="",y;const g=new n(u.get(h));let S=0;for(;g.hasNext();){const B=g.next();++S%3===0&&await this._yield();let I=s.clone(),b="";const w=[];let x=!1;for(const _ of B)if(this.canonicalIssuer.hasId(_)?b+=this.canonicalIssuer.getId(_):(I.hasId(_)||w.push(_),b+=I.getId(_)),f.length!==0&&b>f){x=!0;break}if(!x){for(const _ of w){const N=await this.hashNDegreeQuads(_,I);if(b+=I.getId(_),b+=`<${N.hash}>`,I=N.issuer,f.length!==0&&b>f){x=!0;break}}x||(f.length===0||b<f)&&(f=b,y=I)}}l.update(f),s=y}return{hash:await l.digest(),issuer:s}}modifyFirstDegreeComponent(i,s){return s.termType!=="BlankNode"?s:{termType:"BlankNode",value:s.value===i?"_:a":"_:z"}}getRelatedPredicate(i){return`<${i.predicate.value}>`}async createHashToRelated(i,s){const c=new Map,l=this.blankNodeInfo.get(i).quads;let u=0;for(const d of l)++u%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:d,component:d.subject,position:"s",id:i,issuer:s,hashToRelated:c}),this._addRelatedBlankNodeHash({quad:d,component:d.object,position:"o",id:i,issuer:s,hashToRelated:c}),this._addRelatedBlankNodeHash({quad:d,component:d.graph,position:"g",id:i,issuer:s,hashToRelated:c})]);return c}async _hashAndTrackBlankNode({id:i,hashToBlankNodes:s}){const c=await this.hashFirstDegreeQuads(i),l=s.get(c);l?l.push(i):s.set(c,[i])}_addBlankNodeQuadInfo({quad:i,component:s}){if(s.termType!=="BlankNode")return;const c=s.value,l=this.blankNodeInfo.get(c);l?l.quads.add(i):this.blankNodeInfo.set(c,{quads:new Set([i]),hash:null})}async _addRelatedBlankNodeHash({quad:i,component:s,position:c,id:l,issuer:u,hashToRelated:d}){if(!(s.termType==="BlankNode"&&s.value!==l))return;const h=s.value,f=await this.hashRelatedBlankNode(h,i,u,c),y=d.get(f);y?y.push(h):d.set(f,[h])}_componentWithCanonicalId(i){return i.termType==="BlankNode"&&!i.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(i.value)}:i}async _yield(){return new Promise(i=>setImmediate(i))}};function a(o,i){return o.hash<i.hash?-1:o.hash>i.hash?1:0}return Ao}var To,kc;function Ry(){if(kc)return To;kc=1;const e=Ki(),t=kd();return To=class extends t{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new e("sha1")}modifyFirstDegreeComponent(r,a,o){return a.termType!=="BlankNode"?a:o==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:a.value===r?"_:a":"_:z"}}getRelatedPredicate(r){return r.predicate.value}async createHashToRelated(r,a){const o=new Map,i=this.blankNodeInfo.get(r).quads;let s=0;for(const c of i){let l,u;if(c.subject.termType==="BlankNode"&&c.subject.value!==r)u=c.subject.value,l="p";else if(c.object.termType==="BlankNode"&&c.object.value!==r)u=c.object.value,l="r";else continue;++s%100===0&&await this._yield();const d=await this.hashRelatedBlankNode(u,c,a,l),h=o.get(d);h?h.push(u):o.set(d,[u])}return o}},To}var Bo,Oc;function Od(){if(Oc)return Bo;Oc=1;const e=ga(),t=Ki(),n=Bd(),r=wa();Bo=class{constructor({createMessageDigest:i=()=>new t("sha256"),canonicalIdMap:s=new Map,maxDeepIterations:c=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new e("_:c14n",s),this.createMessageDigest=i,this.maxDeepIterations=c,this.quads=null,this.deepIterations=null}main(i){this.deepIterations=new Map,this.quads=i;for(const h of i)this._addBlankNodeQuadInfo({quad:h,component:h.subject}),this._addBlankNodeQuadInfo({quad:h,component:h.object}),this._addBlankNodeQuadInfo({quad:h,component:h.graph});const s=new Map,c=[...this.blankNodeInfo.keys()];for(const h of c)this._hashAndTrackBlankNode({id:h,hashToBlankNodes:s});const l=[...s.keys()].sort(),u=[];for(const h of l){const f=s.get(h);if(f.length>1){u.push(f);continue}const y=f[0];this.canonicalIssuer.getId(y)}for(const h of u){const f=[];for(const y of h){if(this.canonicalIssuer.hasId(y))continue;const g=new e("_:b");g.getId(y);const S=this.hashNDegreeQuads(y,g);f.push(S)}f.sort(a);for(const y of f){const g=y.issuer.getOldIds();for(const S of g)this.canonicalIssuer.getId(S)}}const d=[];for(const h of this.quads){const f=r.serializeQuadComponents(this._componentWithCanonicalId({component:h.subject}),h.predicate,this._componentWithCanonicalId({component:h.object}),this._componentWithCanonicalId({component:h.graph}));d.push(f)}return d.sort(),d.join("")}hashFirstDegreeQuads(i){const s=[],c=this.blankNodeInfo.get(i),l=c.quads;for(const d of l){const h={subject:null,predicate:d.predicate,object:null,graph:null};h.subject=this.modifyFirstDegreeComponent(i,d.subject,"subject"),h.object=this.modifyFirstDegreeComponent(i,d.object,"object"),h.graph=this.modifyFirstDegreeComponent(i,d.graph,"graph"),s.push(r.serializeQuad(h))}s.sort();const u=this.createMessageDigest();for(const d of s)u.update(d);return c.hash=u.digest(),c.hash}hashRelatedBlankNode(i,s,c,l){let u;this.canonicalIssuer.hasId(i)?u=this.canonicalIssuer.getId(i):c.hasId(i)?u=c.getId(i):u=this.blankNodeInfo.get(i).hash;const d=this.createMessageDigest();return d.update(l),l!=="g"&&d.update(this.getRelatedPredicate(s)),d.update(u),d.digest()}hashNDegreeQuads(i,s){const c=this.deepIterations.get(i)||0;if(c>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(i,c+1);const l=this.createMessageDigest(),u=this.createHashToRelated(i,s),d=[...u.keys()].sort();for(const h of d){l.update(h);let f="",y;const g=new n(u.get(h));for(;g.hasNext();){const S=g.next();let B=s.clone(),I="";const b=[];let w=!1;for(const x of S)if(this.canonicalIssuer.hasId(x)?I+=this.canonicalIssuer.getId(x):(B.hasId(x)||b.push(x),I+=B.getId(x)),f.length!==0&&I>f){w=!0;break}if(!w){for(const x of b){const _=this.hashNDegreeQuads(x,B);if(I+=B.getId(x),I+=`<${_.hash}>`,B=_.issuer,f.length!==0&&I>f){w=!0;break}}w||(f.length===0||I<f)&&(f=I,y=B)}}l.update(f),s=y}return{hash:l.digest(),issuer:s}}modifyFirstDegreeComponent(i,s){return s.termType!=="BlankNode"?s:{termType:"BlankNode",value:s.value===i?"_:a":"_:z"}}getRelatedPredicate(i){return`<${i.predicate.value}>`}createHashToRelated(i,s){const c=new Map,l=this.blankNodeInfo.get(i).quads;for(const u of l)this._addRelatedBlankNodeHash({quad:u,component:u.subject,position:"s",id:i,issuer:s,hashToRelated:c}),this._addRelatedBlankNodeHash({quad:u,component:u.object,position:"o",id:i,issuer:s,hashToRelated:c}),this._addRelatedBlankNodeHash({quad:u,component:u.graph,position:"g",id:i,issuer:s,hashToRelated:c});return c}_hashAndTrackBlankNode({id:i,hashToBlankNodes:s}){const c=this.hashFirstDegreeQuads(i),l=s.get(c);l?l.push(i):s.set(c,[i])}_addBlankNodeQuadInfo({quad:i,component:s}){if(s.termType!=="BlankNode")return;const c=s.value,l=this.blankNodeInfo.get(c);l?l.quads.add(i):this.blankNodeInfo.set(c,{quads:new Set([i]),hash:null})}_addRelatedBlankNodeHash({quad:i,component:s,position:c,id:l,issuer:u,hashToRelated:d}){if(!(s.termType==="BlankNode"&&s.value!==l))return;const h=s.value,f=this.hashRelatedBlankNode(h,i,u,c),y=d.get(f);y?y.push(h):d.set(f,[h])}_componentWithCanonicalId({component:i}){return i.termType==="BlankNode"&&!i.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(i.value)}:i}};function a(o,i){return o.hash<i.hash?-1:o.hash>i.hash?1:0}return Bo}var ko,Rc;function Py(){if(Rc)return ko;Rc=1;const e=Ki(),t=Od();return ko=class extends t{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new e("sha1")}modifyFirstDegreeComponent(r,a,o){return a.termType!=="BlankNode"?a:o==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:a.value===r?"_:a":"_:z"}}getRelatedPredicate(r){return r.predicate.value}createHashToRelated(r,a){const o=new Map,i=this.blankNodeInfo.get(r).quads;for(const s of i){let c,l;if(s.subject.termType==="BlankNode"&&s.subject.value!==r)l=s.subject.value,c="p";else if(s.object.termType==="BlankNode"&&s.object.value!==r)l=s.object.value,c="r";else continue;const u=this.hashRelatedBlankNode(l,s,a,c),d=o.get(u);d?d.push(l):o.set(u,[l])}return o}},ko}const Uy=Vd(Ad);var Pc;function Hy(){return Pc||(Pc=1,(function(e){const t=kd(),n=Ry(),r=Od(),a=Py();let o;try{o=Uy}catch{}function i(s){return Array.isArray(s)?s:e.NQuads.legacyDatasetToQuads(s)}e.NQuads=wa(),e.IdentifierIssuer=ga(),e._rdfCanonizeNative=function(s){return s&&(o=s),o},e.canonize=async function(s,c){const l=i(s);if(c.useNative){if(!o)throw new Error("rdf-canonize-native not available");if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((u,d)=>o.canonize(l,c,(h,f)=>h?d(h):u(f)))}if(c.algorithm==="URDNA2015")return new t(c).main(l);if(c.algorithm==="URGNA2012"){if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new n(c).main(l)}throw"algorithm"in c?new Error("Invalid RDF Dataset Canonicalization algorithm: "+c.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")},e._canonizeSync=function(s,c){const l=i(s);if(c.useNative){if(!o)throw new Error("rdf-canonize-native not available");if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return o.canonizeSync(l,c)}if(c.algorithm==="URDNA2015")return new r(c).main(l);if(c.algorithm==="URGNA2012"){if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new a(c).main(l)}throw"algorithm"in c?new Error("Invalid RDF Dataset Canonicalization algorithm: "+c.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}})(vo)),vo}var Oo,Uc;function ma(){return Uc||(Uc=1,Oo=Hy()),Oo}var Ro,Hc;function ot(){if(Hc)return Ro;Hc=1;const e={};return Ro=e,e.isArray=Array.isArray,e.isBoolean=t=>typeof t=="boolean"||Object.prototype.toString.call(t)==="[object Boolean]",e.isDouble=t=>e.isNumber(t)&&(String(t).indexOf(".")!==-1||Math.abs(t)>=1e21),e.isEmptyObject=t=>e.isObject(t)&&Object.keys(t).length===0,e.isNumber=t=>typeof t=="number"||Object.prototype.toString.call(t)==="[object Number]",e.isNumeric=t=>!isNaN(parseFloat(t))&&isFinite(t),e.isObject=t=>Object.prototype.toString.call(t)==="[object Object]",e.isString=t=>typeof t=="string"||Object.prototype.toString.call(t)==="[object String]",e.isUndefined=t=>typeof t>"u",Ro}var Po,Lc;function Gt(){if(Lc)return Po;Lc=1;const e=ot(),t={};return Po=t,t.isSubject=n=>e.isObject(n)&&!("@value"in n||"@set"in n||"@list"in n)?Object.keys(n).length>1||!("@id"in n):!1,t.isSubjectReference=n=>e.isObject(n)&&Object.keys(n).length===1&&"@id"in n,t.isValue=n=>e.isObject(n)&&"@value"in n,t.isList=n=>e.isObject(n)&&"@list"in n,t.isGraph=n=>e.isObject(n)&&"@graph"in n&&Object.keys(n).filter(r=>r!=="@id"&&r!=="@index").length===1,t.isSimpleGraph=n=>t.isGraph(n)&&!("@id"in n),t.isBlankNode=n=>{if(e.isObject(n)){if("@id"in n){const r=n["@id"];return!e.isString(r)||r.indexOf("_:")===0}return Object.keys(n).length===0||!("@value"in n||"@set"in n||"@list"in n)}return!1},Po}var Uo,Dc;function lt(){return Dc||(Dc=1,Uo=class extends Error{constructor(t="An unspecified JSON-LD error occurred.",n="jsonld.Error",r={}){super(t),this.name=n,this.message=t,this.details=r}}),Uo}var Ho,Nc;function ft(){if(Nc)return Ho;Nc=1;const e=Gt(),t=ot(),n=ma().IdentifierIssuer,r=lt(),a=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,o=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,i=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,s=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,c=/^@[a-zA-Z]+$/,l={headers:{accept:"application/ld+json, application/json"}},u={};Ho=u,u.IdentifierIssuer=n,u.REGEX_BCP47=a,u.REGEX_KEYWORD=c,u.clone=function(h){if(h&&typeof h=="object"){let f;if(t.isArray(h)){f=[];for(let y=0;y<h.length;++y)f[y]=u.clone(h[y])}else if(h instanceof Map){f=new Map;for(const[y,g]of h)f.set(y,u.clone(g))}else if(h instanceof Set){f=new Set;for(const y of h)f.add(u.clone(y))}else if(t.isObject(h)){f={};for(const y in h)f[y]=u.clone(h[y])}else f=h.toString();return f}return h},u.asArray=function(h){return Array.isArray(h)?h:[h]},u.buildHeaders=(h={})=>{if(Object.keys(h).some(y=>y.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+l.headers.accept+'" is supported.');return Object.assign({Accept:l.headers.accept},h)},u.parseLinkHeader=h=>{const f={},y=h.match(o);for(let g=0;g<y.length;++g){let S=y[g].match(i);if(!S)continue;const B={target:S[1]},I=S[2];for(;S=s.exec(I);)B[S[1]]=S[2]===void 0?S[3]:S[2];const b=B.rel||"";Array.isArray(f[b])?f[b].push(B):f.hasOwnProperty(b)?f[b]=[f[b],B]:f[b]=B}return f},u.validateTypeValue=(h,f)=>{if(!t.isString(h)&&!(t.isArray(h)&&h.every(y=>t.isString(y)))){if(f&&t.isObject(h))switch(Object.keys(h).length){case 0:return;case 1:if("@default"in h&&u.asArray(h["@default"]).every(y=>t.isString(y)))return}throw new r('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:h})}},u.hasProperty=(h,f)=>{if(h.hasOwnProperty(f)){const y=h[f];return!t.isArray(y)||y.length>0}return!1},u.hasValue=(h,f,y)=>{if(u.hasProperty(h,f)){let g=h[f];const S=e.isList(g);if(t.isArray(g)||S){S&&(g=g["@list"]);for(let B=0;B<g.length;++B)if(u.compareValues(y,g[B]))return!0}else if(!t.isArray(y))return u.compareValues(y,g)}return!1},u.addValue=(h,f,y,g)=>{if(g=g||{},"propertyIsArray"in g||(g.propertyIsArray=!1),"valueIsArray"in g||(g.valueIsArray=!1),"allowDuplicate"in g||(g.allowDuplicate=!0),"prependValue"in g||(g.prependValue=!1),g.valueIsArray)h[f]=y;else if(t.isArray(y)){y.length===0&&g.propertyIsArray&&!h.hasOwnProperty(f)&&(h[f]=[]),g.prependValue&&(y=y.concat(h[f]),h[f]=[]);for(let S=0;S<y.length;++S)u.addValue(h,f,y[S],g)}else if(h.hasOwnProperty(f)){const S=!g.allowDuplicate&&u.hasValue(h,f,y);!t.isArray(h[f])&&(!S||g.propertyIsArray)&&(h[f]=[h[f]]),S||(g.prependValue?h[f].unshift(y):h[f].push(y))}else h[f]=g.propertyIsArray?[y]:y},u.getValues=(h,f)=>[].concat(h[f]||[]),u.removeProperty=(h,f)=>{delete h[f]},u.removeValue=(h,f,y,g)=>{g=g||{},"propertyIsArray"in g||(g.propertyIsArray=!1);const S=u.getValues(h,f).filter(B=>!u.compareValues(B,y));S.length===0?u.removeProperty(h,f):S.length===1&&!g.propertyIsArray?h[f]=S[0]:h[f]=S},u.relabelBlankNodes=(h,f)=>{f=f||{};const y=f.issuer||new n("_:b");return d(y,h)},u.compareValues=(h,f)=>h===f||e.isValue(h)&&e.isValue(f)&&h["@value"]===f["@value"]&&h["@type"]===f["@type"]&&h["@language"]===f["@language"]&&h["@index"]===f["@index"]?!0:t.isObject(h)&&"@id"in h&&t.isObject(f)&&"@id"in f?h["@id"]===f["@id"]:!1,u.compareShortestLeast=(h,f)=>h.length<f.length?-1:f.length<h.length?1:h===f?0:h<f?-1:1;function d(h,f){if(t.isArray(f))for(let y=0;y<f.length;++y)f[y]=d(h,f[y]);else if(e.isList(f))f["@list"]=d(h,f["@list"]);else if(t.isObject(f)){e.isBlankNode(f)&&(f["@id"]=h.getId(f["@id"]));const y=Object.keys(f).sort();for(let g=0;g<y.length;++g){const S=y[g];S!=="@id"&&(f[S]=d(h,f[S]))}}return f}return Ho}var Lo,Fc;function ba(){if(Fc)return Lo;Fc=1;const e="http://www.w3.org/1999/02/22-rdf-syntax-ns#",t="http://www.w3.org/2001/XMLSchema#";return Lo={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:e,RDF_LIST:e+"List",RDF_FIRST:e+"first",RDF_REST:e+"rest",RDF_NIL:e+"nil",RDF_TYPE:e+"type",RDF_PLAIN_LITERAL:e+"PlainLiteral",RDF_XML_LITERAL:e+"XMLLiteral",RDF_JSON_LITERAL:e+"JSON",RDF_OBJECT:e+"object",RDF_LANGSTRING:e+"langString",XSD:t,XSD_BOOLEAN:t+"boolean",XSD_DOUBLE:t+"double",XSD_INTEGER:t+"integer",XSD_STRING:t+"string"},Lo}var Do,Mc;function Rd(){return Mc||(Mc=1,Do=class{constructor(){this._requests={}}wrapLoader(t){const n=this;return n._loader=t,function(){return n.add.apply(n,arguments)}}async add(t){let n=this._requests[t];if(n)return Promise.resolve(n);n=this._requests[t]=this._loader(t);try{return await n}finally{delete this._requests[t]}}}),Do}var No,Cc;function Sr(){if(Cc)return No;Cc=1;const e=ot(),t={};No=t,t.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},t.parse=(r,a)=>{const o={},i=t.parsers[a||"full"],s=i.regex.exec(r);let c=i.keys.length;for(;c--;)o[i.keys[c]]=s[c]===void 0?null:s[c];return(o.scheme==="https"&&o.port==="443"||o.scheme==="http"&&o.port==="80")&&(o.href=o.href.replace(":"+o.port,""),o.authority=o.authority.replace(":"+o.port,""),o.port=null),o.normalizedPath=t.removeDotSegments(o.path),o},t.prependBase=(r,a)=>{if(r===null||t.isAbsolute(a))return a;(!r||e.isString(r))&&(r=t.parse(r||""));const o=t.parse(a),i={protocol:r.protocol||""};if(o.authority!==null)i.authority=o.authority,i.path=o.path,i.query=o.query;else if(i.authority=r.authority,o.path==="")i.path=r.path,o.query!==null?i.query=o.query:i.query=r.query;else{if(o.path.indexOf("/")===0)i.path=o.path;else{let c=r.path;c=c.substr(0,c.lastIndexOf("/")+1),(c.length>0||r.authority)&&c.substr(-1)!=="/"&&(c+="/"),c+=o.path,i.path=c}i.query=o.query}o.path!==""&&(i.path=t.removeDotSegments(i.path));let s=i.protocol;return i.authority!==null&&(s+="//"+i.authority),s+=i.path,i.query!==null&&(s+="?"+i.query),o.fragment!==null&&(s+="#"+o.fragment),s===""&&(s="./"),s},t.removeBase=(r,a)=>{if(r===null)return a;(!r||e.isString(r))&&(r=t.parse(r||""));let o="";if(r.href!==""?o+=(r.protocol||"")+"//"+(r.authority||""):a.indexOf("//")&&(o+="//"),a.indexOf(o)!==0)return a;const i=t.parse(a.substr(o.length)),s=r.normalizedPath.split("/"),c=i.normalizedPath.split("/"),l=i.fragment||i.query?0:1;for(;s.length>0&&c.length>l&&s[0]===c[0];)s.shift(),c.shift();let u="";if(s.length>0){s.pop();for(let d=0;d<s.length;++d)u+="../"}return u+=c.join("/"),i.query!==null&&(u+="?"+i.query),i.fragment!==null&&(u+="#"+i.fragment),u===""&&(u="./"),u},t.removeDotSegments=r=>{if(r.length===0)return"";const a=r.split("/"),o=[];for(;a.length>0;){const i=a.shift(),s=a.length===0;if(i==="."){s&&o.push("");continue}if(i===".."){o.pop(),s&&o.push("");continue}o.push(i)}return r[0]==="/"&&o.length>0&&o[0]!==""&&o.unshift(""),o.length===1&&o[0]===""?"/":o.join("/")};const n=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;return t.isAbsolute=r=>e.isString(r)&&n.test(r),t.isRelative=r=>e.isString(r),No}var Fo,jc;function Ly(){if(jc)return Fo;jc=1;const{parseLinkHeader:e,buildHeaders:t}=ft(),{LINK_HEADER_CONTEXT:n}=ba(),r=lt(),a=Rd(),{prependBase:o}=Sr(),i=/(^|(\r\n))link:/i;Fo=({secure:c,headers:l={},xhr:u}={headers:{}})=>{return l=t(l),new a().wrapLoader(h);async function h(f){if(f.indexOf("http:")!==0&&f.indexOf("https:")!==0)throw new r('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:f});if(c&&f.indexOf("https")!==0)throw new r(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:f});let y;try{y=await s(u,f,l)}catch(b){throw new r("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:f,cause:b})}if(y.status>=400)throw new r("URL could not be dereferenced: "+y.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:f,httpStatusCode:y.status});let g={contextUrl:null,documentUrl:f,document:y.response},S=null;const B=y.getResponseHeader("Content-Type");let I;if(i.test(y.getAllResponseHeaders())&&(I=y.getResponseHeader("Link")),I&&B!=="application/ld+json"){const b=e(I),w=b[n];if(Array.isArray(w))throw new r("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:f});w&&(g.contextUrl=w.target),S=b.alternate,S&&S.type=="application/ld+json"&&!(B||"").match(/^application\/(\w*\+)?json$/)&&(g=await h(o(f,S.target)))}return g}};function s(c,l,u){c=c||XMLHttpRequest;const d=new c;return new Promise((h,f)=>{d.onload=()=>h(d),d.onerror=y=>f(y),d.open("GET",l,!0);for(const y in u)d.setRequestHeader(y,u[y]);d.send()})}return Fo}var Mo,qc;function Dy(){if(qc)return Mo;qc=1;const e=Ly(),t={};return Mo=t,t.setupDocumentLoaders=function(n){typeof XMLHttpRequest<"u"&&(n.documentLoaders.xhr=e,n.useDocumentLoader("xhr"))},t.setupGlobals=function(n){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:n.JsonLdProcessor})},Mo}var Co,Kc;function Ny(){return Kc||(Kc=1,Co=function(e){e.prototype[Symbol.iterator]=function*(){for(let t=this.head;t;t=t.next)yield t.value}}),Co}var jo,Vc;function Fy(){if(Vc)return jo;Vc=1,jo=e,e.Node=a,e.create=e;function e(o){var i=this;if(i instanceof e||(i=new e),i.tail=null,i.head=null,i.length=0,o&&typeof o.forEach=="function")o.forEach(function(l){i.push(l)});else if(arguments.length>0)for(var s=0,c=arguments.length;s<c;s++)i.push(arguments[s]);return i}e.prototype.removeNode=function(o){if(o.list!==this)throw new Error("removing node which does not belong to this list");var i=o.next,s=o.prev;return i&&(i.prev=s),s&&(s.next=i),o===this.head&&(this.head=i),o===this.tail&&(this.tail=s),o.list.length--,o.next=null,o.prev=null,o.list=null,i},e.prototype.unshiftNode=function(o){if(o!==this.head){o.list&&o.list.removeNode(o);var i=this.head;o.list=this,o.next=i,i&&(i.prev=o),this.head=o,this.tail||(this.tail=o),this.length++}},e.prototype.pushNode=function(o){if(o!==this.tail){o.list&&o.list.removeNode(o);var i=this.tail;o.list=this,o.prev=i,i&&(i.next=o),this.tail=o,this.head||(this.head=o),this.length++}},e.prototype.push=function(){for(var o=0,i=arguments.length;o<i;o++)n(this,arguments[o]);return this.length},e.prototype.unshift=function(){for(var o=0,i=arguments.length;o<i;o++)r(this,arguments[o]);return this.length},e.prototype.pop=function(){if(this.tail){var o=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,o}},e.prototype.shift=function(){if(this.head){var o=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,o}},e.prototype.forEach=function(o,i){i=i||this;for(var s=this.head,c=0;s!==null;c++)o.call(i,s.value,c,this),s=s.next},e.prototype.forEachReverse=function(o,i){i=i||this;for(var s=this.tail,c=this.length-1;s!==null;c--)o.call(i,s.value,c,this),s=s.prev},e.prototype.get=function(o){for(var i=0,s=this.head;s!==null&&i<o;i++)s=s.next;if(i===o&&s!==null)return s.value},e.prototype.getReverse=function(o){for(var i=0,s=this.tail;s!==null&&i<o;i++)s=s.prev;if(i===o&&s!==null)return s.value},e.prototype.map=function(o,i){i=i||this;for(var s=new e,c=this.head;c!==null;)s.push(o.call(i,c.value,this)),c=c.next;return s},e.prototype.mapReverse=function(o,i){i=i||this;for(var s=new e,c=this.tail;c!==null;)s.push(o.call(i,c.value,this)),c=c.prev;return s},e.prototype.reduce=function(o,i){var s,c=this.head;if(arguments.length>1)s=i;else if(this.head)c=this.head.next,s=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var l=0;c!==null;l++)s=o(s,c.value,l),c=c.next;return s},e.prototype.reduceReverse=function(o,i){var s,c=this.tail;if(arguments.length>1)s=i;else if(this.tail)c=this.tail.prev,s=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var l=this.length-1;c!==null;l--)s=o(s,c.value,l),c=c.prev;return s},e.prototype.toArray=function(){for(var o=new Array(this.length),i=0,s=this.head;s!==null;i++)o[i]=s.value,s=s.next;return o},e.prototype.toArrayReverse=function(){for(var o=new Array(this.length),i=0,s=this.tail;s!==null;i++)o[i]=s.value,s=s.prev;return o},e.prototype.slice=function(o,i){i=i||this.length,i<0&&(i+=this.length),o=o||0,o<0&&(o+=this.length);var s=new e;if(i<o||i<0)return s;o<0&&(o=0),i>this.length&&(i=this.length);for(var c=0,l=this.head;l!==null&&c<o;c++)l=l.next;for(;l!==null&&c<i;c++,l=l.next)s.push(l.value);return s},e.prototype.sliceReverse=function(o,i){i=i||this.length,i<0&&(i+=this.length),o=o||0,o<0&&(o+=this.length);var s=new e;if(i<o||i<0)return s;o<0&&(o=0),i>this.length&&(i=this.length);for(var c=this.length,l=this.tail;l!==null&&c>i;c--)l=l.prev;for(;l!==null&&c>o;c--,l=l.prev)s.push(l.value);return s},e.prototype.splice=function(o,i,...s){o>this.length&&(o=this.length-1),o<0&&(o=this.length+o);for(var c=0,l=this.head;l!==null&&c<o;c++)l=l.next;for(var u=[],c=0;l&&c<i;c++)u.push(l.value),l=this.removeNode(l);l===null&&(l=this.tail),l!==this.head&&l!==this.tail&&(l=l.prev);for(var c=0;c<s.length;c++)l=t(this,l,s[c]);return u},e.prototype.reverse=function(){for(var o=this.head,i=this.tail,s=o;s!==null;s=s.prev){var c=s.prev;s.prev=s.next,s.next=c}return this.head=i,this.tail=o,this};function t(o,i,s){var c=i===o.head?new a(s,null,i,o):new a(s,i,i.next,o);return c.next===null&&(o.tail=c),c.prev===null&&(o.head=c),o.length++,c}function n(o,i){o.tail=new a(i,o.tail,null,o),o.head||(o.head=o.tail),o.length++}function r(o,i){o.head=new a(i,null,o.head,o),o.tail||(o.tail=o.head),o.length++}function a(o,i,s,c){if(!(this instanceof a))return new a(o,i,s,c);this.list=c,this.value=o,i?(i.next=this,this.prev=i):this.prev=null,s?(s.prev=this,this.next=s):this.next=null}try{Ny()(e)}catch{}return jo}var qo,Gc;function Pd(){if(Gc)return qo;Gc=1;const e=Fy(),t=Symbol("max"),n=Symbol("length"),r=Symbol("lengthCalculator"),a=Symbol("allowStale"),o=Symbol("maxAge"),i=Symbol("dispose"),s=Symbol("noDisposeOnSet"),c=Symbol("lruList"),l=Symbol("cache"),u=Symbol("updateAgeOnGet"),d=()=>1;class h{constructor(w){if(typeof w=="number"&&(w={max:w}),w||(w={}),w.max&&(typeof w.max!="number"||w.max<0))throw new TypeError("max must be a non-negative number");this[t]=w.max||1/0;const x=w.length||d;if(this[r]=typeof x!="function"?d:x,this[a]=w.stale||!1,w.maxAge&&typeof w.maxAge!="number")throw new TypeError("maxAge must be a number");this[o]=w.maxAge||0,this[i]=w.dispose,this[s]=w.noDisposeOnSet||!1,this[u]=w.updateAgeOnGet||!1,this.reset()}set max(w){if(typeof w!="number"||w<0)throw new TypeError("max must be a non-negative number");this[t]=w||1/0,g(this)}get max(){return this[t]}set allowStale(w){this[a]=!!w}get allowStale(){return this[a]}set maxAge(w){if(typeof w!="number")throw new TypeError("maxAge must be a non-negative number");this[o]=w,g(this)}get maxAge(){return this[o]}set lengthCalculator(w){typeof w!="function"&&(w=d),w!==this[r]&&(this[r]=w,this[n]=0,this[c].forEach(x=>{x.length=this[r](x.value,x.key),this[n]+=x.length})),g(this)}get lengthCalculator(){return this[r]}get length(){return this[n]}get itemCount(){return this[c].length}rforEach(w,x){x=x||this;for(let _=this[c].tail;_!==null;){const N=_.prev;I(this,w,_,x),_=N}}forEach(w,x){x=x||this;for(let _=this[c].head;_!==null;){const N=_.next;I(this,w,_,x),_=N}}keys(){return this[c].toArray().map(w=>w.key)}values(){return this[c].toArray().map(w=>w.value)}reset(){this[i]&&this[c]&&this[c].length&&this[c].forEach(w=>this[i](w.key,w.value)),this[l]=new Map,this[c]=new e,this[n]=0}dump(){return this[c].map(w=>y(this,w)?!1:{k:w.key,v:w.value,e:w.now+(w.maxAge||0)}).toArray().filter(w=>w)}dumpLru(){return this[c]}set(w,x,_){if(_=_||this[o],_&&typeof _!="number")throw new TypeError("maxAge must be a number");const N=_?Date.now():0,k=this[r](x,w);if(this[l].has(w)){if(k>this[t])return S(this,this[l].get(w)),!1;const F=this[l].get(w).value;return this[i]&&(this[s]||this[i](w,F.value)),F.now=N,F.maxAge=_,F.value=x,this[n]+=k-F.length,F.length=k,this.get(w),g(this),!0}const T=new B(w,x,k,N,_);return T.length>this[t]?(this[i]&&this[i](w,x),!1):(this[n]+=T.length,this[c].unshift(T),this[l].set(w,this[c].head),g(this),!0)}has(w){if(!this[l].has(w))return!1;const x=this[l].get(w).value;return!y(this,x)}get(w){return f(this,w,!0)}peek(w){return f(this,w,!1)}pop(){const w=this[c].tail;return w?(S(this,w),w.value):null}del(w){S(this,this[l].get(w))}load(w){this.reset();const x=Date.now();for(let _=w.length-1;_>=0;_--){const N=w[_],k=N.e||0;if(k===0)this.set(N.k,N.v);else{const T=k-x;T>0&&this.set(N.k,N.v,T)}}}prune(){this[l].forEach((w,x)=>f(this,x,!1))}}const f=(b,w,x)=>{const _=b[l].get(w);if(_){const N=_.value;if(y(b,N)){if(S(b,_),!b[a])return}else x&&(b[u]&&(_.value.now=Date.now()),b[c].unshiftNode(_));return N.value}},y=(b,w)=>{if(!w||!w.maxAge&&!b[o])return!1;const x=Date.now()-w.now;return w.maxAge?x>w.maxAge:b[o]&&x>b[o]},g=b=>{if(b[n]>b[t])for(let w=b[c].tail;b[n]>b[t]&&w!==null;){const x=w.prev;S(b,w),w=x}},S=(b,w)=>{if(w){const x=w.value;b[i]&&b[i](x.key,x.value),b[n]-=x.length,b[l].delete(x.key),b[c].removeNode(w)}};class B{constructor(w,x,_,N,k){this.key=w,this.value=x,this.length=_,this.now=N,this.maxAge=k||0}}const I=(b,w,x,_)=>{let N=x.value;y(b,N)&&(S(b,x),b[a]||(N=void 0)),N&&w.call(_,N.value,N.key,b)};return qo=h,qo}var Ko,Wc;function My(){if(Wc)return Ko;Wc=1;const e=Pd(),t=10;return Ko=class{constructor({document:r}){this.document=r,this.cache=new e({max:t})}getProcessed(r){return this.cache.get(r)}setProcessed(r,a){this.cache.set(r,a)}},Ko}var Vo,$c;function Cy(){if($c)return Vo;$c=1;const{isArray:e,isObject:t,isString:n}=ot(),{asArray:r}=ft(),{prependBase:a}=Sr(),o=lt(),i=My(),s=10;Vo=class{constructor({sharedCache:d}){this.perOpCache=new Map,this.sharedCache=d}async resolve({activeCtx:d,context:h,documentLoader:f,base:y,cycles:g=new Set}){h&&t(h)&&h["@context"]&&(h=h["@context"]),h=r(h);const S=[];for(const B of h){if(n(B)){let w=this._get(B);w||(w=await this._resolveRemoteContext({activeCtx:d,url:B,documentLoader:f,base:y,cycles:g})),e(w)?S.push(...w):S.push(w);continue}if(B===null){S.push(new i({document:null}));continue}t(B)||c(h);const I=JSON.stringify(B);let b=this._get(I);b||(b=new i({document:B}),this._cacheResolvedContext({key:I,resolved:b,tag:"static"})),S.push(b)}return S}_get(d){let h=this.perOpCache.get(d);if(!h){const f=this.sharedCache.get(d);f&&(h=f.get("static"),h&&this.perOpCache.set(d,h))}return h}_cacheResolvedContext({key:d,resolved:h,tag:f}){if(this.perOpCache.set(d,h),f!==void 0){let y=this.sharedCache.get(d);y||(y=new Map,this.sharedCache.set(d,y)),y.set(f,h)}return h}async _resolveRemoteContext({activeCtx:d,url:h,documentLoader:f,base:y,cycles:g}){h=a(y,h);const{context:S,remoteDoc:B}=await this._fetchContext({activeCtx:d,url:h,documentLoader:f,cycles:g});y=B.documentUrl||h,l({context:S,base:y});const I=await this.resolve({activeCtx:d,context:S,documentLoader:f,base:y,cycles:g});return this._cacheResolvedContext({key:h,resolved:I,tag:B.tag}),I}async _fetchContext({activeCtx:d,url:h,documentLoader:f,cycles:y}){if(y.size>s)throw new o("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:d.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:s});if(y.has(h))throw new o("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:d.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:h});y.add(h);let g,S;try{S=await f(h),g=S.document||null,n(g)&&(g=JSON.parse(g))}catch(B){throw new o(`Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context. URL: "${h}".`,"jsonld.InvalidUrl",{code:"loading remote context failed",url:h,cause:B})}if(!t(g))throw new o(`Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object. URL: "${h}".`,"jsonld.InvalidUrl",{code:"invalid remote context",url:h});return"@context"in g?g={"@context":g["@context"]}:g={"@context":{}},S.contextUrl&&(e(g["@context"])||(g["@context"]=[g["@context"]]),g["@context"].push(S.contextUrl)),{context:g,remoteDoc:S}}};function c(u){throw new o("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:u})}function l({context:u,base:d}){if(!u)return;const h=u["@context"];if(n(h)){u["@context"]=a(d,h);return}if(e(h)){for(let f=0;f<h.length;++f){const y=h[f];if(n(y)){h[f]=a(d,y);continue}t(y)&&l({context:{"@context":y},base:d})}return}if(t(h))for(const f in h)l({context:h[f],base:d})}return Vo}var Go,Xc;function jy(){return Xc||(Xc=1,Go=ma().NQuads),Go}var Wo,zc;function $n(){if(zc)return Wo;zc=1;const e=lt(),{isArray:t}=ot(),{asArray:n}=ft(),r={};Wo=r,r.defaultEventHandler=null,r.setupEventHandler=({options:i={}})=>{const s=[].concat(i.safe?r.safeEventHandler:[],i.eventHandler?n(i.eventHandler):[],r.defaultEventHandler?r.defaultEventHandler:[]);return s.length===0?null:s},r.handleEvent=({event:i,options:s})=>{a({event:i,handlers:s.eventHandler})};function a({event:i,handlers:s}){let c=!0;for(let l=0;c&&l<s.length;++l){c=!1;const u=s[l];if(t(u))c=a({event:i,handlers:u});else if(typeof u=="function")u({event:i,next:()=>{c=!0}});else if(typeof u=="object")i.code in u?u[i.code]({event:i,next:()=>{c=!0}}):c=!0;else throw new e("Invalid event handler.","jsonld.InvalidEventHandler",{event:i})}return c}const o=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);return r.safeEventHandler=function({event:s,next:c}){if(s.level==="warning"&&o.has(s.code))throw new e("Safe mode validation error.","jsonld.ValidationError",{event:s});c()},r.logEventHandler=function({event:s,next:c}){console.log(`EVENT: ${s.message}`,{event:s}),c()},r.logWarningEventHandler=function({event:s,next:c}){s.level==="warning"&&console.warn(`WARNING: ${s.message}`,{event:s}),c()},r.unhandledEventHandler=function({event:s}){throw new e("No handler for event.","jsonld.UnhandledEvent",{event:s})},r.setDefaultEventHandler=function({eventHandler:i}={}){r.defaultEventHandler=i?n(i):null},Wo}var $o,Jc;function Xr(){if(Jc)return $o;Jc=1;const e=ft(),t=lt(),{isArray:n,isObject:r,isString:a,isUndefined:o}=ot(),{isAbsolute:i,isRelative:s,prependBase:c}=Sr(),{handleEvent:l}=$n(),{REGEX_BCP47:u,REGEX_KEYWORD:d,asArray:h,compareShortestLeast:f}=ft(),y=new Map,g=1e4,S={};$o=S,S.process=async({activeCtx:b,localCtx:w,options:x,propagate:_=!0,overrideProtected:N=!1,cycles:k=new Set})=>{if(r(w)&&"@context"in w&&n(w["@context"])&&(w=w["@context"]),h(w).length===0)return b;const L=[],F=[({event:K,next:U})=>{L.push(K),U()}];x.eventHandler&&F.push(x.eventHandler);const O=x;x={...x,eventHandler:F};const R=await x.contextResolver.resolve({activeCtx:b,context:w,documentLoader:x.documentLoader,base:x.base});r(R[0].document)&&typeof R[0].document["@propagate"]=="boolean"&&(_=R[0].document["@propagate"]);let P=b;!_&&!P.previousContext&&(P=P.clone(),P.previousContext=b);for(const K of R){let{document:U}=K;if(b=P,U===null){if(!N&&Object.keys(b.protected).length!==0)throw new t("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});P=b=S.getInitialContext(x).clone();continue}const V=K.getProcessed(b);if(V){if(O.eventHandler)for(const H of V.events)l({event:H,options:O});P=b=V.context;continue}if(r(U)&&"@context"in U&&(U=U["@context"]),!r(U))throw new t("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:U});P=P.clone();const C=new Map;if("@version"in U){if(U["@version"]!==1.1)throw new t("Unsupported JSON-LD version: "+U["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:U});if(b.processingMode&&b.processingMode==="json-ld-1.0")throw new t("@version: "+U["@version"]+" not compatible with "+b.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:U});P.processingMode="json-ld-1.1",P["@version"]=U["@version"],C.set("@version",!0)}if(P.processingMode=P.processingMode||b.processingMode,"@base"in U){let H=U["@base"];if(!(H===null||i(H)))if(s(H))H=c(P["@base"],H);else throw new t('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:U});P["@base"]=H,C.set("@base",!0)}if("@vocab"in U){const H=U["@vocab"];if(H===null)delete P["@vocab"];else if(a(H)){if(!i(H)&&S.processingMode(P,1))throw new t('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:U});{const D=B(P,H,{vocab:!0,base:!0},void 0,void 0,x);i(D)||x.eventHandler&&l({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:D}},options:x}),P["@vocab"]=D}}else throw new t('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:U});C.set("@vocab",!0)}if("@language"in U){const H=U["@language"];if(H===null)delete P["@language"];else if(a(H))H.match(u)||x.eventHandler&&l({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:H}},options:x}),P["@language"]=H.toLowerCase();else throw new t('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:U});C.set("@language",!0)}if("@direction"in U){const H=U["@direction"];if(b.processingMode==="json-ld-1.0")throw new t("Invalid JSON-LD syntax; @direction not compatible with "+b.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:U});if(H===null)delete P["@direction"];else{if(H!=="ltr"&&H!=="rtl")throw new t('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:U});P["@direction"]=H}C.set("@direction",!0)}if("@propagate"in U){const H=U["@propagate"];if(b.processingMode==="json-ld-1.0")throw new t("Invalid JSON-LD syntax; @propagate not compatible with "+b.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:U});if(typeof H!="boolean")throw new t("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:w});C.set("@propagate",!0)}if("@import"in U){const H=U["@import"];if(b.processingMode==="json-ld-1.0")throw new t("Invalid JSON-LD syntax; @import not compatible with "+b.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:U});if(!a(H))throw new t("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:w});const D=await x.contextResolver.resolve({activeCtx:b,context:H,documentLoader:x.documentLoader,base:x.base});if(D.length!==1)throw new t("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:w});const W=D[0].getProcessed(b);if(W)U=W;else{const J=D[0].document;if("@import"in J)throw new t("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:w});for(const re in J)U.hasOwnProperty(re)||(U[re]=J[re]);D[0].setProcessed(b,U)}C.set("@import",!0)}C.set("@protected",U["@protected"]||!1);for(const H in U)if(S.createTermDefinition({activeCtx:P,localCtx:U,term:H,defined:C,options:x,overrideProtected:N}),r(U[H])&&"@context"in U[H]){const D=U[H]["@context"];let W=!0;if(a(D)){const J=c(x.base,D);k.has(J)?W=!1:k.add(J)}if(W)try{await S.process({activeCtx:P.clone(),localCtx:U[H]["@context"],overrideProtected:!0,options:x,cycles:k})}catch{throw new t("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:U[H]["@context"],term:H})}}K.setProcessed(b,{context:P,events:L})}return P},S.createTermDefinition=({activeCtx:b,localCtx:w,term:x,defined:_,options:N,overrideProtected:k=!1})=>{if(_.has(x)){if(_.get(x))return;throw new t("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:w,term:x})}_.set(x,!1);let T;if(w.hasOwnProperty(x)&&(T=w[x]),x==="@type"&&r(T)&&(T["@container"]||"@set")==="@set"&&S.processingMode(b,1.1)){const U=["@container","@id","@protected"],V=Object.keys(T);if(V.length===0||V.some(C=>!U.includes(C)))throw new t("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:w,term:x})}else{if(S.isKeyword(x))throw new t("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:w,term:x});if(x.match(d)){N.eventHandler&&l({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:x}},options:N});return}else if(x==="")throw new t("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:w})}const L=b.mappings.get(x);b.mappings.has(x)&&b.mappings.delete(x);let F=!1;if((a(T)||T===null)&&(F=!0,T={"@id":T}),!r(T))throw new t("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:w});const O={};b.mappings.set(x,O),O.reverse=!1;const R=["@container","@id","@language","@reverse","@type"];S.processingMode(b,1.1)&&R.push("@context","@direction","@index","@nest","@prefix","@protected");for(const U in T)if(!R.includes(U))throw new t("Invalid JSON-LD syntax; a term definition must not contain "+U,"jsonld.SyntaxError",{code:"invalid term definition",context:w});const P=x.indexOf(":");if(O._termHasColon=P>0,"@reverse"in T){if("@id"in T)throw new t("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:w});if("@nest"in T)throw new t("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:w});const U=T["@reverse"];if(!a(U))throw new t("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:w});if(U.match(d)){N.eventHandler&&l({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:U}},options:N}),L?b.mappings.set(x,L):b.mappings.delete(x);return}const V=B(b,U,{vocab:!0,base:!1},w,_,N);if(!i(V))throw new t("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:w});O["@id"]=V,O.reverse=!0}else if("@id"in T){let U=T["@id"];if(U&&!a(U))throw new t("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:w});if(U===null)O["@id"]=null;else if(!S.isKeyword(U)&&U.match(d)){N.eventHandler&&l({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:U}},options:N}),L?b.mappings.set(x,L):b.mappings.delete(x);return}else if(U!==x){if(U=B(b,U,{vocab:!0,base:!1},w,_,N),!i(U)&&!S.isKeyword(U))throw new t("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:w});if(x.match(/(?::[^:])|\//)){const V=new Map(_).set(x,!0);if(B(b,x,{vocab:!0,base:!1},w,V,N)!==U)throw new t("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:w})}O["@id"]=U,O._prefix=F&&!O._termHasColon&&U.match(/[:\/\?#\[\]@]$/)!==null}}if(!("@id"in O))if(O._termHasColon){const U=x.substr(0,P);if(w.hasOwnProperty(U)&&S.createTermDefinition({activeCtx:b,localCtx:w,term:U,defined:_,options:N}),b.mappings.has(U)){const V=x.substr(P+1);O["@id"]=b.mappings.get(U)["@id"]+V}else O["@id"]=x}else if(x==="@type")O["@id"]=x;else{if(!("@vocab"in b))throw new t("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:w,term:x});O["@id"]=b["@vocab"]+x}if((T["@protected"]===!0||_.get("@protected")===!0&&T["@protected"]!==!1)&&(b.protected[x]=!0,O.protected=!0),_.set(x,!0),"@type"in T){let U=T["@type"];if(!a(U))throw new t("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:w});if(U==="@json"||U==="@none"){if(S.processingMode(b,1))throw new t(`Invalid JSON-LD syntax; an @context @type value must not be "${U}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:w})}else if(U!=="@id"&&U!=="@vocab"){if(U=B(b,U,{vocab:!0,base:!1},w,_,N),!i(U))throw new t("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:w});if(U.indexOf("_:")===0)throw new t("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:w})}O["@type"]=U}if("@container"in T){const U=a(T["@container"])?[T["@container"]]:T["@container"]||[],V=["@list","@set","@index","@language"];let C=!0;const H=U.includes("@set");if(S.processingMode(b,1.1)){if(V.push("@graph","@id","@type"),U.includes("@list")){if(U.length!==1)throw new t("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:w})}else if(U.includes("@graph")){if(U.some(D=>D!=="@graph"&&D!=="@id"&&D!=="@index"&&D!=="@set"))throw new t("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:w})}else C&=U.length<=(H?2:1);if(U.includes("@type")&&(O["@type"]=O["@type"]||"@id",!["@id","@vocab"].includes(O["@type"])))throw new t("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:w})}else C&=!n(T["@container"]),C&=U.length<=1;if(C&=U.every(D=>V.includes(D)),C&=!(H&&U.includes("@list")),!C)throw new t("Invalid JSON-LD syntax; @context @container value must be one of the following: "+V.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:w});if(O.reverse&&!U.every(D=>["@index","@set"].includes(D)))throw new t("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:w});O["@container"]=U}if("@index"in T){if(!("@container"in T)||!O["@container"].includes("@index"))throw new t(`Invalid JSON-LD syntax; @index without @index in @container: "${T["@index"]}" on term "${x}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:w});if(!a(T["@index"])||T["@index"].indexOf("@")===0)throw new t(`Invalid JSON-LD syntax; @index must expand to an IRI: "${T["@index"]}" on term "${x}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:w});O["@index"]=T["@index"]}if("@context"in T&&(O["@context"]=T["@context"]),"@language"in T&&!("@type"in T)){let U=T["@language"];if(U!==null&&!a(U))throw new t("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:w});U!==null&&(U=U.toLowerCase()),O["@language"]=U}if("@prefix"in T){if(x.match(/:|\//))throw new t("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:w});if(S.isKeyword(O["@id"]))throw new t("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:w});if(typeof T["@prefix"]=="boolean")O._prefix=T["@prefix"]===!0;else throw new t("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:w})}if("@direction"in T){const U=T["@direction"];if(U!==null&&U!=="ltr"&&U!=="rtl")throw new t('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:w});O["@direction"]=U}if("@nest"in T){const U=T["@nest"];if(!a(U)||U!=="@nest"&&U.indexOf("@")===0)throw new t("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:w});O["@nest"]=U}const K=O["@id"];if(K==="@context"||K==="@preserve")throw new t("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:w});if(L&&L.protected&&!k&&(b.protected[x]=!0,O.protected=!0,!I(L,O)))throw new t("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:w,term:x})},S.expandIri=(b,w,x,_)=>B(b,w,x,void 0,void 0,_);function B(b,w,x,_,N,k){if(w===null||!a(w)||S.isKeyword(w))return w;if(w.match(d))return null;if(_&&_.hasOwnProperty(w)&&N.get(w)!==!0&&S.createTermDefinition({activeCtx:b,localCtx:_,term:w,defined:N,options:k}),x=x||{},x.vocab){const L=b.mappings.get(w);if(L===null)return null;if(r(L)&&"@id"in L)return L["@id"]}const T=w.indexOf(":");if(T>0){const L=w.substr(0,T),F=w.substr(T+1);if(L==="_"||F.indexOf("//")===0)return w;_&&_.hasOwnProperty(L)&&S.createTermDefinition({activeCtx:b,localCtx:_,term:L,defined:N,options:k});const O=b.mappings.get(L);if(O&&O._prefix)return O["@id"]+F;if(i(w))return w}if(x.vocab&&"@vocab"in b)w=b["@vocab"]+w;else if(x.base){let L,F;"@base"in b?b["@base"]?(F=c(k.base,b["@base"]),L=c(F,w)):(F=b["@base"],L=w):(F=k.base,L=c(k.base,w)),w=L}return w}S.getInitialContext=b=>{const w=JSON.stringify({processingMode:b.processingMode}),x=y.get(w);if(x)return x;const _={processingMode:b.processingMode,mappings:new Map,inverse:null,getInverse:N,clone:L,revertToPreviousContext:F,protected:{}};return y.size===g&&y.clear(),y.set(w,_),_;function N(){const O=this;if(O.inverse)return O.inverse;const R=O.inverse={},P=O.fastCurieMap={},K={},U=(O["@language"]||"@none").toLowerCase(),V=O["@direction"],C=O.mappings,H=[...C.keys()].sort(f);for(const D of H){const W=C.get(D);if(W===null)continue;let J=W["@container"]||"@none";if(J=[].concat(J).sort().join(""),W["@id"]===null)continue;const re=h(W["@id"]);for(const se of re){let z=R[se];const X=S.isKeyword(se);if(z)!X&&!W._termHasColon&&K[se].push(D);else if(R[se]=z={},!X&&!W._termHasColon){K[se]=[D];const Y={iri:se,terms:K[se]};se[0]in P?P[se[0]].push(Y):P[se[0]]=[Y]}if(z[J]||(z[J]={"@language":{},"@type":{},"@any":{}}),z=z[J],T(D,z["@any"],"@none"),W.reverse)T(D,z["@type"],"@reverse");else if(W["@type"]==="@none")T(D,z["@any"],"@none"),T(D,z["@language"],"@none"),T(D,z["@type"],"@none");else if("@type"in W)T(D,z["@type"],W["@type"]);else if("@language"in W&&"@direction"in W){const Y=W["@language"],ae=W["@direction"];Y&&ae?T(D,z["@language"],`${Y}_${ae}`.toLowerCase()):Y?T(D,z["@language"],Y.toLowerCase()):ae?T(D,z["@language"],`_${ae}`):T(D,z["@language"],"@null")}else"@language"in W?T(D,z["@language"],(W["@language"]||"@null").toLowerCase()):"@direction"in W?W["@direction"]?T(D,z["@language"],`_${W["@direction"]}`):T(D,z["@language"],"@none"):V?(T(D,z["@language"],`_${V}`),T(D,z["@language"],"@none"),T(D,z["@type"],"@none")):(T(D,z["@language"],U),T(D,z["@language"],"@none"),T(D,z["@type"],"@none"))}}for(const D in P)k(P,D,1);return R}function k(O,R,P){const K=O[R],U=O[R]={};let V,C;for(const H of K)V=H.iri,P>=V.length?C="":C=V[P],C in U?U[C].push(H):U[C]=[H];for(const H in U)H!==""&&k(U,H,P+1)}function T(O,R,P){R.hasOwnProperty(P)||(R[P]=O)}function L(){const O={};return O.mappings=e.clone(this.mappings),O.clone=this.clone,O.inverse=null,O.getInverse=this.getInverse,O.protected=e.clone(this.protected),this.previousContext&&(O.previousContext=this.previousContext.clone()),O.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(O["@base"]=this["@base"]),"@language"in this&&(O["@language"]=this["@language"]),"@vocab"in this&&(O["@vocab"]=this["@vocab"]),O}function F(){return this.previousContext?this.previousContext.clone():this}},S.getContextValue=(b,w,x)=>{if(w===null)return x==="@context"?void 0:null;if(b.mappings.has(w)){const _=b.mappings.get(w);if(o(x))return _;if(_.hasOwnProperty(x))return _[x]}if(x==="@language"&&x in b||x==="@direction"&&x in b)return b[x];if(x!=="@context")return null},S.processingMode=(b,w)=>w.toString()>="1.1"?!b.processingMode||b.processingMode>="json-ld-"+w.toString():b.processingMode==="json-ld-1.0",S.isKeyword=b=>{if(!a(b)||b[0]!=="@")return!1;switch(b){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function I(b,w){if(!(b&&typeof b=="object")||!(w&&typeof w=="object"))return b===w;const x=Array.isArray(b);if(x!==Array.isArray(w))return!1;if(x){if(b.length!==w.length)return!1;for(let k=0;k<b.length;++k)if(!I(b[k],w[k]))return!1;return!0}const _=Object.keys(b),N=Object.keys(w);if(_.length!==N.length)return!1;for(const k in b){let T=b[k],L=w[k];if(k==="@container"&&Array.isArray(T)&&Array.isArray(L)&&(T=T.slice().sort(),L=L.slice().sort()),!I(T,L))return!1}return!0}return $o}var Xo,Yc;function qy(){if(Yc)return Xo;Yc=1;const e=lt(),{isArray:t,isObject:n,isEmptyObject:r,isString:a,isUndefined:o}=ot(),{isList:i,isValue:s,isGraph:c,isSubject:l}=Gt(),{expandIri:u,getContextValue:d,isKeyword:h,process:f,processingMode:y}=Xr(),{isAbsolute:g}=Sr(),{REGEX_BCP47:S,REGEX_KEYWORD:B,addValue:I,asArray:b,getValues:w,validateTypeValue:x}=ft(),{handleEvent:_}=$n(),N={};Xo=N,N.expand=async({activeCtx:R,activeProperty:P=null,element:K,options:U={},insideList:V=!1,insideIndex:C=!1,typeScopedContext:H=null})=>{if(K==null)return null;if(P==="@default"&&(U=Object.assign({},U,{isFrame:!1})),!t(K)&&!n(K))return!V&&(P===null||u(R,P,{vocab:!0},U)==="@graph")?(U.eventHandler&&_({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:K}},options:U}),null):L({activeCtx:R,activeProperty:P,value:K,options:U});if(t(K)){let Y=[];const ae=d(R,P,"@container")||[];V=V||ae.includes("@list");for(let ce=0;ce<K.length;++ce){let oe=await N.expand({activeCtx:R,activeProperty:P,element:K[ce],options:U,insideIndex:C,typeScopedContext:H});V&&t(oe)&&(oe={"@list":oe}),oe!==null&&(t(oe)?Y=Y.concat(oe):Y.push(oe))}return Y}const D=u(R,P,{vocab:!0},U),W=d(R,P,"@context");H=H||(R.previousContext?R:null);let J=Object.keys(K).sort(),re=!C;if(re&&H&&J.length<=2&&!J.includes("@context"))for(const Y of J){const ae=u(H,Y,{vocab:!0},U);if(ae==="@value"){re=!1,R=H;break}if(ae==="@id"&&J.length===1){re=!1;break}}re&&(R=R.revertToPreviousContext()),o(W)||(R=await f({activeCtx:R,localCtx:W,propagate:!0,overrideProtected:!0,options:U})),"@context"in K&&(R=await f({activeCtx:R,localCtx:K["@context"],options:U})),H=R;let se=null;for(const Y of J)if(u(R,Y,{vocab:!0},U)==="@type"){se=se||Y;const ce=K[Y],oe=Array.isArray(ce)?ce.length>1?ce.slice().sort():ce:[ce];for(const de of oe){const pe=d(H,de,"@context");o(pe)||(R=await f({activeCtx:R,localCtx:pe,options:U,propagate:!1}))}}let z={};await T({activeCtx:R,activeProperty:P,expandedActiveProperty:D,element:K,expandedParent:z,options:U,insideList:V,typeKey:se,typeScopedContext:H}),J=Object.keys(z);let X=J.length;if("@value"in z){if("@type"in z&&("@language"in z||"@direction"in z))throw new e('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:z});let Y=X-1;if("@type"in z&&(Y-=1),"@index"in z&&(Y-=1),"@language"in z&&(Y-=1),"@direction"in z&&(Y-=1),Y!==0)throw new e('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:z});const ae=z["@value"]===null?[]:b(z["@value"]),ce=w(z,"@type");if(!(y(R,1.1)&&ce.includes("@json")&&ce.length===1))if(ae.length===0)U.eventHandler&&_({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:z}},options:U}),z=null;else{if(!ae.every(oe=>a(oe)||r(oe))&&"@language"in z)throw new e("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:z});if(!ce.every(oe=>g(oe)&&!(a(oe)&&oe.indexOf("_:")===0)||r(oe)))throw new e('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:z})}}else if("@type"in z&&!t(z["@type"]))z["@type"]=[z["@type"]];else if("@set"in z||"@list"in z){if(X>1&&!(X===2&&"@index"in z))throw new e('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:z});"@set"in z&&(z=z["@set"],J=Object.keys(z),X=J.length)}else X===1&&"@language"in z&&(U.eventHandler&&_({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:z}},options:U}),z=null);return n(z)&&!U.keepFreeFloatingNodes&&!V&&(P===null||D==="@graph"||(d(R,P,"@container")||[]).includes("@graph"))&&(z=k({value:z,count:X,options:U})),z};function k({value:R,count:P,options:K}){if(P===0||"@value"in R||"@list"in R||P===1&&"@id"in R){if(K.eventHandler){let U,V;P===0?(U="empty object",V="Dropping empty object."):"@value"in R?(U="object with only @value",V="Dropping object with only @value."):"@list"in R?(U="object with only @list",V="Dropping object with only @list."):P===1&&"@id"in R&&(U="object with only @id",V="Dropping object with only @id."),_({event:{type:["JsonLdEvent"],code:U,level:"warning",message:V,details:{value:R}},options:K})}return null}return R}async function T({activeCtx:R,activeProperty:P,expandedActiveProperty:K,element:U,expandedParent:V,options:C={},insideList:H,typeKey:D,typeScopedContext:W}){const J=Object.keys(U).sort(),re=[];let se;const z=U[D]&&u(R,t(U[D])?U[D][0]:U[D],{vocab:!0},{...C,typeExpansion:!0})==="@json";for(const X of J){let Y=U[X],ae;if(X==="@context")continue;const ce=u(R,X,{vocab:!0},C);if(ce===null||!(g(ce)||h(ce))){C.eventHandler&&_({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:X,expandedProperty:ce}},options:C});continue}if(h(ce)){if(K==="@reverse")throw new e("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:Y});if(ce in V&&ce!=="@included"&&ce!=="@type")throw new e("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:ce})}if(ce==="@id"){if(!a(Y)){if(!C.isFrame)throw new e('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:Y});if(n(Y)){if(!r(Y))throw new e('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:Y})}else if(t(Y)){if(!Y.every(fe=>a(fe)))throw new e('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:Y})}else throw new e('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:Y})}I(V,"@id",b(Y).map(fe=>{if(a(fe)){const ye=u(R,fe,{base:!0},C);return C.eventHandler&&(ye===null?_(fe===null?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:fe}},options:C}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:fe}},options:C}):g(ye)||_({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:fe,expandedId:ye}},options:C})),ye}return fe}),{propertyIsArray:C.isFrame});continue}if(ce==="@type"){n(Y)&&(Y=Object.fromEntries(Object.entries(Y).map(([fe,ye])=>[u(W,fe,{vocab:!0}),b(ye).map(Ie=>u(W,Ie,{base:!0,vocab:!0},{...C,typeExpansion:!0}))]))),x(Y,C.isFrame),I(V,"@type",b(Y).map(fe=>{if(a(fe)){const ye=u(W,fe,{base:!0,vocab:!0},{...C,typeExpansion:!0});return ye!=="@json"&&!g(ye)&&C.eventHandler&&_({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:fe}},options:C}),ye}return fe}),{propertyIsArray:!!C.isFrame});continue}if(ce==="@included"&&y(R,1.1)){const fe=b(await N.expand({activeCtx:R,activeProperty:P,element:Y,options:C}));if(!fe.every(ye=>l(ye)))throw new e("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:Y});I(V,"@included",fe,{propertyIsArray:!0});continue}if(ce==="@graph"&&!(n(Y)||t(Y)))throw new e('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:Y});if(ce==="@value"){se=Y,z&&y(R,1.1)?V["@value"]=Y:I(V,"@value",Y,{propertyIsArray:C.isFrame});continue}if(ce==="@language"){if(Y===null)continue;if(!a(Y)&&!C.isFrame)throw new e('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:Y});Y=b(Y).map(fe=>a(fe)?fe.toLowerCase():fe);for(const fe of Y)a(fe)&&!fe.match(S)&&C.eventHandler&&_({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:fe}},options:C});I(V,"@language",Y,{propertyIsArray:C.isFrame});continue}if(ce==="@direction"){if(!a(Y)&&!C.isFrame)throw new e('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:Y});Y=b(Y);for(const fe of Y)if(a(fe)&&fe!=="ltr"&&fe!=="rtl")throw new e('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:Y});I(V,"@direction",Y,{propertyIsArray:C.isFrame});continue}if(ce==="@index"){if(!a(Y))throw new e('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:Y});I(V,"@index",Y);continue}if(ce==="@reverse"){if(!n(Y))throw new e('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:Y});if(ae=await N.expand({activeCtx:R,activeProperty:"@reverse",element:Y,options:C}),"@reverse"in ae)for(const ye in ae["@reverse"])I(V,ye,ae["@reverse"][ye],{propertyIsArray:!0});let fe=V["@reverse"]||null;for(const ye in ae){if(ye==="@reverse")continue;fe===null&&(fe=V["@reverse"]={}),I(fe,ye,[],{propertyIsArray:!0});const Ie=ae[ye];for(let xe=0;xe<Ie.length;++xe){const _e=Ie[xe];if(s(_e)||i(_e))throw new e('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:ae});I(fe,ye,_e,{propertyIsArray:!0})}}continue}if(ce==="@nest"){re.push(X);continue}let oe=R;const de=d(R,X,"@context");o(de)||(oe=await f({activeCtx:R,localCtx:de,propagate:!0,overrideProtected:!0,options:C}));const pe=d(R,X,"@container")||[];if(pe.includes("@language")&&n(Y)){const fe=d(oe,X,"@direction");ae=F(oe,Y,fe,C)}else if(pe.includes("@index")&&n(Y)){const fe=pe.includes("@graph"),ye=d(oe,X,"@index")||"@index",Ie=ye!=="@index"&&u(R,ye,{vocab:!0},C);ae=await O({activeCtx:oe,options:C,activeProperty:X,value:Y,asGraph:fe,indexKey:ye,propertyIndex:Ie})}else if(pe.includes("@id")&&n(Y)){const fe=pe.includes("@graph");ae=await O({activeCtx:oe,options:C,activeProperty:X,value:Y,asGraph:fe,indexKey:"@id"})}else if(pe.includes("@type")&&n(Y))ae=await O({activeCtx:oe.revertToPreviousContext(),options:C,activeProperty:X,value:Y,asGraph:!1,indexKey:"@type"});else{const fe=ce==="@list";if(fe||ce==="@set"){let ye=P;fe&&K==="@graph"&&(ye=null),ae=await N.expand({activeCtx:oe,activeProperty:ye,element:Y,options:C,insideList:fe})}else d(R,X,"@type")==="@json"?ae={"@type":"@json","@value":Y}:ae=await N.expand({activeCtx:oe,activeProperty:X,element:Y,options:C,insideList:!1})}if(!(ae===null&&ce!=="@value")){if(ce!=="@list"&&!i(ae)&&pe.includes("@list")&&(ae={"@list":b(ae)}),pe.includes("@graph")&&!pe.some(fe=>fe==="@id"||fe==="@index")){if(ae=b(ae),C.isFrame||(ae=ae.filter(fe=>{const ye=Object.keys(fe).length;return k({value:fe,count:ye,options:C})!==null})),ae.length===0)continue;ae=ae.map(fe=>({"@graph":b(fe)}))}if(oe.mappings.has(X)&&oe.mappings.get(X).reverse){const fe=V["@reverse"]=V["@reverse"]||{};ae=b(ae);for(let ye=0;ye<ae.length;++ye){const Ie=ae[ye];if(s(Ie)||i(Ie))throw new e('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:ae});I(fe,ce,Ie,{propertyIsArray:!0})}continue}I(V,ce,ae,{propertyIsArray:!0})}}if("@value"in V&&!(V["@type"]==="@json"&&y(R,1.1))){if((n(se)||t(se))&&!C.isFrame)throw new e('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:se})}for(const X of re){const Y=t(U[X])?U[X]:[U[X]];for(const ae of Y){if(!n(ae)||Object.keys(ae).some(ce=>u(R,ce,{vocab:!0},C)==="@value"))throw new e("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:ae});await T({activeCtx:R,activeProperty:P,expandedActiveProperty:K,element:ae,expandedParent:V,options:C,insideList:H,typeScopedContext:W,typeKey:D})}}}function L({activeCtx:R,activeProperty:P,value:K,options:U}){if(K==null)return null;const V=u(R,P,{vocab:!0},U);if(V==="@id")return u(R,K,{base:!0},U);if(V==="@type")return u(R,K,{vocab:!0,base:!0},{...U,typeExpansion:!0});const C=d(R,P,"@type");if((C==="@id"||V==="@graph")&&a(K)){const D=u(R,K,{base:!0},U);return D===null&&K.match(B)&&U.eventHandler&&_({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:P}},options:U}),{"@id":D}}if(C==="@vocab"&&a(K))return{"@id":u(R,K,{vocab:!0,base:!0},U)};if(h(V))return K;const H={};if(C&&!["@id","@vocab","@none"].includes(C))H["@type"]=C;else if(a(K)){const D=d(R,P,"@language");D!==null&&(H["@language"]=D);const W=d(R,P,"@direction");W!==null&&(H["@direction"]=W)}return["boolean","number","string"].includes(typeof K)||(K=K.toString()),H["@value"]=K,H}function F(R,P,K,U){const V=[],C=Object.keys(P).sort();for(const H of C){const D=u(R,H,{vocab:!0},U);let W=P[H];t(W)||(W=[W]);for(const J of W){if(J===null)continue;if(!a(J))throw new e("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:P});const re={"@value":J};D!=="@none"&&(H.match(S)||U.eventHandler&&_({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:H}},options:U}),re["@language"]=H.toLowerCase()),K&&(re["@direction"]=K),V.push(re)}}return V}async function O({activeCtx:R,options:P,activeProperty:K,value:U,asGraph:V,indexKey:C,propertyIndex:H}){const D=[],W=Object.keys(U).sort(),J=C==="@type";for(let re of W){if(J){const X=d(R,re,"@context");o(X)||(R=await f({activeCtx:R,localCtx:X,propagate:!1,options:P}))}let se=U[re];t(se)||(se=[se]),se=await N.expand({activeCtx:R,activeProperty:K,element:se,options:P,insideList:!1,insideIndex:!0});let z;H?re==="@none"?z="@none":z=L({activeCtx:R,activeProperty:C,value:re,options:P}):z=u(R,re,{vocab:!0},P),C==="@id"?re=u(R,re,{base:!0},P):J&&(re=z);for(let X of se){if(V&&!c(X)&&(X={"@graph":[X]}),C==="@type")z==="@none"||(X["@type"]?X["@type"]=[re].concat(X["@type"]):X["@type"]=[re]);else{if(s(X)&&!["@language","@type","@index"].includes(C))throw new e(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${C}".`,"jsonld.SyntaxError",{code:"invalid value object",value:X});H?z!=="@none"&&I(X,H,z,{propertyIsArray:!0,prependValue:!0}):z!=="@none"&&!(C in X)&&(X[C]=re)}D.push(X)}}return D}return Xo}var zo,Zc;function Vi(){if(Zc)return zo;Zc=1;const{isKeyword:e}=Xr(),t=Gt(),n=ot(),r=ft(),a=lt(),o={};return zo=o,o.createMergedNodeMap=(i,s)=>{s=s||{};const c=s.issuer||new r.IdentifierIssuer("_:b"),l={"@default":{}};return o.createNodeMap(i,l,"@default",c),o.mergeNodeMaps(l)},o.createNodeMap=(i,s,c,l,u,d)=>{if(n.isArray(i)){for(const g of i)o.createNodeMap(g,s,c,l,void 0,d);return}if(!n.isObject(i)){d&&d.push(i);return}if(t.isValue(i)){if("@type"in i){let g=i["@type"];g.indexOf("_:")===0&&(i["@type"]=g=l.getId(g))}d&&d.push(i);return}else if(d&&t.isList(i)){const g=[];o.createNodeMap(i["@list"],s,c,l,u,g),d.push({"@list":g});return}if("@type"in i){const g=i["@type"];for(const S of g)S.indexOf("_:")===0&&l.getId(S)}n.isUndefined(u)&&(u=t.isBlankNode(i)?l.getId(i["@id"]):i["@id"]),d&&d.push({"@id":u});const h=s[c],f=h[u]=h[u]||{};f["@id"]=u;const y=Object.keys(i).sort();for(let g of y){if(g==="@id")continue;if(g==="@reverse"){const B={"@id":u},I=i["@reverse"];for(const b in I){const w=I[b];for(const x of w){let _=x["@id"];t.isBlankNode(x)&&(_=l.getId(_)),o.createNodeMap(x,s,c,l,_),r.addValue(h[_],b,B,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(g==="@graph"){u in s||(s[u]={}),o.createNodeMap(i[g],s,u,l);continue}if(g==="@included"){o.createNodeMap(i[g],s,c,l);continue}if(g!=="@type"&&e(g)){if(g==="@index"&&g in f&&(i[g]!==f[g]||i[g]["@id"]!==f[g]["@id"]))throw new a("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:f});f[g]=i[g];continue}const S=i[g];if(g.indexOf("_:")===0&&(g=l.getId(g)),S.length===0){r.addValue(f,g,[],{propertyIsArray:!0});continue}for(let B of S)if(g==="@type"&&(B=B.indexOf("_:")===0?l.getId(B):B),t.isSubject(B)||t.isSubjectReference(B)){if("@id"in B&&!B["@id"])continue;const I=t.isBlankNode(B)?l.getId(B["@id"]):B["@id"];r.addValue(f,g,{"@id":I},{propertyIsArray:!0,allowDuplicate:!1}),o.createNodeMap(B,s,c,l,I)}else if(t.isValue(B))r.addValue(f,g,B,{propertyIsArray:!0,allowDuplicate:!1});else if(t.isList(B)){const I=[];o.createNodeMap(B["@list"],s,c,l,u,I),B={"@list":I},r.addValue(f,g,B,{propertyIsArray:!0,allowDuplicate:!1})}else o.createNodeMap(B,s,c,l,u),r.addValue(f,g,B,{propertyIsArray:!0,allowDuplicate:!1})}},o.mergeNodeMapGraphs=i=>{const s={};for(const c of Object.keys(i).sort())for(const l of Object.keys(i[c]).sort()){const u=i[c][l];l in s||(s[l]={"@id":l});const d=s[l];for(const h of Object.keys(u).sort())if(e(h)&&h!=="@type")d[h]=r.clone(u[h]);else for(const f of u[h])r.addValue(d,h,r.clone(f),{propertyIsArray:!0,allowDuplicate:!1})}return s},o.mergeNodeMaps=i=>{const s=i["@default"],c=Object.keys(i).sort();for(const l of c){if(l==="@default")continue;const u=i[l];let d=s[l];d?"@graph"in d||(d["@graph"]=[]):s[l]=d={"@id":l,"@graph":[]};const h=d["@graph"];for(const f of Object.keys(u).sort()){const y=u[f];t.isSubjectReference(y)||h.push(y)}}return s},zo}var Jo,Qc;function Ky(){if(Qc)return Jo;Qc=1;const{isSubjectReference:e}=Gt(),{createMergedNodeMap:t}=Vi(),n={};return Jo=n,n.flatten=r=>{const a=t(r),o=[],i=Object.keys(a).sort();for(let s=0;s<i.length;++s){const c=a[i[s]];e(c)||o.push(c)}return o},Jo}var Yo,eu;function Vy(){if(eu)return Yo;eu=1;const e=lt(),t=Gt(),n=ot(),{REGEX_BCP47:r,addValue:a}=ft(),{handleEvent:o}=$n(),{RDF_LIST:i,RDF_FIRST:s,RDF_REST:c,RDF_NIL:l,RDF_TYPE:u,RDF_JSON_LITERAL:d,XSD_BOOLEAN:h,XSD_DOUBLE:f,XSD_INTEGER:y,XSD_STRING:g}=ba(),S={};Yo=S,S.fromRDF=async(I,b)=>{const{useRdfType:w=!1,useNativeTypes:x=!1,rdfDirection:_=null}=b,N={},k={"@default":N},T={};if(_){if(_==="compound-literal")throw new e("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:_});if(_!=="i18n-datatype")throw new e("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:_})}for(const O of I){const R=O.graph.termType==="DefaultGraph"?"@default":O.graph.value;R in k||(k[R]={}),R!=="@default"&&!(R in N)&&(N[R]={"@id":R});const P=k[R],K=O.subject.value,U=O.predicate.value,V=O.object;K in P||(P[K]={"@id":K});const C=P[K],H=V.termType.endsWith("Node");if(H&&!(V.value in P)&&(P[V.value]={"@id":V.value}),U===u&&!w&&H){a(C,"@type",V.value,{propertyIsArray:!0});continue}const D=B(V,x,_,b);if(a(C,U,D,{propertyIsArray:!0}),H)if(V.value===l){const W=P[V.value];"usages"in W||(W.usages=[]),W.usages.push({node:C,property:U,value:D})}else V.value in T?T[V.value]=!1:T[V.value]={node:C,property:U,value:D}}for(const O in k){const R=k[O];if(!(l in R))continue;const P=R[l];if(P.usages){for(let K of P.usages){let U=K.node,V=K.property,C=K.value;const H=[],D=[];let W=Object.keys(U).length;for(;V===c&&n.isObject(T[U["@id"]])&&n.isArray(U[s])&&U[s].length===1&&n.isArray(U[c])&&U[c].length===1&&(W===3||W===4&&n.isArray(U["@type"])&&U["@type"].length===1&&U["@type"][0]===i)&&(H.push(U[s][0]),D.push(U["@id"]),K=T[U["@id"]],U=K.node,V=K.property,C=K.value,W=Object.keys(U).length,!!t.isBlankNode(U)););delete C["@id"],C["@list"]=H.reverse();for(const J of D)delete R[J]}delete P.usages}}const L=[],F=Object.keys(N).sort();for(const O of F){const R=N[O];if(O in k){const P=R["@graph"]=[],K=k[O],U=Object.keys(K).sort();for(const V of U){const C=K[V];t.isSubjectReference(C)||P.push(C)}}t.isSubjectReference(R)||L.push(R)}return L};function B(I,b,w,x){if(I.termType.endsWith("Node"))return{"@id":I.value};const _={"@value":I.value};if(I.language)I.language.match(r)||x.eventHandler&&o({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:I.language}},options:x}),_["@language"]=I.language;else{let N=I.datatype.value;if(N||(N=g),N===d){N="@json";try{_["@value"]=JSON.parse(_["@value"])}catch(k){throw new e("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:_["@value"],cause:k})}}if(b){if(N===h)_["@value"]==="true"?_["@value"]=!0:_["@value"]==="false"&&(_["@value"]=!1);else if(n.isNumeric(_["@value"]))if(N===y){const k=parseInt(_["@value"],10);k.toFixed(0)===_["@value"]&&(_["@value"]=k)}else N===f&&(_["@value"]=parseFloat(_["@value"]));[h,y,f,g].includes(N)||(_["@type"]=N)}else if(w==="i18n-datatype"&&N.startsWith("https://www.w3.org/ns/i18n#")){const[,k,T]=N.split(/[#_]/);k.length>0&&(_["@language"]=k,k.match(r)||x.eventHandler&&o({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:k}},options:x})),_["@direction"]=T}else N!==g&&(_["@type"]=N)}return _}return Yo}var Zo,tu;function Gy(){return tu||(tu=1,Zo=function e(t){return t===null||typeof t!="object"||t.toJSON!=null?JSON.stringify(t):Array.isArray(t)?"["+t.reduce((n,r,a)=>{const o=a===0?"":",",i=r===void 0||typeof r=="symbol"?null:r;return n+o+e(i)},"")+"]":"{"+Object.keys(t).sort().reduce((n,r,a)=>{if(t[r]===void 0||typeof t[r]=="symbol")return n;const o=n.length===0?"":",";return n+o+e(r)+":"+e(t[r])},"")+"}"}),Zo}var Qo,ru;function Wy(){if(ru)return Qo;ru=1;const{createNodeMap:e}=Vi(),{isKeyword:t}=Xr(),n=Gt(),r=Gy(),a=lt(),o=ot(),i=ft(),{handleEvent:s}=$n(),{RDF_FIRST:c,RDF_REST:l,RDF_NIL:u,RDF_TYPE:d,RDF_JSON_LITERAL:h,RDF_LANGSTRING:f,XSD_BOOLEAN:y,XSD_DOUBLE:g,XSD_INTEGER:S,XSD_STRING:B}=ba(),{isAbsolute:I}=Sr(),b={};Qo=b,b.toRDF=(N,k)=>{const T=new i.IdentifierIssuer("_:b"),L={"@default":{}};e(N,L,"@default",T);const F=[],O=Object.keys(L).sort();for(const R of O){let P;if(R==="@default")P={termType:"DefaultGraph",value:""};else if(I(R))R.startsWith("_:")?P={termType:"BlankNode"}:P={termType:"NamedNode"},P.value=R;else{k.eventHandler&&s({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:R}},options:k});continue}w(F,L[R],P,T,k)}return F};function w(N,k,T,L,F){const O=Object.keys(k).sort();for(const R of O){const P=k[R],K=Object.keys(P).sort();for(let U of K){const V=P[U];if(U==="@type")U=d;else if(t(U))continue;for(const C of V){const H={termType:R.startsWith("_:")?"BlankNode":"NamedNode",value:R};if(!I(R)){F.eventHandler&&s({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:R}},options:F});continue}const D={termType:U.startsWith("_:")?"BlankNode":"NamedNode",value:U};if(!I(U)){F.eventHandler&&s({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:U}},options:F});continue}if(D.termType==="BlankNode"&&!F.produceGeneralizedRdf){F.eventHandler&&s({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:L.getOldIds().find(J=>L.getId(J)===U)}},options:F});continue}const W=_(C,L,N,T,F.rdfDirection,F);W&&N.push({subject:H,predicate:D,object:W,graph:T})}}}}function x(N,k,T,L,F,O){const R={termType:"NamedNode",value:c},P={termType:"NamedNode",value:l},K={termType:"NamedNode",value:u},U=N.pop(),V=U?{termType:"BlankNode",value:k.getId()}:K;let C=V;for(const H of N){const D=_(H,k,T,L,F,O),W={termType:"BlankNode",value:k.getId()};T.push({subject:C,predicate:R,object:D,graph:L}),T.push({subject:C,predicate:P,object:W,graph:L}),C=W}if(U){const H=_(U,k,T,L,F,O);T.push({subject:C,predicate:R,object:H,graph:L}),T.push({subject:C,predicate:P,object:K,graph:L})}return V}function _(N,k,T,L,F,O){const R={};if(n.isValue(N)){R.termType="Literal",R.value=void 0,R.datatype={termType:"NamedNode"};let P=N["@value"];const K=N["@type"]||null;if(K==="@json")R.value=r(P),R.datatype.value=h;else if(o.isBoolean(P))R.value=P.toString(),R.datatype.value=K||y;else if(o.isDouble(P)||K===g)o.isDouble(P)||(P=parseFloat(P)),R.value=P.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),R.datatype.value=K||g;else if(o.isNumber(P))R.value=P.toFixed(0),R.datatype.value=K||S;else if("@direction"in N&&F==="i18n-datatype"){const U=(N["@language"]||"").toLowerCase(),V=N["@direction"],C=`https://www.w3.org/ns/i18n#${U}_${V}`;R.datatype.value=C,R.value=P}else{if("@direction"in N&&F==="compound-literal")throw new a("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:F});if("@direction"in N&&F)throw new a("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:F});"@language"in N?("@direction"in N&&!F&&O.eventHandler&&s({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:R.value}},options:O}),R.value=P,R.datatype.value=K||f,R.language=N["@language"]):("@direction"in N&&!F&&O.eventHandler&&s({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:R.value}},options:O}),R.value=P,R.datatype.value=K||B)}}else if(n.isList(N)){const P=x(N["@list"],k,T,L,F,O);R.termType=P.termType,R.value=P.value}else{const P=o.isObject(N)?N["@id"]:N;R.termType=P.startsWith("_:")?"BlankNode":"NamedNode",R.value=P}return R.termType==="NamedNode"&&!I(R.value)?(O.eventHandler&&s({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:R.value}},options:O}),null):R}return Qo}var es,nu;function $y(){if(nu)return es;nu=1;const{isKeyword:e}=Xr(),t=Gt(),n=ot(),r=ft(),a=Sr(),o=lt(),{createNodeMap:i,mergeNodeMapGraphs:s}=Vi(),c={};es=c,c.frameMergedOrDefault=(w,x,_)=>{const N={options:_,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},k=new r.IdentifierIssuer("_:b");i(w,N.graphMap,"@default",k),_.merged&&(N.graphMap["@merged"]=s(N.graphMap),N.graph="@merged"),N.subjects=N.graphMap[N.graph];const T=[];c.frame(N,Object.keys(N.subjects).sort(),x,T),_.pruneBlankNodeIdentifiers&&(_.bnodesToClear=Object.keys(N.bnodeMap).filter(L=>N.bnodeMap[L].length===1));return _.link={},S(T,_)},c.frame=(w,x,_,N,k=null)=>{h(_),_=_[0];const T=w.options,L={embed:d(_,T,"embed"),explicit:d(_,T,"explicit"),requireAll:d(_,T,"requireAll")};w.link.hasOwnProperty(w.graph)||(w.link[w.graph]={});const F=w.link[w.graph],O=f(w,x,_,L),R=Object.keys(O).sort();for(const P of R){const K=O[P];if(k===null?w.uniqueEmbeds={[w.graph]:{}}:w.uniqueEmbeds[w.graph]=w.uniqueEmbeds[w.graph]||{},L.embed==="@link"&&P in F){B(N,k,F[P]);continue}const U={"@id":P};if(P.indexOf("_:")===0&&r.addValue(w.bnodeMap,P,U,{propertyIsArray:!0}),F[P]=U,(L.embed==="@first"||L.embed==="@last")&&w.is11)throw new o("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:_});if(!(!w.embedded&&w.uniqueEmbeds[w.graph].hasOwnProperty(P))){if(w.embedded&&(L.embed==="@never"||u(K,w.graph,w.subjectStack))){B(N,k,U);continue}if(w.embedded&&(L.embed=="@first"||L.embed=="@once")&&w.uniqueEmbeds[w.graph].hasOwnProperty(P)){B(N,k,U);continue}if(L.embed==="@last"&&P in w.uniqueEmbeds[w.graph]&&g(w,P),w.uniqueEmbeds[w.graph][P]={parent:N,property:k},w.subjectStack.push({subject:K,graph:w.graph}),P in w.graphMap){let V=!1,C=null;"@graph"in _?(C=_["@graph"][0],V=!(P==="@merged"||P==="@default"),n.isObject(C)||(C={})):(V=w.graph!=="@merged",C={}),V&&c.frame({...w,graph:P,embedded:!1},Object.keys(w.graphMap[P]).sort(),[C],U,"@graph")}"@included"in _&&c.frame({...w,embedded:!1},x,_["@included"],U,"@included");for(const V of Object.keys(K).sort()){if(e(V)){if(U[V]=r.clone(K[V]),V==="@type")for(const C of K["@type"])C.indexOf("_:")===0&&r.addValue(w.bnodeMap,C,U,{propertyIsArray:!0});continue}if(!(L.explicit&&!(V in _)))for(const C of K[V]){const H=V in _?_[V]:l(L);if(t.isList(C)){const D=_[V]&&_[V][0]&&_[V][0]["@list"]?_[V][0]["@list"]:l(L),W={"@list":[]};B(U,V,W);const J=C["@list"];for(const re of J)t.isSubjectReference(re)?c.frame({...w,embedded:!0},[re["@id"]],D,W,"@list"):B(W,"@list",r.clone(re))}else t.isSubjectReference(C)?c.frame({...w,embedded:!0},[C["@id"]],H,U,V):b(H[0],C)&&B(U,V,r.clone(C))}}for(const V of Object.keys(_).sort()){if(V==="@type"){if(!n.isObject(_[V][0])||!("@default"in _[V][0]))continue}else if(e(V))continue;const C=_[V][0]||{};if(!d(C,T,"omitDefault")&&!(V in U)){let D="@null";"@default"in C&&(D=r.clone(C["@default"])),n.isArray(D)||(D=[D]),U[V]=[{"@preserve":D}]}}for(const V of Object.keys(_["@reverse"]||{}).sort()){const C=_["@reverse"][V];for(const H of Object.keys(w.subjects))r.getValues(w.subjects[H],V).some(W=>W["@id"]===P)&&(U["@reverse"]=U["@reverse"]||{},r.addValue(U["@reverse"],V,[],{propertyIsArray:!0}),c.frame({...w,embedded:!0},[H],C,U["@reverse"][V],k))}B(N,k,U),w.subjectStack.pop()}}},c.cleanupNull=(w,x)=>{if(n.isArray(w))return w.map(N=>c.cleanupNull(N,x)).filter(N=>N);if(w==="@null")return null;if(n.isObject(w)){if("@id"in w){const _=w["@id"];if(x.link.hasOwnProperty(_)){const N=x.link[_].indexOf(w);if(N!==-1)return x.link[_][N];x.link[_].push(w)}else x.link[_]=[w]}for(const _ in w)w[_]=c.cleanupNull(w[_],x)}return w};function l(w){const x={};for(const _ in w)w[_]!==void 0&&(x["@"+_]=[w[_]]);return[x]}function u(w,x,_){for(let N=_.length-1;N>=0;--N){const k=_[N];if(k.graph===x&&k.subject["@id"]===w["@id"])return!0}return!1}function d(w,x,_){const N="@"+_;let k=N in w?w[N][0]:x[_];if(_==="embed"){if(k===!0)k="@once";else if(k===!1)k="@never";else if(k!=="@always"&&k!=="@never"&&k!=="@link"&&k!=="@first"&&k!=="@last"&&k!=="@once")throw new o("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:w})}return k}function h(w){if(!n.isArray(w)||w.length!==1||!n.isObject(w[0]))throw new o("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:w});if("@id"in w[0]){for(const x of r.asArray(w[0]["@id"]))if(!(n.isObject(x)||a.isAbsolute(x))||n.isString(x)&&x.indexOf("_:")===0)throw new o("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:w})}if("@type"in w[0]){for(const x of r.asArray(w[0]["@type"]))if(!(n.isObject(x)||a.isAbsolute(x)||x==="@json")||n.isString(x)&&x.indexOf("_:")===0)throw new o("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:w})}}function f(w,x,_,N){const k={};for(const T of x){const L=w.graphMap[w.graph][T];y(w,L,_,N)&&(k[T]=L)}return k}function y(w,x,_,N){let k=!0,T=!1;for(const L in _){let F=!1;const O=r.getValues(x,L),R=r.getValues(_,L).length===0;if(L==="@id"){if(n.isEmptyObject(_["@id"][0]||{})?F=!0:_["@id"].length>=0&&(F=_["@id"].includes(O[0])),!N.requireAll)return F}else if(L==="@type"){if(k=!1,R){if(O.length>0)return!1;F=!0}else if(_["@type"].length===1&&n.isEmptyObject(_["@type"][0]))F=O.length>0;else for(const P of _["@type"])n.isObject(P)&&"@default"in P?F=!0:F=F||O.some(K=>K===P);if(!N.requireAll)return F}else{if(e(L))continue;{const P=r.getValues(_,L)[0];let K=!1;if(P&&(h([P]),K="@default"in P),k=!1,O.length===0&&K)continue;if(O.length>0&&R)return!1;if(P===void 0){if(O.length>0)return!1;F=!0}else if(t.isList(P)){const U=P["@list"][0];if(t.isList(O[0])){const V=O[0]["@list"];t.isValue(U)?F=V.some(C=>b(U,C)):(t.isSubject(U)||t.isSubjectReference(U))&&(F=V.some(C=>I(w,U,C,N)))}}else t.isValue(P)?F=O.some(U=>b(P,U)):t.isSubjectReference(P)?F=O.some(U=>I(w,P,U,N)):n.isObject(P)?F=O.length>0:F=!1}}if(!F&&N.requireAll)return!1;T=T||F}return k||T}function g(w,x){const _=w.uniqueEmbeds[w.graph],N=_[x],k=N.parent,T=N.property,L={"@id":x};if(n.isArray(k)){for(let O=0;O<k.length;++O)if(r.compareValues(k[O],L)){k[O]=L;break}}else{const O=n.isArray(k[T]);r.removeValue(k,T,L,{propertyIsArray:O}),r.addValue(k,T,L,{propertyIsArray:O})}const F=O=>{const R=Object.keys(_);for(const P of R)P in _&&n.isObject(_[P].parent)&&_[P].parent["@id"]===O&&(delete _[P],F(P))};F(x)}function S(w,x){if(n.isArray(w))return w.map(_=>S(_,x));if(n.isObject(w)){if("@preserve"in w)return w["@preserve"][0];if(t.isValue(w))return w;if(t.isList(w))return w["@list"]=S(w["@list"],x),w;if("@id"in w){const _=w["@id"];if(x.link.hasOwnProperty(_)){const N=x.link[_].indexOf(w);if(N!==-1)return x.link[_][N];x.link[_].push(w)}else x.link[_]=[w]}for(const _ in w){if(_==="@id"&&x.bnodesToClear.includes(w[_])){delete w["@id"];continue}w[_]=S(w[_],x)}}return w}function B(w,x,_){n.isObject(w)?r.addValue(w,x,_,{propertyIsArray:!0}):w.push(_)}function I(w,x,_,N){if(!("@id"in _))return!1;const k=w.subjects[_["@id"]];return k&&y(w,k,x,N)}function b(w,x){const _=x["@value"],N=x["@type"],k=x["@language"],T=w["@value"]?n.isArray(w["@value"])?w["@value"]:[w["@value"]]:[],L=w["@type"]?n.isArray(w["@type"])?w["@type"]:[w["@type"]]:[],F=w["@language"]?n.isArray(w["@language"])?w["@language"]:[w["@language"]]:[];return T.length===0&&L.length===0&&F.length===0?!0:!(!(T.includes(_)||n.isEmptyObject(T[0]))||!(!N&&L.length===0||L.includes(N)||N&&n.isEmptyObject(L[0]))||!(!k&&F.length===0||F.includes(k)||k&&n.isEmptyObject(F[0])))}return es}var ts,iu;function Xy(){if(iu)return ts;iu=1;const e=lt(),{isArray:t,isObject:n,isString:r,isUndefined:a}=ot(),{isList:o,isValue:i,isGraph:s,isSimpleGraph:c,isSubjectReference:l}=Gt(),{expandIri:u,getContextValue:d,isKeyword:h,process:f,processingMode:y}=Xr(),{removeBase:g,prependBase:S}=Sr(),{REGEX_KEYWORD:B,addValue:I,asArray:b,compareShortestLeast:w}=ft(),x={};ts=x,x.compact=async({activeCtx:k,activeProperty:T=null,element:L,options:F={}})=>{if(t(L)){let R=[];for(let P=0;P<L.length;++P){const K=await x.compact({activeCtx:k,activeProperty:T,element:L[P],options:F});K!==null&&R.push(K)}return F.compactArrays&&R.length===1&&(d(k,T,"@container")||[]).length===0&&(R=R[0]),R}const O=d(k,T,"@context");if(a(O)||(k=await f({activeCtx:k,localCtx:O,propagate:!0,overrideProtected:!0,options:F})),n(L)){if(F.link&&"@id"in L&&F.link.hasOwnProperty(L["@id"])){const D=F.link[L["@id"]];for(let W=0;W<D.length;++W)if(D[W].expanded===L)return D[W].compacted}if(i(L)||l(L)){const D=x.compactValue({activeCtx:k,activeProperty:T,value:L,options:F});return F.link&&l(L)&&(F.link.hasOwnProperty(L["@id"])||(F.link[L["@id"]]=[]),F.link[L["@id"]].push({expanded:L,compacted:D})),D}if(o(L)&&(d(k,T,"@container")||[]).includes("@list"))return x.compact({activeCtx:k,activeProperty:T,element:L["@list"],options:F});const R=T==="@reverse",P={},K=k;!i(L)&&!l(L)&&(k=k.revertToPreviousContext());const U=d(K,T,"@context");a(U)||(k=await f({activeCtx:k,localCtx:U,propagate:!0,overrideProtected:!0,options:F})),F.link&&"@id"in L&&(F.link.hasOwnProperty(L["@id"])||(F.link[L["@id"]]=[]),F.link[L["@id"]].push({expanded:L,compacted:P}));let V=L["@type"]||[];V.length>1&&(V=Array.from(V).sort());const C=k;for(const D of V){const W=x.compactIri({activeCtx:C,iri:D,relativeTo:{vocab:!0}}),J=d(K,W,"@context");a(J)||(k=await f({activeCtx:k,localCtx:J,options:F,propagate:!1}))}const H=Object.keys(L).sort();for(const D of H){const W=L[D];if(D==="@id"){let J=b(W).map(se=>x.compactIri({activeCtx:k,iri:se,relativeTo:{vocab:!1},base:F.base}));J.length===1&&(J=J[0]);const re=x.compactIri({activeCtx:k,iri:"@id",relativeTo:{vocab:!0}});P[re]=J;continue}if(D==="@type"){let J=b(W).map(Y=>x.compactIri({activeCtx:K,iri:Y,relativeTo:{vocab:!0}}));J.length===1&&(J=J[0]);const re=x.compactIri({activeCtx:k,iri:"@type",relativeTo:{vocab:!0}}),X=(d(k,re,"@container")||[]).includes("@set")&&y(k,1.1)||t(J)&&W.length===0;I(P,re,J,{propertyIsArray:X});continue}if(D==="@reverse"){const J=await x.compact({activeCtx:k,activeProperty:"@reverse",element:W,options:F});for(const re in J)if(k.mappings.has(re)&&k.mappings.get(re).reverse){const se=J[re],X=(d(k,re,"@container")||[]).includes("@set")||!F.compactArrays;I(P,re,se,{propertyIsArray:X}),delete J[re]}if(Object.keys(J).length>0){const re=x.compactIri({activeCtx:k,iri:D,relativeTo:{vocab:!0}});I(P,re,J)}continue}if(D==="@preserve"){const J=await x.compact({activeCtx:k,activeProperty:T,element:W,options:F});t(J)&&J.length===0||I(P,D,J);continue}if(D==="@index"){if((d(k,T,"@container")||[]).includes("@index"))continue;const re=x.compactIri({activeCtx:k,iri:D,relativeTo:{vocab:!0}});I(P,re,W);continue}if(D!=="@graph"&&D!=="@list"&&D!=="@included"&&h(D)){const J=x.compactIri({activeCtx:k,iri:D,relativeTo:{vocab:!0}});I(P,J,W);continue}if(!t(W))throw new e("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(W.length===0){const J=x.compactIri({activeCtx:k,iri:D,value:W,relativeTo:{vocab:!0},reverse:R}),re=k.mappings.has(J)?k.mappings.get(J)["@nest"]:null;let se=P;re&&(N(k,re,F),n(P[re])||(P[re]={}),se=P[re]),I(se,J,W,{propertyIsArray:!0})}for(const J of W){const re=x.compactIri({activeCtx:k,iri:D,value:J,relativeTo:{vocab:!0},reverse:R}),se=k.mappings.has(re)?k.mappings.get(re)["@nest"]:null;let z=P;se&&(N(k,se,F),n(P[se])||(P[se]={}),z=P[se]);const X=d(k,re,"@container")||[],Y=s(J),ae=o(J);let ce;ae?ce=J["@list"]:Y&&(ce=J["@graph"]);let oe=await x.compact({activeCtx:k,activeProperty:re,element:ae||Y?ce:J,options:F});if(ae)if(t(oe)||(oe=[oe]),!X.includes("@list"))oe={[x.compactIri({activeCtx:k,iri:"@list",relativeTo:{vocab:!0}})]:oe},"@index"in J&&(oe[x.compactIri({activeCtx:k,iri:"@index",relativeTo:{vocab:!0}})]=J["@index"]);else{I(z,re,oe,{valueIsArray:!0,allowDuplicate:!0});continue}if(Y)if(X.includes("@graph")&&(X.includes("@id")||X.includes("@index")&&c(J))){let de;z.hasOwnProperty(re)?de=z[re]:z[re]=de={};const pe=(X.includes("@id")?J["@id"]:J["@index"])||x.compactIri({activeCtx:k,iri:"@none",relativeTo:{vocab:!0}});I(de,pe,oe,{propertyIsArray:!F.compactArrays||X.includes("@set")})}else X.includes("@graph")&&c(J)?(t(oe)&&oe.length>1&&(oe={"@included":oe}),I(z,re,oe,{propertyIsArray:!F.compactArrays||X.includes("@set")})):(t(oe)&&oe.length===1&&F.compactArrays&&(oe=oe[0]),oe={[x.compactIri({activeCtx:k,iri:"@graph",relativeTo:{vocab:!0}})]:oe},"@id"in J&&(oe[x.compactIri({activeCtx:k,iri:"@id",relativeTo:{vocab:!0}})]=J["@id"]),"@index"in J&&(oe[x.compactIri({activeCtx:k,iri:"@index",relativeTo:{vocab:!0}})]=J["@index"]),I(z,re,oe,{propertyIsArray:!F.compactArrays||X.includes("@set")}));else if(X.includes("@language")||X.includes("@index")||X.includes("@id")||X.includes("@type")){let de;z.hasOwnProperty(re)?de=z[re]:z[re]=de={};let pe;if(X.includes("@language"))i(oe)&&(oe=oe["@value"]),pe=J["@language"];else if(X.includes("@index")){const fe=d(k,re,"@index")||"@index",ye=x.compactIri({activeCtx:k,iri:fe,relativeTo:{vocab:!0}});if(fe==="@index")pe=J["@index"],delete oe[ye];else{let Ie;if([pe,...Ie]=b(oe[fe]||[]),!r(pe))pe=null;else switch(Ie.length){case 0:delete oe[fe];break;case 1:oe[fe]=Ie[0];break;default:oe[fe]=Ie;break}}}else if(X.includes("@id")){const fe=x.compactIri({activeCtx:k,iri:"@id",relativeTo:{vocab:!0}});pe=oe[fe],delete oe[fe]}else if(X.includes("@type")){const fe=x.compactIri({activeCtx:k,iri:"@type",relativeTo:{vocab:!0}});let ye;switch([pe,...ye]=b(oe[fe]||[]),ye.length){case 0:delete oe[fe];break;case 1:oe[fe]=ye[0];break;default:oe[fe]=ye;break}Object.keys(oe).length===1&&"@id"in J&&(oe=await x.compact({activeCtx:k,activeProperty:re,element:{"@id":J["@id"]},options:F}))}pe||(pe=x.compactIri({activeCtx:k,iri:"@none",relativeTo:{vocab:!0}})),I(de,pe,oe,{propertyIsArray:X.includes("@set")})}else{const de=!F.compactArrays||X.includes("@set")||X.includes("@list")||t(oe)&&oe.length===0||D==="@list"||D==="@graph";I(z,re,oe,{propertyIsArray:de})}}}return P}return L},x.compactIri=({activeCtx:k,iri:T,value:L=null,relativeTo:F={vocab:!1},reverse:O=!1,base:R=null})=>{if(T===null)return T;k.isPropertyTermScoped&&k.previousContext&&(k=k.previousContext);const P=k.getInverse();if(h(T)&&T in P&&"@none"in P[T]&&"@type"in P[T]["@none"]&&"@none"in P[T]["@none"]["@type"])return P[T]["@none"]["@type"]["@none"];if(F.vocab&&T in P){const H=k["@language"]||"@none",D=[];n(L)&&"@index"in L&&!("@graph"in L)&&D.push("@index","@index@set"),n(L)&&"@preserve"in L&&(L=L["@preserve"][0]),s(L)?("@index"in L&&D.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in L&&D.push("@graph@id","@graph@id@set"),D.push("@graph","@graph@set","@set"),"@index"in L||D.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in L||D.push("@graph@id","@graph@id@set")):n(L)&&!i(L)&&D.push("@id","@id@set","@type","@set@type");let W="@language",J="@null";if(O)W="@type",J="@reverse",D.push("@set");else if(o(L)){"@index"in L||D.push("@list");const se=L["@list"];if(se.length===0)W="@any",J="@none";else{let z=se.length===0?H:null,X=null;for(let Y=0;Y<se.length;++Y){const ae=se[Y];let ce="@none",oe="@none";if(i(ae))if("@direction"in ae){const de=(ae["@language"]||"").toLowerCase(),pe=ae["@direction"];ce=`${de}_${pe}`}else"@language"in ae?ce=ae["@language"].toLowerCase():"@type"in ae?oe=ae["@type"]:ce="@null";else oe="@id";if(z===null?z=ce:ce!==z&&i(ae)&&(z="@none"),X===null?X=oe:oe!==X&&(X="@none"),z==="@none"&&X==="@none")break}z=z||"@none",X=X||"@none",X!=="@none"?(W="@type",J=X):J=z}}else{if(i(L))if("@language"in L&&!("@index"in L)){D.push("@language","@language@set"),J=L["@language"];const se=L["@direction"];se&&(J=`${J}_${se}`)}else"@direction"in L&&!("@index"in L)?J=`_${L["@direction"]}`:"@type"in L&&(W="@type",J=L["@type"]);else W="@type",J="@id";D.push("@set")}D.push("@none"),n(L)&&!("@index"in L)&&D.push("@index","@index@set"),i(L)&&Object.keys(L).length===1&&D.push("@language","@language@set");const re=_(k,T,L,D,W,J);if(re!==null)return re}if(F.vocab&&"@vocab"in k){const H=k["@vocab"];if(T.indexOf(H)===0&&T!==H){const D=T.substr(H.length);if(!k.mappings.has(D))return D}}let K=null;const U=[];let V=k.fastCurieMap;const C=T.length-1;for(let H=0;H<C&&T[H]in V;++H)V=V[T[H]],""in V&&U.push(V[""][0]);for(let H=U.length-1;H>=0;--H){const D=U[H],W=D.terms;for(const J of W){const re=J+":"+T.substr(D.iri.length);k.mappings.get(J)._prefix&&(!k.mappings.has(re)||L===null&&k.mappings.get(re)["@id"]===T)&&(K===null||w(re,K)<0)&&(K=re)}}if(K!==null)return K;for(const[H,D]of k.mappings)if(D&&D._prefix&&T.startsWith(H+":"))throw new e(`Absolute IRI "${T}" confused with prefix "${H}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:k});if(!F.vocab)if("@base"in k)if(k["@base"]){const H=g(S(R,k["@base"]),T);return B.test(H)?`./${H}`:H}else return T;else return g(R,T);return T},x.compactValue=({activeCtx:k,activeProperty:T,value:L,options:F})=>{if(i(L)){const K=d(k,T,"@type"),U=d(k,T,"@language"),V=d(k,T,"@direction"),C=d(k,T,"@container")||[],H="@index"in L&&!C.includes("@index");if(!H&&K!=="@none"&&(L["@type"]===K||"@language"in L&&L["@language"]===U&&"@direction"in L&&L["@direction"]===V||"@language"in L&&L["@language"]===U||"@direction"in L&&L["@direction"]===V))return L["@value"];const D=Object.keys(L).length,W=D===1||D===2&&"@index"in L&&!H,J="@language"in k,re=r(L["@value"]),se=k.mappings.has(T)&&k.mappings.get(T)["@language"]===null;if(W&&K!=="@none"&&(!J||!re||se))return L["@value"];const z={};return H&&(z[x.compactIri({activeCtx:k,iri:"@index",relativeTo:{vocab:!0}})]=L["@index"]),"@type"in L?z[x.compactIri({activeCtx:k,iri:"@type",relativeTo:{vocab:!0}})]=x.compactIri({activeCtx:k,iri:L["@type"],relativeTo:{vocab:!0}}):"@language"in L&&(z[x.compactIri({activeCtx:k,iri:"@language",relativeTo:{vocab:!0}})]=L["@language"]),"@direction"in L&&(z[x.compactIri({activeCtx:k,iri:"@direction",relativeTo:{vocab:!0}})]=L["@direction"]),z[x.compactIri({activeCtx:k,iri:"@value",relativeTo:{vocab:!0}})]=L["@value"],z}const O=u(k,T,{vocab:!0},F),R=d(k,T,"@type"),P=x.compactIri({activeCtx:k,iri:L["@id"],relativeTo:{vocab:R==="@vocab"},base:F.base});return R==="@id"||R==="@vocab"||O==="@graph"?P:{[x.compactIri({activeCtx:k,iri:"@id",relativeTo:{vocab:!0}})]:P}};function _(k,T,L,F,O,R){R===null&&(R="@null");const P=[];if((R==="@id"||R==="@reverse")&&n(L)&&"@id"in L){R==="@reverse"&&P.push("@reverse");const U=x.compactIri({activeCtx:k,iri:L["@id"],relativeTo:{vocab:!0}});k.mappings.has(U)&&k.mappings.get(U)&&k.mappings.get(U)["@id"]===L["@id"]?P.push.apply(P,["@vocab","@id"]):P.push.apply(P,["@id","@vocab"])}else{P.push(R);const U=P.find(V=>V.includes("_"));U&&P.push(U.replace(/^[^_]+_/,"_"))}P.push("@none");const K=k.inverse[T];for(const U of F){if(!(U in K))continue;const V=K[U][O];for(const C of P)if(C in V)return V[C]}return null}function N(k,T,L){if(u(k,T,{vocab:!0},L)!=="@nest")throw new e("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}return ts}var rs,ou;function zy(){return ou||(ou=1,rs=e=>{class t{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(t,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(t.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:t}),t.compact=function(n,r){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):e.compact(n,r)},t.expand=function(n){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):e.expand(n)},t.flatten=function(n){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):e.flatten(n)},t}),rs}var ns,su;function Jy(){if(su)return ns;su=1;const e=ma(),t=Dy(),n=ft(),r=Cy(),a=n.IdentifierIssuer,o=lt(),i=Pd(),s=jy(),{expand:c}=qy(),{flatten:l}=Ky(),{fromRDF:u}=Vy(),{toRDF:d}=Wy(),{frameMergedOrDefault:h,cleanupNull:f}=$y(),{isArray:y,isObject:g,isString:S}=ot(),{isSubjectReference:B}=Gt(),{expandIri:I,getInitialContext:b,process:w,processingMode:x}=Xr(),{compact:_,compactIri:N}=Xy(),{createNodeMap:k,createMergedNodeMap:T,mergeNodeMaps:L}=Vi(),{logEventHandler:F,logWarningEventHandler:O,safeEventHandler:R,setDefaultEventHandler:P,setupEventHandler:K,strictEventHandler:U,unhandledEventHandler:V}=$n(),C=function(D){const W={},re=new i({max:100});D.compact=async function(z,X,Y){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(X===null)throw new o("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(z===null)return null;Y=se(Y,{base:S(z)?z:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new a("_:b"),contextResolver:new r({sharedCache:re})}),Y.link&&(Y.skipExpansion=!0),Y.compactToRelative||delete Y.base;let ae;Y.skipExpansion?ae=z:ae=await D.expand(z,Y);const ce=await D.processContext(b(Y),X,Y);let oe=await _({activeCtx:ce,element:ae,options:Y});Y.compactArrays&&!Y.graph&&y(oe)?oe.length===1?oe=oe[0]:oe.length===0&&(oe={}):Y.graph&&g(oe)&&(oe=[oe]),g(X)&&"@context"in X&&(X=X["@context"]),X=n.clone(X),y(X)||(X=[X]);const de=X;X=[];for(let fe=0;fe<de.length;++fe)(!g(de[fe])||Object.keys(de[fe]).length>0)&&X.push(de[fe]);const pe=X.length>0;if(X.length===1&&(X=X[0]),y(oe)){const fe=N({activeCtx:ce,iri:"@graph",relativeTo:{vocab:!0}}),ye=oe;oe={},pe&&(oe["@context"]=X),oe[fe]=ye}else if(g(oe)&&pe){const fe=oe;oe={"@context":X};for(const ye in fe)oe[ye]=fe[ye]}return oe},D.expand=async function(z,X){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");X=se(X,{keepFreeFloatingNodes:!1,contextResolver:new r({sharedCache:re})});const Y={},ae=[];if("expandContext"in X){const pe=n.clone(X.expandContext);g(pe)&&"@context"in pe?Y.expandContext=pe:Y.expandContext={"@context":pe},ae.push(Y.expandContext)}let ce;if(!S(z))Y.input=n.clone(z);else{const pe=await D.get(z,X);ce=pe.documentUrl,Y.input=pe.document,pe.contextUrl&&(Y.remoteContext={"@context":pe.contextUrl},ae.push(Y.remoteContext))}"base"in X||(X.base=ce||"");let oe=b(X);for(const pe of ae)oe=await w({activeCtx:oe,localCtx:pe,options:X});let de=await c({activeCtx:oe,element:Y.input,options:X});return g(de)&&"@graph"in de&&Object.keys(de).length===1?de=de["@graph"]:de===null&&(de=[]),y(de)||(de=[de]),de},D.flatten=async function(z,X,Y){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof X=="function"?X=null:X=X||null,Y=se(Y,{base:S(z)?z:"",contextResolver:new r({sharedCache:re})});const ae=await D.expand(z,Y),ce=l(ae);return X===null?ce:(Y.graph=!0,Y.skipExpansion=!0,await D.compact(ce,X,Y))},D.frame=async function(z,X,Y){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(Y=se(Y,{base:S(z)?z:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new r({sharedCache:re})}),S(X)){const xe=await D.get(X,Y);if(X=xe.document,xe.contextUrl){let _e=X["@context"];_e?y(_e)?_e.push(xe.contextUrl):_e=[_e,xe.contextUrl]:_e=xe.contextUrl,X["@context"]=_e}}const ae=X?X["@context"]||{}:{},ce=await D.processContext(b(Y),ae,Y);Y.hasOwnProperty("omitGraph")||(Y.omitGraph=x(ce,1.1)),Y.hasOwnProperty("pruneBlankNodeIdentifiers")||(Y.pruneBlankNodeIdentifiers=x(ce,1.1));const oe=await D.expand(z,Y),de={...Y};de.isFrame=!0,de.keepFreeFloatingNodes=!0;const pe=await D.expand(X,de),fe=Object.keys(X).map(xe=>I(ce,xe,{vocab:!0}));de.merged=!fe.includes("@graph"),de.is11=x(ce,1.1);const ye=h(oe,pe,de);de.graph=!Y.omitGraph,de.skipExpansion=!0,de.link={},de.framing=!0;let Ie=await D.compact(ye,ae,de);return de.link={},Ie=f(Ie,de),Ie},D.link=async function(z,X,Y){const ae={};return X&&(ae["@context"]=X),ae["@embed"]="@link",D.frame(z,ae,Y)},D.normalize=D.canonize=async function(z,X){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if(X=se(X,{base:S(z)?z:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new r({sharedCache:re})}),"inputFormat"in X){if(X.inputFormat!=="application/n-quads"&&X.inputFormat!=="application/nquads")throw new o("Unknown canonicalization input format.","jsonld.CanonizeError");const ce=s.parse(z);return e.canonize(ce,X)}const Y={...X};delete Y.format,Y.produceGeneralizedRdf=!1;const ae=await D.toRDF(z,Y);return e.canonize(ae,X)},D.fromRDF=async function(z,X){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");X=se(X,{format:S(z)?"application/n-quads":void 0});const{format:Y}=X;let{rdfParser:ae}=X;if(Y){if(ae=ae||W[Y],!ae)throw new o("Unknown input format.","jsonld.UnknownFormat",{format:Y})}else ae=()=>z;const ce=await ae(z);return u(ce,X)},D.toRDF=async function(z,X){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");X=se(X,{base:S(z)?z:"",skipExpansion:!1,contextResolver:new r({sharedCache:re})});let Y;X.skipExpansion?Y=z:Y=await D.expand(z,X);const ae=d(Y,X);if(X.format){if(X.format==="application/n-quads"||X.format==="application/nquads")return s.serialize(ae);throw new o("Unknown output format.","jsonld.UnknownFormat",{format:X.format})}return ae},D.createNodeMap=async function(z,X){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");X=se(X,{base:S(z)?z:"",contextResolver:new r({sharedCache:re})});const Y=await D.expand(z,X);return T(Y,X)},D.merge=async function(z,X,Y){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!y(z))throw new TypeError('Could not merge, "docs" must be an array.');typeof X=="function"?X=null:X=X||null,Y=se(Y,{contextResolver:new r({sharedCache:re})});const ae=await Promise.all(z.map(xe=>{const _e={...Y};return D.expand(xe,_e)}));let ce=!0;"mergeNodes"in Y&&(ce=Y.mergeNodes);const oe=Y.issuer||new a("_:b"),de={"@default":{}};for(let xe=0;xe<ae.length;++xe){const _e=n.relabelBlankNodes(ae[xe],{issuer:new a("_:b"+xe+"-")}),mt=ce||xe===0?de:{"@default":{}};if(k(_e,mt,"@default",oe),mt!==de)for(const bt in mt){const dt=mt[bt];if(!(bt in de)){de[bt]=dt;continue}const $t=de[bt];for(const Te in dt)Te in $t||($t[Te]=dt[Te])}}const pe=L(de),fe=[],ye=Object.keys(pe).sort();for(let xe=0;xe<ye.length;++xe){const _e=pe[ye[xe]];B(_e)||fe.push(_e)}return X===null?fe:(Y.graph=!0,Y.skipExpansion=!0,await D.compact(fe,X,Y))},Object.defineProperty(D,"documentLoader",{get:()=>D._documentLoader,set:z=>D._documentLoader=z}),D.documentLoader=async z=>{throw new o("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:z})},D.get=async function(z,X){let Y;typeof X.documentLoader=="function"?Y=X.documentLoader:Y=D.documentLoader;const ae=await Y(z);try{if(!ae.document)throw new o("No remote document found at the given URL.","jsonld.NullRemoteDocument");S(ae.document)&&(ae.document=JSON.parse(ae.document))}catch(ce){throw new o("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:ce,remoteDoc:ae})}return ae},D.processContext=async function(z,X,Y){return Y=se(Y,{base:"",contextResolver:new r({sharedCache:re})}),X===null?b(Y):(X=n.clone(X),g(X)&&"@context"in X||(X={"@context":X}),w({activeCtx:z,localCtx:X,options:Y}))},D.getContextValue=Xr().getContextValue,D.documentLoaders={},D.useDocumentLoader=function(z){if(!(z in D.documentLoaders))throw new o('Unknown document loader type: "'+z+'"',"jsonld.UnknownDocumentLoader",{type:z});D.documentLoader=D.documentLoaders[z].apply(D,Array.prototype.slice.call(arguments,1))},D.registerRDFParser=function(z,X){W[z]=X},D.unregisterRDFParser=function(z){delete W[z]},D.registerRDFParser("application/n-quads",s.parse),D.registerRDFParser("application/nquads",s.parse),D.url=Sr(),D.logEventHandler=F,D.logWarningEventHandler=O,D.safeEventHandler=R,D.setDefaultEventHandler=P,D.strictEventHandler=U,D.unhandledEventHandler=V,D.util=n,Object.assign(D,n),D.promises=D,D.RequestQueue=Rd(),D.JsonLdProcessor=zy()(D),t.setupGlobals(D),t.setupDocumentLoaders(D);function se(z,{documentLoader:X=D.documentLoader,...Y}){if(z&&"compactionMap"in z)throw new o('"compactionMap" not supported.',"jsonld.OptionsError");if(z&&"expansionMap"in z)throw new o('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:X},Y,z,{eventHandler:K({options:z})})}return D},H=function(){return C(function(){return H()})};return C(H),ns=H,ns}Jy();var is={},Je={},Dt={},au;function wt(){return au||(au=1,Object.defineProperty(Dt,"__esModule",{value:!0}),Dt.testnet=Dt.regtest=Dt.bitcoin=void 0,Dt.bitcoin={messagePrefix:`Bitcoin Signed Message:
`,bech32:"bc",bip32:{public:76067358,private:76066276},pubKeyHash:0,scriptHash:5,wif:128},Dt.regtest={messagePrefix:`Bitcoin Signed Message:
`,bech32:"bcrt",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239},Dt.testnet={messagePrefix:`Bitcoin Signed Message:
`,bech32:"tb",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239}),Dt}var os={},In={},ss={},Nt={},cu;function Ud(){if(cu)return Nt;cu=1,Object.defineProperty(Nt,"__esModule",{value:!0}),Nt.encode=Nt.decode=Nt.check=void 0;function e(r){if(r.length<8||r.length>72||r[0]!==48||r[1]!==r.length-2||r[2]!==2)return!1;const a=r[3];if(a===0||5+a>=r.length||r[4+a]!==2)return!1;const o=r[5+a];return!(o===0||6+a+o!==r.length||r[4]&128||a>1&&r[4]===0&&!(r[5]&128)||r[a+6]&128||o>1&&r[a+6]===0&&!(r[a+7]&128))}Nt.check=e;function t(r){if(r.length<8)throw new Error("DER sequence length is too short");if(r.length>72)throw new Error("DER sequence length is too long");if(r[0]!==48)throw new Error("Expected DER sequence");if(r[1]!==r.length-2)throw new Error("DER sequence length is invalid");if(r[2]!==2)throw new Error("Expected DER integer");const a=r[3];if(a===0)throw new Error("R length is zero");if(5+a>=r.length)throw new Error("R length is too long");if(r[4+a]!==2)throw new Error("Expected DER integer (2)");const o=r[5+a];if(o===0)throw new Error("S length is zero");if(6+a+o!==r.length)throw new Error("S length is invalid");if(r[4]&128)throw new Error("R value is negative");if(a>1&&r[4]===0&&!(r[5]&128))throw new Error("R value excessively padded");if(r[a+6]&128)throw new Error("S value is negative");if(o>1&&r[a+6]===0&&!(r[a+7]&128))throw new Error("S value excessively padded");return{r:r.slice(4,4+a),s:r.slice(6+a)}}Nt.decode=t;function n(r,a){const o=r.length,i=a.length;if(o===0)throw new Error("R length is zero");if(i===0)throw new Error("S length is zero");if(o>33)throw new Error("R length is too long");if(i>33)throw new Error("S length is too long");if(r[0]&128)throw new Error("R value is negative");if(a[0]&128)throw new Error("S value is negative");if(o>1&&r[0]===0&&!(r[1]&128))throw new Error("R value excessively padded");if(i>1&&a[0]===0&&!(a[1]&128))throw new Error("S value excessively padded");const s=te.allocUnsafe(6+o+i);return s[0]=48,s[1]=s.length-2,s[2]=2,s[3]=r.length,r.copy(s,4),s[4+o]=2,s[5+o]=a.length,a.copy(s,6+o),s}return Nt.encode=n,Nt}var Ar={},uu;function va(){if(uu)return Ar;uu=1,Object.defineProperty(Ar,"__esModule",{value:!0}),Ar.REVERSE_OPS=Ar.OPS=void 0;const e={OP_FALSE:0,OP_0:0,OP_PUSHDATA1:76,OP_PUSHDATA2:77,OP_PUSHDATA4:78,OP_1NEGATE:79,OP_RESERVED:80,OP_TRUE:81,OP_1:81,OP_2:82,OP_3:83,OP_4:84,OP_5:85,OP_6:86,OP_7:87,OP_8:88,OP_9:89,OP_10:90,OP_11:91,OP_12:92,OP_13:93,OP_14:94,OP_15:95,OP_16:96,OP_NOP:97,OP_VER:98,OP_IF:99,OP_NOTIF:100,OP_VERIF:101,OP_VERNOTIF:102,OP_ELSE:103,OP_ENDIF:104,OP_VERIFY:105,OP_RETURN:106,OP_TOALTSTACK:107,OP_FROMALTSTACK:108,OP_2DROP:109,OP_2DUP:110,OP_3DUP:111,OP_2OVER:112,OP_2ROT:113,OP_2SWAP:114,OP_IFDUP:115,OP_DEPTH:116,OP_DROP:117,OP_DUP:118,OP_NIP:119,OP_OVER:120,OP_PICK:121,OP_ROLL:122,OP_ROT:123,OP_SWAP:124,OP_TUCK:125,OP_CAT:126,OP_SUBSTR:127,OP_LEFT:128,OP_RIGHT:129,OP_SIZE:130,OP_INVERT:131,OP_AND:132,OP_OR:133,OP_XOR:134,OP_EQUAL:135,OP_EQUALVERIFY:136,OP_RESERVED1:137,OP_RESERVED2:138,OP_1ADD:139,OP_1SUB:140,OP_2MUL:141,OP_2DIV:142,OP_NEGATE:143,OP_ABS:144,OP_NOT:145,OP_0NOTEQUAL:146,OP_ADD:147,OP_SUB:148,OP_MUL:149,OP_DIV:150,OP_MOD:151,OP_LSHIFT:152,OP_RSHIFT:153,OP_BOOLAND:154,OP_BOOLOR:155,OP_NUMEQUAL:156,OP_NUMEQUALVERIFY:157,OP_NUMNOTEQUAL:158,OP_LESSTHAN:159,OP_GREATERTHAN:160,OP_LESSTHANOREQUAL:161,OP_GREATERTHANOREQUAL:162,OP_MIN:163,OP_MAX:164,OP_WITHIN:165,OP_RIPEMD160:166,OP_SHA1:167,OP_SHA256:168,OP_HASH160:169,OP_HASH256:170,OP_CODESEPARATOR:171,OP_CHECKSIG:172,OP_CHECKSIGVERIFY:173,OP_CHECKMULTISIG:174,OP_CHECKMULTISIGVERIFY:175,OP_NOP1:176,OP_NOP2:177,OP_CHECKLOCKTIMEVERIFY:177,OP_NOP3:178,OP_CHECKSEQUENCEVERIFY:178,OP_NOP4:179,OP_NOP5:180,OP_NOP6:181,OP_NOP7:182,OP_NOP8:183,OP_NOP9:184,OP_NOP10:185,OP_CHECKSIGADD:186,OP_PUBKEYHASH:253,OP_PUBKEY:254,OP_INVALIDOPCODE:255};Ar.OPS=e;const t={};Ar.REVERSE_OPS=t;for(const n of Object.keys(e)){const r=e[n];t[r]=n}return Ar}var Ft={},fu;function Yy(){if(fu)return Ft;fu=1,Object.defineProperty(Ft,"__esModule",{value:!0}),Ft.decode=Ft.encode=Ft.encodingLength=void 0;const e=va();function t(a){return a<e.OPS.OP_PUSHDATA1?1:a<=255?2:a<=65535?3:5}Ft.encodingLength=t;function n(a,o,i){const s=t(o);return s===1?a.writeUInt8(o,i):s===2?(a.writeUInt8(e.OPS.OP_PUSHDATA1,i),a.writeUInt8(o,i+1)):s===3?(a.writeUInt8(e.OPS.OP_PUSHDATA2,i),a.writeUInt16LE(o,i+1)):(a.writeUInt8(e.OPS.OP_PUSHDATA4,i),a.writeUInt32LE(o,i+1)),s}Ft.encode=n;function r(a,o){const i=a.readUInt8(o);let s,c;if(i<e.OPS.OP_PUSHDATA1)s=i,c=1;else if(i===e.OPS.OP_PUSHDATA1){if(o+2>a.length)return null;s=a.readUInt8(o+1),c=2}else if(i===e.OPS.OP_PUSHDATA2){if(o+3>a.length)return null;s=a.readUInt16LE(o+1),c=3}else{if(o+5>a.length)return null;if(i!==e.OPS.OP_PUSHDATA4)throw new Error("Unexpected opcode");s=a.readUInt32LE(o+1),c=5}return{opcode:i,number:s,size:c}}return Ft.decode=r,Ft}var Tr={},lu;function Zy(){if(lu)return Tr;lu=1,Object.defineProperty(Tr,"__esModule",{value:!0}),Tr.encode=Tr.decode=void 0;function e(r,a,o){a=a||4,o=o===void 0?!0:o;const i=r.length;if(i===0)return 0;if(i>a)throw new TypeError("Script number overflow");if(o&&(r[i-1]&127)===0&&(i<=1||(r[i-2]&128)===0))throw new Error("Non-minimally encoded script number");if(i===5){const c=r.readUInt32LE(0),l=r.readUInt8(4);return l&128?-((l&-129)*4294967296+c):l*4294967296+c}let s=0;for(let c=0;c<i;++c)s|=r[c]<<8*c;return r[i-1]&128?-(s&~(128<<8*(i-1))):s}Tr.decode=e;function t(r){return r>2147483647?5:r>8388607?4:r>32767?3:r>127?2:r>0?1:0}function n(r){let a=Math.abs(r);const o=t(a),i=te.allocUnsafe(o),s=r<0;for(let c=0;c<o;++c)i.writeUInt8(a&255,c),a>>=8;return i[o-1]&128?i.writeUInt8(s?128:0,o-1):s&&(i[o-1]|=128),i}return Tr.encode=n,Tr}var Br={},as={},cs,du;function Ea(){if(du)return cs;du=1;var e={Array:function(n){return n!=null&&n.constructor===Array},Boolean:function(n){return typeof n=="boolean"},Function:function(n){return typeof n=="function"},Nil:function(n){return n==null},Number:function(n){return typeof n=="number"},Object:function(n){return typeof n=="object"},String:function(n){return typeof n=="string"},"":function(){return!0}};e.Null=e.Nil;for(var t in e)e[t].toJSON=(function(n){return n}).bind(null,t);return cs=e,cs}var us,hu;function Hd(){if(hu)return us;hu=1;var e=Ea();function t(h){return h.name||h.toString().match(/function (.*?)\s*\(/)[1]}function n(h){return e.Nil(h)?"":t(h.constructor)}function r(h){return e.Function(h)?"":e.String(h)?JSON.stringify(h):h&&e.Object(h)?"":h}function a(h,f){Error.captureStackTrace&&Error.captureStackTrace(h,f)}function o(h){return e.Function(h)?h.toJSON?h.toJSON():t(h):e.Array(h)?"Array":h&&e.Object(h)?"Object":h!==void 0?h:""}function i(h,f,y){var g=r(f);return"Expected "+o(h)+", got"+(y!==""?" "+y:"")+(g!==""?" "+g:"")}function s(h,f,y){y=y||n(f),this.message=i(h,f,y),a(this,s),this.__type=h,this.__value=f,this.__valueTypeName=y}s.prototype=Object.create(Error.prototype),s.prototype.constructor=s;function c(h,f,y,g,S){var B='" of type ';return f==="key"&&(B='" with key type '),i('property "'+o(y)+B+o(h),g,S)}function l(h,f,y,g,S){h?(S=S||n(g),this.message=c(h,y,f,g,S)):this.message='Unexpected property "'+f+'"',a(this,s),this.__label=y,this.__property=f,this.__type=h,this.__value=g,this.__valueTypeName=S}l.prototype=Object.create(Error.prototype),l.prototype.constructor=s;function u(h,f){return new s(h,{},f)}function d(h,f,y){return h instanceof l?(f=f+"."+h.__property,h=new l(h.__type,f,h.__label,h.__value,h.__valueTypeName)):h instanceof s&&(h=new l(h.__type,f,y,h.__value,h.__valueTypeName)),a(h),h}return us={TfTypeError:s,TfPropertyTypeError:l,tfCustomError:u,tfSubError:d,tfJSON:o,getValueTypeName:n},us}var fs,pu;function Qy(){if(pu)return fs;pu=1;var e=Ea(),t=Hd();function n(_){return te.isBuffer(_)}function r(_){return typeof _=="string"&&/^([0-9a-f]{2})+$/i.test(_)}function a(_,N){var k=_.toJSON();function T(L){if(!_(L))return!1;if(L.length===N)return!0;throw t.tfCustomError(k+"(Length: "+N+")",k+"(Length: "+L.length+")")}return T.toJSON=function(){return k},T}var o=a.bind(null,e.Array),i=a.bind(null,n),s=a.bind(null,r),c=a.bind(null,e.String);function l(_,N,k){k=k||e.Number;function T(L,F){return k(L,F)&&L>_&&L<N}return T.toJSON=function(){return`${k.toJSON()} between [${_}, ${N}]`},T}var u=Math.pow(2,53)-1;function d(_){return typeof _=="number"&&isFinite(_)}function h(_){return _<<24>>24===_}function f(_){return _<<16>>16===_}function y(_){return(_|0)===_}function g(_){return typeof _=="number"&&_>=-u&&_<=u&&Math.floor(_)===_}function S(_){return(_&255)===_}function B(_){return(_&65535)===_}function I(_){return _>>>0===_}function b(_){return typeof _=="number"&&_>=0&&_<=u&&Math.floor(_)===_}var w={ArrayN:o,Buffer:n,BufferN:i,Finite:d,Hex:r,HexN:s,Int8:h,Int16:f,Int32:y,Int53:g,Range:l,StringN:c,UInt8:S,UInt16:B,UInt32:I,UInt53:b};for(var x in w)w[x].toJSON=(function(_){return _}).bind(null,x);return fs=w,fs}var ls,yu;function eg(){if(yu)return ls;yu=1;var e=Hd(),t=Ea(),n=e.tfJSON,r=e.TfTypeError,a=e.TfPropertyTypeError,o=e.tfSubError,i=e.getValueTypeName,s={arrayOf:function(f,y){f=c(f),y=y||{};function g(S,B){return!t.Array(S)||t.Nil(S)||y.minLength!==void 0&&S.length<y.minLength||y.maxLength!==void 0&&S.length>y.maxLength||y.length!==void 0&&S.length!==y.length?!1:S.every(function(I,b){try{return l(f,I,B)}catch(w){throw o(w,b)}})}return g.toJSON=function(){var S="["+n(f)+"]";return y.length!==void 0?S+="{"+y.length+"}":(y.minLength!==void 0||y.maxLength!==void 0)&&(S+="{"+(y.minLength===void 0?0:y.minLength)+","+(y.maxLength===void 0?1/0:y.maxLength)+"}"),S},g},maybe:function h(f){f=c(f);function y(g,S){return t.Nil(g)||f(g,S,h)}return y.toJSON=function(){return"?"+n(f)},y},map:function(f,y){f=c(f),y&&(y=c(y));function g(S,B){if(!t.Object(S)||t.Nil(S))return!1;for(var I in S){try{y&&l(y,I,B)}catch(w){throw o(w,I,"key")}try{var b=S[I];l(f,b,B)}catch(w){throw o(w,I)}}return!0}return y?g.toJSON=function(){return"{"+n(y)+": "+n(f)+"}"}:g.toJSON=function(){return"{"+n(f)+"}"},g},object:function(f){var y={};for(var g in f)y[g]=c(f[g]);function S(B,I){if(!t.Object(B)||t.Nil(B))return!1;var b;try{for(b in y){var w=y[b],x=B[b];l(w,x,I)}}catch(_){throw o(_,b)}if(I){for(b in B)if(!y[b])throw new a(void 0,b)}return!0}return S.toJSON=function(){return n(y)},S},anyOf:function(){var f=[].slice.call(arguments).map(c);function y(g,S){return f.some(function(B){try{return l(B,g,S)}catch{return!1}})}return y.toJSON=function(){return f.map(n).join("|")},y},allOf:function(){var f=[].slice.call(arguments).map(c);function y(g,S){return f.every(function(B){try{return l(B,g,S)}catch{return!1}})}return y.toJSON=function(){return f.map(n).join(" & ")},y},quacksLike:function(f){function y(g){return f===i(g)}return y.toJSON=function(){return f},y},tuple:function(){var f=[].slice.call(arguments).map(c);function y(g,S){return t.Nil(g)||t.Nil(g.length)||S&&g.length!==f.length?!1:f.every(function(B,I){try{return l(B,g[I],S)}catch(b){throw o(b,I)}})}return y.toJSON=function(){return"("+f.map(n).join(", ")+")"},y},value:function(f){function y(g){return g===f}return y.toJSON=function(){return f},y}};s.oneOf=s.anyOf;function c(h){if(t.String(h))return h[0]==="?"?s.maybe(h.slice(1)):t[h]||s.quacksLike(h);if(h&&t.Object(h)){if(t.Array(h)){if(h.length!==1)throw new TypeError("Expected compile() parameter of type Array of length 1");return s.arrayOf(h[0])}return s.object(h)}else if(t.Function(h))return h;return s.value(h)}function l(h,f,y,g){if(t.Function(h)){if(h(f,y))return!0;throw new r(g||h,f)}return l(c(h),f,y)}for(var u in t)l[u]=t[u];for(u in s)l[u]=s[u];var d=Qy();for(u in d)l[u]=d[u];return l.compile=c,l.TfTypeError=r,l.TfPropertyTypeError=a,ls=l,ls}var gu;function ze(){return gu||(gu=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.oneOf=e.Null=e.BufferN=e.Function=e.UInt32=e.UInt8=e.tuple=e.maybe=e.Hex=e.Buffer=e.String=e.Boolean=e.Array=e.Number=e.Hash256bit=e.Hash160bit=e.Buffer256bit=e.isTaptree=e.isTapleaf=e.TAPLEAF_VERSION_MASK=e.Satoshi=e.isPoint=e.stacksEqual=e.typeforce=void 0;const t=Ci();e.typeforce=eg();const n=t.Buffer.alloc(32,0),r=t.Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f","hex");function a(u,d){return u.length!==d.length?!1:u.every((h,f)=>h.equals(d[f]))}e.stacksEqual=a;function o(u){if(!t.Buffer.isBuffer(u)||u.length<33)return!1;const d=u[0],h=u.slice(1,33);if(h.compare(n)===0||h.compare(r)>=0)return!1;if((d===2||d===3)&&u.length===33)return!0;const f=u.slice(33);return f.compare(n)===0||f.compare(r)>=0?!1:d===4&&u.length===65}e.isPoint=o;const i=21*1e14;function s(u){return e.typeforce.UInt53(u)&&u<=i}e.Satoshi=s,e.TAPLEAF_VERSION_MASK=254;function c(u){return!u||!("output"in u)||!t.Buffer.isBuffer(u.output)?!1:u.version!==void 0?(u.version&e.TAPLEAF_VERSION_MASK)===u.version:!0}e.isTapleaf=c;function l(u){return(0,e.Array)(u)?u.length!==2?!1:u.every(d=>l(d)):c(u)}e.isTaptree=l,e.Buffer256bit=e.typeforce.BufferN(32),e.Hash160bit=e.typeforce.BufferN(20),e.Hash256bit=e.typeforce.BufferN(32),e.Number=e.typeforce.Number,e.Array=e.typeforce.Array,e.Boolean=e.typeforce.Boolean,e.String=e.typeforce.String,e.Buffer=e.typeforce.Buffer,e.Hex=e.typeforce.Hex,e.maybe=e.typeforce.maybe,e.tuple=e.typeforce.tuple,e.UInt8=e.typeforce.UInt8,e.UInt32=e.typeforce.UInt32,e.Function=e.typeforce.Function,e.BufferN=e.typeforce.BufferN,e.Null=e.typeforce.Null,e.oneOf=e.typeforce.oneOf})(as)),as}var wu;function tg(){if(wu)return Br;wu=1,Object.defineProperty(Br,"__esModule",{value:!0}),Br.encode=Br.decode=void 0;const e=Ud(),t=et(),n=ze(),{typeforce:r}=n,a=te.alloc(1,0);function o(l){let u=0;for(;l[u]===0;)++u;return u===l.length?a:(l=l.slice(u),l[0]&128?te.concat([a,l],1+l.length):l)}function i(l){l[0]===0&&(l=l.slice(1));const u=te.alloc(32,0),d=Math.max(0,32-l.length);return l.copy(u,d),u}function s(l){const u=l.readUInt8(l.length-1);if(!(0,t.isDefinedHashType)(u))throw new Error("Invalid hashType "+u);const d=e.decode(l.slice(0,-1)),h=i(d.r),f=i(d.s);return{signature:te.concat([h,f],64),hashType:u}}Br.decode=s;function c(l,u){if(r({signature:n.BufferN(64),hashType:n.UInt8},{signature:l,hashType:u}),!(0,t.isDefinedHashType)(u))throw new Error("Invalid hashType "+u);const d=te.allocUnsafe(1);d.writeUInt8(u,0);const h=o(l.slice(0,32)),f=o(l.slice(32,64));return te.concat([e.encode(h,f),d])}return Br.encode=c,Br}var mu;function et(){return mu||(mu=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.signature=e.number=e.isCanonicalScriptSignature=e.isDefinedHashType=e.isCanonicalPubKey=e.toStack=e.fromASM=e.toASM=e.decompile=e.compile=e.countNonPushOnlyOPs=e.isPushOnly=e.OPS=void 0;const t=Ud(),n=va();Object.defineProperty(e,"OPS",{enumerable:!0,get:function(){return n.OPS}});const r=Yy(),a=Zy(),o=tg(),i=ze(),{typeforce:s}=i,c=n.OPS.OP_RESERVED;function l(T){return i.Number(T)&&(T===n.OPS.OP_0||T>=n.OPS.OP_1&&T<=n.OPS.OP_16||T===n.OPS.OP_1NEGATE)}function u(T){return i.Buffer(T)||l(T)}function d(T){return i.Array(T)&&T.every(u)}e.isPushOnly=d;function h(T){return T.length-T.filter(u).length}e.countNonPushOnlyOPs=h;function f(T){if(T.length===0)return n.OPS.OP_0;if(T.length===1){if(T[0]>=1&&T[0]<=16)return c+T[0];if(T[0]===129)return n.OPS.OP_1NEGATE}}function y(T){return te.isBuffer(T)}function g(T){return i.Array(T)}function S(T){return te.isBuffer(T)}function B(T){if(y(T))return T;s(i.Array,T);const L=T.reduce((R,P)=>S(P)?P.length===1&&f(P)!==void 0?R+1:R+r.encodingLength(P.length)+P.length:R+1,0),F=te.allocUnsafe(L);let O=0;if(T.forEach(R=>{if(S(R)){const P=f(R);if(P!==void 0){F.writeUInt8(P,O),O+=1;return}O+=r.encode(F,R.length,O),R.copy(F,O),O+=R.length}else F.writeUInt8(R,O),O+=1}),O!==F.length)throw new Error("Could not decode chunks");return F}e.compile=B;function I(T){if(g(T))return T;s(i.Buffer,T);const L=[];let F=0;for(;F<T.length;){const O=T[F];if(O>n.OPS.OP_0&&O<=n.OPS.OP_PUSHDATA4){const R=r.decode(T,F);if(R===null||(F+=R.size,F+R.number>T.length))return null;const P=T.slice(F,F+R.number);F+=R.number;const K=f(P);K!==void 0?L.push(K):L.push(P)}else L.push(O),F+=1}return L}e.decompile=I;function b(T){if(y(T)&&(T=I(T)),!T)throw new Error("Could not convert invalid chunks to ASM");return T.map(L=>{if(S(L)){const F=f(L);if(F===void 0)return L.toString("hex");L=F}return n.REVERSE_OPS[L]}).join(" ")}e.toASM=b;function w(T){return s(i.String,T),B(T.split(" ").map(L=>n.OPS[L]!==void 0?n.OPS[L]:(s(i.Hex,L),te.from(L,"hex"))))}e.fromASM=w;function x(T){return T=I(T),s(d,T),T.map(L=>S(L)?L:L===n.OPS.OP_0?te.allocUnsafe(0):a.encode(L-c))}e.toStack=x;function _(T){return i.isPoint(T)}e.isCanonicalPubKey=_;function N(T){const L=T&-129;return L>0&&L<4}e.isDefinedHashType=N;function k(T){return!te.isBuffer(T)||!N(T[T.length-1])?!1:t.check(T.slice(0,-1))}e.isCanonicalScriptSignature=k,e.number=a,e.signature=o})(ss)),ss}var kr={},bu;function Ir(){if(bu)return kr;bu=1,Object.defineProperty(kr,"__esModule",{value:!0}),kr.value=kr.prop=void 0;function e(n,r,a){Object.defineProperty(n,r,{configurable:!0,enumerable:!0,get(){const o=a.call(this);return this[r]=o,o},set(o){Object.defineProperty(this,r,{configurable:!0,enumerable:!0,value:o,writable:!0})}})}kr.prop=e;function t(n){let r;return()=>(r!==void 0||(r=n()),r)}return kr.value=t,kr}var vu;function rg(){if(vu)return In;vu=1,Object.defineProperty(In,"__esModule",{value:!0}),In.p2data=void 0;const e=wt(),t=et(),n=ze(),r=Ir(),a=t.OPS;function o(i,s){if(!i.data&&!i.output)throw new TypeError("Not enough data");s=Object.assign({validate:!0},s||{}),(0,n.typeforce)({network:n.typeforce.maybe(n.typeforce.Object),output:n.typeforce.maybe(n.typeforce.Buffer),data:n.typeforce.maybe(n.typeforce.arrayOf(n.typeforce.Buffer))},i);const l={name:"embed",network:i.network||e.bitcoin};if(r.prop(l,"output",()=>{if(i.data)return t.compile([a.OP_RETURN].concat(i.data))}),r.prop(l,"data",()=>{if(i.output)return t.decompile(i.output).slice(1)}),s.validate&&i.output){const u=t.decompile(i.output);if(u[0]!==a.OP_RETURN)throw new TypeError("Output is invalid");if(!u.slice(1).every(n.typeforce.Buffer))throw new TypeError("Output is invalid");if(i.data&&!(0,n.stacksEqual)(i.data,l.data))throw new TypeError("Data mismatch")}return Object.assign(l,i)}return In.p2data=o,In}var _n={},Eu;function ng(){if(Eu)return _n;Eu=1,Object.defineProperty(_n,"__esModule",{value:!0}),_n.p2ms=void 0;const e=wt(),t=et(),n=ze(),r=Ir(),a=t.OPS,o=a.OP_RESERVED;function i(s,c){if(!s.input&&!s.output&&!(s.pubkeys&&s.m!==void 0)&&!s.signatures)throw new TypeError("Not enough data");c=Object.assign({validate:!0},c||{});function l(g){return t.isCanonicalScriptSignature(g)||(c.allowIncomplete&&g===a.OP_0)!==void 0}(0,n.typeforce)({network:n.typeforce.maybe(n.typeforce.Object),m:n.typeforce.maybe(n.typeforce.Number),n:n.typeforce.maybe(n.typeforce.Number),output:n.typeforce.maybe(n.typeforce.Buffer),pubkeys:n.typeforce.maybe(n.typeforce.arrayOf(n.isPoint)),signatures:n.typeforce.maybe(n.typeforce.arrayOf(l)),input:n.typeforce.maybe(n.typeforce.Buffer)},s);const d={network:s.network||e.bitcoin};let h=[],f=!1;function y(g){f||(f=!0,h=t.decompile(g),d.m=h[0]-o,d.n=h[h.length-2]-o,d.pubkeys=h.slice(1,-2))}if(r.prop(d,"output",()=>{if(s.m&&d.n&&s.pubkeys)return t.compile([].concat(o+s.m,s.pubkeys,o+d.n,a.OP_CHECKMULTISIG))}),r.prop(d,"m",()=>{if(d.output)return y(d.output),d.m}),r.prop(d,"n",()=>{if(d.pubkeys)return d.pubkeys.length}),r.prop(d,"pubkeys",()=>{if(s.output)return y(s.output),d.pubkeys}),r.prop(d,"signatures",()=>{if(s.input)return t.decompile(s.input).slice(1)}),r.prop(d,"input",()=>{if(s.signatures)return t.compile([a.OP_0].concat(s.signatures))}),r.prop(d,"witness",()=>{if(d.input)return[]}),r.prop(d,"name",()=>{if(!(!d.m||!d.n))return`p2ms(${d.m} of ${d.n})`}),c.validate){if(s.output){if(y(s.output),!n.typeforce.Number(h[0]))throw new TypeError("Output is invalid");if(!n.typeforce.Number(h[h.length-2]))throw new TypeError("Output is invalid");if(h[h.length-1]!==a.OP_CHECKMULTISIG)throw new TypeError("Output is invalid");if(d.m<=0||d.n>16||d.m>d.n||d.n!==h.length-3)throw new TypeError("Output is invalid");if(!d.pubkeys.every(g=>(0,n.isPoint)(g)))throw new TypeError("Output is invalid");if(s.m!==void 0&&s.m!==d.m)throw new TypeError("m mismatch");if(s.n!==void 0&&s.n!==d.n)throw new TypeError("n mismatch");if(s.pubkeys&&!(0,n.stacksEqual)(s.pubkeys,d.pubkeys))throw new TypeError("Pubkeys mismatch")}if(s.pubkeys){if(s.n!==void 0&&s.n!==s.pubkeys.length)throw new TypeError("Pubkey count mismatch");if(d.n=s.pubkeys.length,d.n<d.m)throw new TypeError("Pubkey count cannot be less than m")}if(s.signatures){if(s.signatures.length<d.m)throw new TypeError("Not enough signatures provided");if(s.signatures.length>d.m)throw new TypeError("Too many signatures provided")}if(s.input){if(s.input[0]!==a.OP_0)throw new TypeError("Input is invalid");if(d.signatures.length===0||!d.signatures.every(l))throw new TypeError("Input has invalid signature(s)");if(s.signatures&&!(0,n.stacksEqual)(s.signatures,d.signatures))throw new TypeError("Signature mismatch");if(s.m!==void 0&&s.m!==s.signatures.length)throw new TypeError("Signature count mismatch")}}return Object.assign(d,s)}return _n.p2ms=i,_n}var An={},xu;function ig(){if(xu)return An;xu=1,Object.defineProperty(An,"__esModule",{value:!0}),An.p2pk=void 0;const e=wt(),t=et(),n=ze(),r=Ir(),a=t.OPS;function o(i,s){if(!i.input&&!i.output&&!i.pubkey&&!i.input&&!i.signature)throw new TypeError("Not enough data");s=Object.assign({validate:!0},s||{}),(0,n.typeforce)({network:n.typeforce.maybe(n.typeforce.Object),output:n.typeforce.maybe(n.typeforce.Buffer),pubkey:n.typeforce.maybe(n.isPoint),signature:n.typeforce.maybe(t.isCanonicalScriptSignature),input:n.typeforce.maybe(n.typeforce.Buffer)},i);const c=r.value(()=>t.decompile(i.input)),u={name:"p2pk",network:i.network||e.bitcoin};if(r.prop(u,"output",()=>{if(i.pubkey)return t.compile([i.pubkey,a.OP_CHECKSIG])}),r.prop(u,"pubkey",()=>{if(i.output)return i.output.slice(1,-1)}),r.prop(u,"signature",()=>{if(i.input)return c()[0]}),r.prop(u,"input",()=>{if(i.signature)return t.compile([i.signature])}),r.prop(u,"witness",()=>{if(u.input)return[]}),s.validate){if(i.output){if(i.output[i.output.length-1]!==a.OP_CHECKSIG)throw new TypeError("Output is invalid");if(!(0,n.isPoint)(u.pubkey))throw new TypeError("Output pubkey is invalid");if(i.pubkey&&!i.pubkey.equals(u.pubkey))throw new TypeError("Pubkey mismatch")}if(i.signature&&i.input&&!i.input.equals(u.input))throw new TypeError("Signature mismatch");if(i.input){if(c().length!==1)throw new TypeError("Input is invalid");if(!t.isCanonicalScriptSignature(u.signature))throw new TypeError("Input has invalid signature")}}return Object.assign(u,i)}return An.p2pk=o,An}var Tn={},ds={},Or={},Ye={},We={},hs={},Bn={},Su;function og(){return Su||(Su=1,Object.defineProperty(Bn,"__esModule",{value:!0}),Bn.crypto=void 0,Bn.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0),Bn}var Iu;function xa(){return Iu||(Iu=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.Hash=e.nextTick=e.swap32IfBE=e.byteSwapIfBE=e.swap8IfBE=e.isLE=void 0,e.isBytes=n,e.anumber=r,e.abytes=a,e.ahash=o,e.aexists=i,e.aoutput=s,e.u8=c,e.u32=l,e.clean=u,e.createView=d,e.rotr=h,e.rotl=f,e.byteSwap=y,e.byteSwap32=g,e.bytesToHex=I,e.hexToBytes=x,e.asyncLoop=N,e.utf8ToBytes=k,e.bytesToUtf8=T,e.toBytes=L,e.kdfInputToBytes=F,e.concatBytes=O,e.checkOpts=R,e.createHasher=K,e.createOptHasher=U,e.createXOFer=V,e.randomBytes=C;const t=og();function n(H){return H instanceof Uint8Array||ArrayBuffer.isView(H)&&H.constructor.name==="Uint8Array"}function r(H){if(!Number.isSafeInteger(H)||H<0)throw new Error("positive integer expected, got "+H)}function a(H,...D){if(!n(H))throw new Error("Uint8Array expected");if(D.length>0&&!D.includes(H.length))throw new Error("Uint8Array expected of length "+D+", got length="+H.length)}function o(H){if(typeof H!="function"||typeof H.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");r(H.outputLen),r(H.blockLen)}function i(H,D=!0){if(H.destroyed)throw new Error("Hash instance has been destroyed");if(D&&H.finished)throw new Error("Hash#digest() has already been called")}function s(H,D){a(H);const W=D.outputLen;if(H.length<W)throw new Error("digestInto() expects output buffer of length at least "+W)}function c(H){return new Uint8Array(H.buffer,H.byteOffset,H.byteLength)}function l(H){return new Uint32Array(H.buffer,H.byteOffset,Math.floor(H.byteLength/4))}function u(...H){for(let D=0;D<H.length;D++)H[D].fill(0)}function d(H){return new DataView(H.buffer,H.byteOffset,H.byteLength)}function h(H,D){return H<<32-D|H>>>D}function f(H,D){return H<<D|H>>>32-D>>>0}e.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function y(H){return H<<24&4278190080|H<<8&16711680|H>>>8&65280|H>>>24&255}e.swap8IfBE=e.isLE?H=>H:H=>y(H),e.byteSwapIfBE=e.swap8IfBE;function g(H){for(let D=0;D<H.length;D++)H[D]=y(H[D]);return H}e.swap32IfBE=e.isLE?H=>H:g;const S=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",B=Array.from({length:256},(H,D)=>D.toString(16).padStart(2,"0"));function I(H){if(a(H),S)return H.toHex();let D="";for(let W=0;W<H.length;W++)D+=B[H[W]];return D}const b={_0:48,_9:57,A:65,F:70,a:97,f:102};function w(H){if(H>=b._0&&H<=b._9)return H-b._0;if(H>=b.A&&H<=b.F)return H-(b.A-10);if(H>=b.a&&H<=b.f)return H-(b.a-10)}function x(H){if(typeof H!="string")throw new Error("hex string expected, got "+typeof H);if(S)return Uint8Array.fromHex(H);const D=H.length,W=D/2;if(D%2)throw new Error("hex string expected, got unpadded hex of length "+D);const J=new Uint8Array(W);for(let re=0,se=0;re<W;re++,se+=2){const z=w(H.charCodeAt(se)),X=w(H.charCodeAt(se+1));if(z===void 0||X===void 0){const Y=H[se]+H[se+1];throw new Error('hex string expected, got non-hex character "'+Y+'" at index '+se)}J[re]=z*16+X}return J}const _=async()=>{};e.nextTick=_;async function N(H,D,W){let J=Date.now();for(let re=0;re<H;re++){W(re);const se=Date.now()-J;se>=0&&se<D||(await(0,e.nextTick)(),J+=se)}}function k(H){if(typeof H!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(H))}function T(H){return new TextDecoder().decode(H)}function L(H){return typeof H=="string"&&(H=k(H)),a(H),H}function F(H){return typeof H=="string"&&(H=k(H)),a(H),H}function O(...H){let D=0;for(let J=0;J<H.length;J++){const re=H[J];a(re),D+=re.length}const W=new Uint8Array(D);for(let J=0,re=0;J<H.length;J++){const se=H[J];W.set(se,re),re+=se.length}return W}function R(H,D){if(D!==void 0&&{}.toString.call(D)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(H,D)}class P{}e.Hash=P;function K(H){const D=J=>H().update(L(J)).digest(),W=H();return D.outputLen=W.outputLen,D.blockLen=W.blockLen,D.create=()=>H(),D}function U(H){const D=(J,re)=>H(re).update(L(J)).digest(),W=H({});return D.outputLen=W.outputLen,D.blockLen=W.blockLen,D.create=J=>H(J),D}function V(H){const D=(J,re)=>H(re).update(L(J)).digest(),W=H({});return D.outputLen=W.outputLen,D.blockLen=W.blockLen,D.create=J=>H(J),D}e.wrapConstructor=K,e.wrapConstructorWithOpts=U,e.wrapXOFConstructorWithOpts=V;function C(H=32){if(t.crypto&&typeof t.crypto.getRandomValues=="function")return t.crypto.getRandomValues(new Uint8Array(H));if(t.crypto&&typeof t.crypto.randomBytes=="function")return Uint8Array.from(t.crypto.randomBytes(H));throw new Error("crypto.getRandomValues must be defined")}})(hs)),hs}var _u;function Ld(){if(_u)return We;_u=1,Object.defineProperty(We,"__esModule",{value:!0}),We.SHA512_IV=We.SHA384_IV=We.SHA224_IV=We.SHA256_IV=We.HashMD=void 0,We.setBigUint64=t,We.Chi=n,We.Maj=r;const e=xa();function t(o,i,s,c){if(typeof o.setBigUint64=="function")return o.setBigUint64(i,s,c);const l=BigInt(32),u=BigInt(4294967295),d=Number(s>>l&u),h=Number(s&u),f=c?4:0,y=c?0:4;o.setUint32(i+f,d,c),o.setUint32(i+y,h,c)}function n(o,i,s){return o&i^~o&s}function r(o,i,s){return o&i^o&s^i&s}class a extends e.Hash{constructor(i,s,c,l){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=i,this.outputLen=s,this.padOffset=c,this.isLE=l,this.buffer=new Uint8Array(i),this.view=(0,e.createView)(this.buffer)}update(i){(0,e.aexists)(this),i=(0,e.toBytes)(i),(0,e.abytes)(i);const{view:s,buffer:c,blockLen:l}=this,u=i.length;for(let d=0;d<u;){const h=Math.min(l-this.pos,u-d);if(h===l){const f=(0,e.createView)(i);for(;l<=u-d;d+=l)this.process(f,d);continue}c.set(i.subarray(d,d+h),this.pos),this.pos+=h,d+=h,this.pos===l&&(this.process(s,0),this.pos=0)}return this.length+=i.length,this.roundClean(),this}digestInto(i){(0,e.aexists)(this),(0,e.aoutput)(i,this),this.finished=!0;const{buffer:s,view:c,blockLen:l,isLE:u}=this;let{pos:d}=this;s[d++]=128,(0,e.clean)(this.buffer.subarray(d)),this.padOffset>l-d&&(this.process(c,0),d=0);for(let S=d;S<l;S++)s[S]=0;t(c,l-8,BigInt(this.length*8),u),this.process(c,0);const h=(0,e.createView)(i),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const y=f/4,g=this.get();if(y>g.length)throw new Error("_sha2: outputLen bigger than state");for(let S=0;S<y;S++)h.setUint32(4*S,g[S],u)}digest(){const{buffer:i,outputLen:s}=this;this.digestInto(i);const c=i.slice(0,s);return this.destroy(),c}_cloneInto(i){i||(i=new this.constructor),i.set(...this.get());const{blockLen:s,buffer:c,length:l,finished:u,destroyed:d,pos:h}=this;return i.destroyed=d,i.finished=u,i.length=l,i.pos=h,l%s&&i.buffer.set(c),i}clone(){return this._cloneInto()}}return We.HashMD=a,We.SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),We.SHA224_IV=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),We.SHA384_IV=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),We.SHA512_IV=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),We}var Au;function Dd(){if(Au)return Ye;Au=1,Object.defineProperty(Ye,"__esModule",{value:!0}),Ye.ripemd160=Ye.RIPEMD160=Ye.md5=Ye.MD5=Ye.sha1=Ye.SHA1=void 0;const e=Ld(),t=xa(),n=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),r=new Uint32Array(80);class a extends e.HashMD{constructor(){super(64,20,8,!1),this.A=n[0]|0,this.B=n[1]|0,this.C=n[2]|0,this.D=n[3]|0,this.E=n[4]|0}get(){const{A:T,B:L,C:F,D:O,E:R}=this;return[T,L,F,O,R]}set(T,L,F,O,R){this.A=T|0,this.B=L|0,this.C=F|0,this.D=O|0,this.E=R|0}process(T,L){for(let U=0;U<16;U++,L+=4)r[U]=T.getUint32(L,!1);for(let U=16;U<80;U++)r[U]=(0,t.rotl)(r[U-3]^r[U-8]^r[U-14]^r[U-16],1);let{A:F,B:O,C:R,D:P,E:K}=this;for(let U=0;U<80;U++){let V,C;U<20?(V=(0,e.Chi)(O,R,P),C=1518500249):U<40?(V=O^R^P,C=1859775393):U<60?(V=(0,e.Maj)(O,R,P),C=2400959708):(V=O^R^P,C=3395469782);const H=(0,t.rotl)(F,5)+V+K+C+r[U]|0;K=P,P=R,R=(0,t.rotl)(O,30),O=F,F=H}F=F+this.A|0,O=O+this.B|0,R=R+this.C|0,P=P+this.D|0,K=K+this.E|0,this.set(F,O,R,P,K)}roundClean(){(0,t.clean)(r)}destroy(){this.set(0,0,0,0,0),(0,t.clean)(this.buffer)}}Ye.SHA1=a,Ye.sha1=(0,t.createHasher)(()=>new a);const o=Math.pow(2,32),i=Array.from({length:64},(k,T)=>Math.floor(o*Math.abs(Math.sin(T+1)))),s=n.slice(0,4),c=new Uint32Array(16);class l extends e.HashMD{constructor(){super(64,16,8,!0),this.A=s[0]|0,this.B=s[1]|0,this.C=s[2]|0,this.D=s[3]|0}get(){const{A:T,B:L,C:F,D:O}=this;return[T,L,F,O]}set(T,L,F,O){this.A=T|0,this.B=L|0,this.C=F|0,this.D=O|0}process(T,L){for(let K=0;K<16;K++,L+=4)c[K]=T.getUint32(L,!0);let{A:F,B:O,C:R,D:P}=this;for(let K=0;K<64;K++){let U,V,C;K<16?(U=(0,e.Chi)(O,R,P),V=K,C=[7,12,17,22]):K<32?(U=(0,e.Chi)(P,O,R),V=(5*K+1)%16,C=[5,9,14,20]):K<48?(U=O^R^P,V=(3*K+5)%16,C=[4,11,16,23]):(U=R^(O|~P),V=7*K%16,C=[6,10,15,21]),U=U+F+i[K]+c[V],F=P,P=R,R=O,O=O+(0,t.rotl)(U,C[K%4])}F=F+this.A|0,O=O+this.B|0,R=R+this.C|0,P=P+this.D|0,this.set(F,O,R,P)}roundClean(){(0,t.clean)(c)}destroy(){this.set(0,0,0,0),(0,t.clean)(this.buffer)}}Ye.MD5=l,Ye.md5=(0,t.createHasher)(()=>new l);const u=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),d=Uint8Array.from(new Array(16).fill(0).map((k,T)=>T)),h=d.map(k=>(9*k+5)%16),f=(()=>{const L=[[d],[h]];for(let F=0;F<4;F++)for(let O of L)O.push(O[F].map(R=>u[R]));return L})(),y=f[0],g=f[1],S=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(k=>Uint8Array.from(k)),B=y.map((k,T)=>k.map(L=>S[T][L])),I=g.map((k,T)=>k.map(L=>S[T][L])),b=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),w=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function x(k,T,L,F){return k===0?T^L^F:k===1?T&L|~T&F:k===2?(T|~L)^F:k===3?T&F|L&~F:T^(L|~F)}const _=new Uint32Array(16);class N extends e.HashMD{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:T,h1:L,h2:F,h3:O,h4:R}=this;return[T,L,F,O,R]}set(T,L,F,O,R){this.h0=T|0,this.h1=L|0,this.h2=F|0,this.h3=O|0,this.h4=R|0}process(T,L){for(let W=0;W<16;W++,L+=4)_[W]=T.getUint32(L,!0);let F=this.h0|0,O=F,R=this.h1|0,P=R,K=this.h2|0,U=K,V=this.h3|0,C=V,H=this.h4|0,D=H;for(let W=0;W<5;W++){const J=4-W,re=b[W],se=w[W],z=y[W],X=g[W],Y=B[W],ae=I[W];for(let ce=0;ce<16;ce++){const oe=(0,t.rotl)(F+x(W,R,K,V)+_[z[ce]]+re,Y[ce])+H|0;F=H,H=V,V=(0,t.rotl)(K,10)|0,K=R,R=oe}for(let ce=0;ce<16;ce++){const oe=(0,t.rotl)(O+x(J,P,U,C)+_[X[ce]]+se,ae[ce])+D|0;O=D,D=C,C=(0,t.rotl)(U,10)|0,U=P,P=oe}}this.set(this.h1+K+C|0,this.h2+V+D|0,this.h3+H+O|0,this.h4+F+P|0,this.h0+R+U|0)}roundClean(){(0,t.clean)(_)}destroy(){this.destroyed=!0,(0,t.clean)(this.buffer),this.set(0,0,0,0,0)}}return Ye.RIPEMD160=N,Ye.ripemd160=(0,t.createHasher)(()=>new N),Ye}var Tu;function sg(){if(Tu)return Or;Tu=1,Object.defineProperty(Or,"__esModule",{value:!0}),Or.ripemd160=Or.RIPEMD160=void 0;const e=Dd();return Or.RIPEMD160=e.RIPEMD160,Or.ripemd160=e.ripemd160,Or}var Rr={},Bu;function ag(){if(Bu)return Rr;Bu=1,Object.defineProperty(Rr,"__esModule",{value:!0}),Rr.sha1=Rr.SHA1=void 0;const e=Dd();return Rr.SHA1=e.SHA1,Rr.sha1=e.sha1,Rr}var ht={},ke={},be={},ku;function cg(){if(ku)return be;ku=1,Object.defineProperty(be,"__esModule",{value:!0}),be.toBig=be.shrSL=be.shrSH=be.rotrSL=be.rotrSH=be.rotrBL=be.rotrBH=be.rotr32L=be.rotr32H=be.rotlSL=be.rotlSH=be.rotlBL=be.rotlBH=be.add5L=be.add5H=be.add4L=be.add4H=be.add3L=be.add3H=void 0,be.add=B,be.fromBig=n,be.split=r;const e=BigInt(2**32-1),t=BigInt(32);function n(T,L=!1){return L?{h:Number(T&e),l:Number(T>>t&e)}:{h:Number(T>>t&e)|0,l:Number(T&e)|0}}function r(T,L=!1){const F=T.length;let O=new Uint32Array(F),R=new Uint32Array(F);for(let P=0;P<F;P++){const{h:K,l:U}=n(T[P],L);[O[P],R[P]]=[K,U]}return[O,R]}const a=(T,L)=>BigInt(T>>>0)<<t|BigInt(L>>>0);be.toBig=a;const o=(T,L,F)=>T>>>F;be.shrSH=o;const i=(T,L,F)=>T<<32-F|L>>>F;be.shrSL=i;const s=(T,L,F)=>T>>>F|L<<32-F;be.rotrSH=s;const c=(T,L,F)=>T<<32-F|L>>>F;be.rotrSL=c;const l=(T,L,F)=>T<<64-F|L>>>F-32;be.rotrBH=l;const u=(T,L,F)=>T>>>F-32|L<<64-F;be.rotrBL=u;const d=(T,L)=>L;be.rotr32H=d;const h=(T,L)=>T;be.rotr32L=h;const f=(T,L,F)=>T<<F|L>>>32-F;be.rotlSH=f;const y=(T,L,F)=>L<<F|T>>>32-F;be.rotlSL=y;const g=(T,L,F)=>L<<F-32|T>>>64-F;be.rotlBH=g;const S=(T,L,F)=>T<<F-32|L>>>64-F;be.rotlBL=S;function B(T,L,F,O){const R=(L>>>0)+(O>>>0);return{h:T+F+(R/2**32|0)|0,l:R|0}}const I=(T,L,F)=>(T>>>0)+(L>>>0)+(F>>>0);be.add3L=I;const b=(T,L,F,O)=>L+F+O+(T/2**32|0)|0;be.add3H=b;const w=(T,L,F,O)=>(T>>>0)+(L>>>0)+(F>>>0)+(O>>>0);be.add4L=w;const x=(T,L,F,O,R)=>L+F+O+R+(T/2**32|0)|0;be.add4H=x;const _=(T,L,F,O,R)=>(T>>>0)+(L>>>0)+(F>>>0)+(O>>>0)+(R>>>0);be.add5L=_;const N=(T,L,F,O,R,P)=>L+F+O+R+P+(T/2**32|0)|0;be.add5H=N;const k={fromBig:n,split:r,toBig:a,shrSH:o,shrSL:i,rotrSH:s,rotrSL:c,rotrBH:l,rotrBL:u,rotr32H:d,rotr32L:h,rotlSH:f,rotlSL:y,rotlBH:g,rotlBL:S,add:B,add3L:I,add3H:b,add4L:w,add4H:x,add5H:N,add5L:_};return be.default=k,be}var Ou;function ug(){if(Ou)return ke;Ou=1,Object.defineProperty(ke,"__esModule",{value:!0}),ke.sha512_224=ke.sha512_256=ke.sha384=ke.sha512=ke.sha224=ke.sha256=ke.SHA512_256=ke.SHA512_224=ke.SHA384=ke.SHA512=ke.SHA224=ke.SHA256=void 0;const e=Ld(),t=cg(),n=xa(),r=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a=new Uint32Array(64);class o extends e.HashMD{constructor(b=32){super(64,b,8,!1),this.A=e.SHA256_IV[0]|0,this.B=e.SHA256_IV[1]|0,this.C=e.SHA256_IV[2]|0,this.D=e.SHA256_IV[3]|0,this.E=e.SHA256_IV[4]|0,this.F=e.SHA256_IV[5]|0,this.G=e.SHA256_IV[6]|0,this.H=e.SHA256_IV[7]|0}get(){const{A:b,B:w,C:x,D:_,E:N,F:k,G:T,H:L}=this;return[b,w,x,_,N,k,T,L]}set(b,w,x,_,N,k,T,L){this.A=b|0,this.B=w|0,this.C=x|0,this.D=_|0,this.E=N|0,this.F=k|0,this.G=T|0,this.H=L|0}process(b,w){for(let R=0;R<16;R++,w+=4)a[R]=b.getUint32(w,!1);for(let R=16;R<64;R++){const P=a[R-15],K=a[R-2],U=(0,n.rotr)(P,7)^(0,n.rotr)(P,18)^P>>>3,V=(0,n.rotr)(K,17)^(0,n.rotr)(K,19)^K>>>10;a[R]=V+a[R-7]+U+a[R-16]|0}let{A:x,B:_,C:N,D:k,E:T,F:L,G:F,H:O}=this;for(let R=0;R<64;R++){const P=(0,n.rotr)(T,6)^(0,n.rotr)(T,11)^(0,n.rotr)(T,25),K=O+P+(0,e.Chi)(T,L,F)+r[R]+a[R]|0,V=((0,n.rotr)(x,2)^(0,n.rotr)(x,13)^(0,n.rotr)(x,22))+(0,e.Maj)(x,_,N)|0;O=F,F=L,L=T,T=k+K|0,k=N,N=_,_=x,x=K+V|0}x=x+this.A|0,_=_+this.B|0,N=N+this.C|0,k=k+this.D|0,T=T+this.E|0,L=L+this.F|0,F=F+this.G|0,O=O+this.H|0,this.set(x,_,N,k,T,L,F,O)}roundClean(){(0,n.clean)(a)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,n.clean)(this.buffer)}}ke.SHA256=o;class i extends o{constructor(){super(28),this.A=e.SHA224_IV[0]|0,this.B=e.SHA224_IV[1]|0,this.C=e.SHA224_IV[2]|0,this.D=e.SHA224_IV[3]|0,this.E=e.SHA224_IV[4]|0,this.F=e.SHA224_IV[5]|0,this.G=e.SHA224_IV[6]|0,this.H=e.SHA224_IV[7]|0}}ke.SHA224=i;const s=t.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(I=>BigInt(I))),c=s[0],l=s[1],u=new Uint32Array(80),d=new Uint32Array(80);class h extends e.HashMD{constructor(b=64){super(128,b,16,!1),this.Ah=e.SHA512_IV[0]|0,this.Al=e.SHA512_IV[1]|0,this.Bh=e.SHA512_IV[2]|0,this.Bl=e.SHA512_IV[3]|0,this.Ch=e.SHA512_IV[4]|0,this.Cl=e.SHA512_IV[5]|0,this.Dh=e.SHA512_IV[6]|0,this.Dl=e.SHA512_IV[7]|0,this.Eh=e.SHA512_IV[8]|0,this.El=e.SHA512_IV[9]|0,this.Fh=e.SHA512_IV[10]|0,this.Fl=e.SHA512_IV[11]|0,this.Gh=e.SHA512_IV[12]|0,this.Gl=e.SHA512_IV[13]|0,this.Hh=e.SHA512_IV[14]|0,this.Hl=e.SHA512_IV[15]|0}get(){const{Ah:b,Al:w,Bh:x,Bl:_,Ch:N,Cl:k,Dh:T,Dl:L,Eh:F,El:O,Fh:R,Fl:P,Gh:K,Gl:U,Hh:V,Hl:C}=this;return[b,w,x,_,N,k,T,L,F,O,R,P,K,U,V,C]}set(b,w,x,_,N,k,T,L,F,O,R,P,K,U,V,C){this.Ah=b|0,this.Al=w|0,this.Bh=x|0,this.Bl=_|0,this.Ch=N|0,this.Cl=k|0,this.Dh=T|0,this.Dl=L|0,this.Eh=F|0,this.El=O|0,this.Fh=R|0,this.Fl=P|0,this.Gh=K|0,this.Gl=U|0,this.Hh=V|0,this.Hl=C|0}process(b,w){for(let W=0;W<16;W++,w+=4)u[W]=b.getUint32(w),d[W]=b.getUint32(w+=4);for(let W=16;W<80;W++){const J=u[W-15]|0,re=d[W-15]|0,se=t.rotrSH(J,re,1)^t.rotrSH(J,re,8)^t.shrSH(J,re,7),z=t.rotrSL(J,re,1)^t.rotrSL(J,re,8)^t.shrSL(J,re,7),X=u[W-2]|0,Y=d[W-2]|0,ae=t.rotrSH(X,Y,19)^t.rotrBH(X,Y,61)^t.shrSH(X,Y,6),ce=t.rotrSL(X,Y,19)^t.rotrBL(X,Y,61)^t.shrSL(X,Y,6),oe=t.add4L(z,ce,d[W-7],d[W-16]),de=t.add4H(oe,se,ae,u[W-7],u[W-16]);u[W]=de|0,d[W]=oe|0}let{Ah:x,Al:_,Bh:N,Bl:k,Ch:T,Cl:L,Dh:F,Dl:O,Eh:R,El:P,Fh:K,Fl:U,Gh:V,Gl:C,Hh:H,Hl:D}=this;for(let W=0;W<80;W++){const J=t.rotrSH(R,P,14)^t.rotrSH(R,P,18)^t.rotrBH(R,P,41),re=t.rotrSL(R,P,14)^t.rotrSL(R,P,18)^t.rotrBL(R,P,41),se=R&K^~R&V,z=P&U^~P&C,X=t.add5L(D,re,z,l[W],d[W]),Y=t.add5H(X,H,J,se,c[W],u[W]),ae=X|0,ce=t.rotrSH(x,_,28)^t.rotrBH(x,_,34)^t.rotrBH(x,_,39),oe=t.rotrSL(x,_,28)^t.rotrBL(x,_,34)^t.rotrBL(x,_,39),de=x&N^x&T^N&T,pe=_&k^_&L^k&L;H=V|0,D=C|0,V=K|0,C=U|0,K=R|0,U=P|0,{h:R,l:P}=t.add(F|0,O|0,Y|0,ae|0),F=T|0,O=L|0,T=N|0,L=k|0,N=x|0,k=_|0;const fe=t.add3L(ae,oe,pe);x=t.add3H(fe,Y,ce,de),_=fe|0}({h:x,l:_}=t.add(this.Ah|0,this.Al|0,x|0,_|0)),{h:N,l:k}=t.add(this.Bh|0,this.Bl|0,N|0,k|0),{h:T,l:L}=t.add(this.Ch|0,this.Cl|0,T|0,L|0),{h:F,l:O}=t.add(this.Dh|0,this.Dl|0,F|0,O|0),{h:R,l:P}=t.add(this.Eh|0,this.El|0,R|0,P|0),{h:K,l:U}=t.add(this.Fh|0,this.Fl|0,K|0,U|0),{h:V,l:C}=t.add(this.Gh|0,this.Gl|0,V|0,C|0),{h:H,l:D}=t.add(this.Hh|0,this.Hl|0,H|0,D|0),this.set(x,_,N,k,T,L,F,O,R,P,K,U,V,C,H,D)}roundClean(){(0,n.clean)(u,d)}destroy(){(0,n.clean)(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}ke.SHA512=h;class f extends h{constructor(){super(48),this.Ah=e.SHA384_IV[0]|0,this.Al=e.SHA384_IV[1]|0,this.Bh=e.SHA384_IV[2]|0,this.Bl=e.SHA384_IV[3]|0,this.Ch=e.SHA384_IV[4]|0,this.Cl=e.SHA384_IV[5]|0,this.Dh=e.SHA384_IV[6]|0,this.Dl=e.SHA384_IV[7]|0,this.Eh=e.SHA384_IV[8]|0,this.El=e.SHA384_IV[9]|0,this.Fh=e.SHA384_IV[10]|0,this.Fl=e.SHA384_IV[11]|0,this.Gh=e.SHA384_IV[12]|0,this.Gl=e.SHA384_IV[13]|0,this.Hh=e.SHA384_IV[14]|0,this.Hl=e.SHA384_IV[15]|0}}ke.SHA384=f;const y=Uint32Array.from([2352822216,424955298,1944164710,2312950998,502970286,855612546,1738396948,1479516111,258812777,2077511080,2011393907,79989058,1067287976,1780299464,286451373,2446758561]),g=Uint32Array.from([573645204,4230739756,2673172387,3360449730,596883563,1867755857,2520282905,1497426621,2519219938,2827943907,3193839141,1401305490,721525244,746961066,246885852,2177182882]);class S extends h{constructor(){super(28),this.Ah=y[0]|0,this.Al=y[1]|0,this.Bh=y[2]|0,this.Bl=y[3]|0,this.Ch=y[4]|0,this.Cl=y[5]|0,this.Dh=y[6]|0,this.Dl=y[7]|0,this.Eh=y[8]|0,this.El=y[9]|0,this.Fh=y[10]|0,this.Fl=y[11]|0,this.Gh=y[12]|0,this.Gl=y[13]|0,this.Hh=y[14]|0,this.Hl=y[15]|0}}ke.SHA512_224=S;class B extends h{constructor(){super(32),this.Ah=g[0]|0,this.Al=g[1]|0,this.Bh=g[2]|0,this.Bl=g[3]|0,this.Ch=g[4]|0,this.Cl=g[5]|0,this.Dh=g[6]|0,this.Dl=g[7]|0,this.Eh=g[8]|0,this.El=g[9]|0,this.Fh=g[10]|0,this.Fl=g[11]|0,this.Gh=g[12]|0,this.Gl=g[13]|0,this.Hh=g[14]|0,this.Hl=g[15]|0}}return ke.SHA512_256=B,ke.sha256=(0,n.createHasher)(()=>new o),ke.sha224=(0,n.createHasher)(()=>new i),ke.sha512=(0,n.createHasher)(()=>new h),ke.sha384=(0,n.createHasher)(()=>new f),ke.sha512_256=(0,n.createHasher)(()=>new B),ke.sha512_224=(0,n.createHasher)(()=>new S),ke}var Ru;function Nd(){if(Ru)return ht;Ru=1,Object.defineProperty(ht,"__esModule",{value:!0}),ht.sha224=ht.SHA224=ht.sha256=ht.SHA256=void 0;const e=ug();return ht.SHA256=e.SHA256,ht.sha256=e.sha256,ht.SHA224=e.SHA224,ht.sha224=e.sha224,ht}var Pu;function Wt(){return Pu||(Pu=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.taggedHash=e.TAGGED_HASH_PREFIXES=e.TAGS=e.hash256=e.hash160=e.sha256=e.sha1=e.ripemd160=void 0;const t=sg(),n=ag(),r=Nd();function a(u){return te.from((0,t.ripemd160)(Uint8Array.from(u)))}e.ripemd160=a;function o(u){return te.from((0,n.sha1)(Uint8Array.from(u)))}e.sha1=o;function i(u){return te.from((0,r.sha256)(Uint8Array.from(u)))}e.sha256=i;function s(u){return te.from((0,t.ripemd160)((0,r.sha256)(Uint8Array.from(u))))}e.hash160=s;function c(u){return te.from((0,r.sha256)((0,r.sha256)(Uint8Array.from(u))))}e.hash256=c,e.TAGS=["BIP0340/challenge","BIP0340/aux","BIP0340/nonce","TapLeaf","TapBranch","TapSighash","TapTweak","KeyAgg list","KeyAgg coefficient"],e.TAGGED_HASH_PREFIXES={"BIP0340/challenge":te.from([123,181,45,122,159,239,88,50,62,177,191,122,64,125,179,130,210,243,242,216,27,177,34,79,73,254,81,143,109,72,211,124,123,181,45,122,159,239,88,50,62,177,191,122,64,125,179,130,210,243,242,216,27,177,34,79,73,254,81,143,109,72,211,124]),"BIP0340/aux":te.from([241,239,78,94,192,99,202,218,109,148,202,250,157,152,126,160,105,38,88,57,236,193,31,151,45,119,165,46,216,193,204,144,241,239,78,94,192,99,202,218,109,148,202,250,157,152,126,160,105,38,88,57,236,193,31,151,45,119,165,46,216,193,204,144]),"BIP0340/nonce":te.from([7,73,119,52,167,155,203,53,91,155,140,125,3,79,18,28,244,52,215,62,247,45,218,25,135,0,97,251,82,191,235,47,7,73,119,52,167,155,203,53,91,155,140,125,3,79,18,28,244,52,215,62,247,45,218,25,135,0,97,251,82,191,235,47]),TapLeaf:te.from([174,234,143,220,66,8,152,49,5,115,75,88,8,29,30,38,56,211,95,28,181,64,8,212,211,87,202,3,190,120,233,238,174,234,143,220,66,8,152,49,5,115,75,88,8,29,30,38,56,211,95,28,181,64,8,212,211,87,202,3,190,120,233,238]),TapBranch:te.from([25,65,161,242,229,110,185,95,162,169,241,148,190,92,1,247,33,111,51,237,130,176,145,70,52,144,208,91,245,22,160,21,25,65,161,242,229,110,185,95,162,169,241,148,190,92,1,247,33,111,51,237,130,176,145,70,52,144,208,91,245,22,160,21]),TapSighash:te.from([244,10,72,223,75,42,112,200,180,146,75,242,101,70,97,237,61,149,253,102,163,19,235,135,35,117,151,198,40,228,160,49,244,10,72,223,75,42,112,200,180,146,75,242,101,70,97,237,61,149,253,102,163,19,235,135,35,117,151,198,40,228,160,49]),TapTweak:te.from([232,15,225,99,156,156,160,80,227,175,27,57,193,67,198,62,66,156,188,235,21,217,64,251,181,197,161,244,175,87,197,233,232,15,225,99,156,156,160,80,227,175,27,57,193,67,198,62,66,156,188,235,21,217,64,251,181,197,161,244,175,87,197,233]),"KeyAgg list":te.from([72,28,151,28,60,11,70,215,240,178,117,174,89,141,78,44,126,215,49,156,89,74,92,110,199,158,160,212,153,2,148,240,72,28,151,28,60,11,70,215,240,178,117,174,89,141,78,44,126,215,49,156,89,74,92,110,199,158,160,212,153,2,148,240]),"KeyAgg coefficient":te.from([191,201,4,3,77,28,136,232,200,14,34,229,61,36,86,109,100,130,78,214,66,114,129,192,145,0,249,77,205,82,201,129,191,201,4,3,77,28,136,232,200,14,34,229,61,36,86,109,100,130,78,214,66,114,129,192,145,0,249,77,205,82,201,129])};function l(u,d){return i(te.concat([e.TAGGED_HASH_PREFIXES[u],d]))}e.taggedHash=l})(ds)),ds}var ps,Uu;function fg(){if(Uu)return ps;Uu=1;function e(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var a=0;a<t.length;a++){var o=t.charAt(a),i=o.charCodeAt(0);if(n[i]!==255)throw new TypeError(o+" is ambiguous");n[i]=a}var s=t.length,c=t.charAt(0),l=Math.log(s)/Math.log(256),u=Math.log(256)/Math.log(s);function d(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var g=0,S=0,B=0,I=y.length;B!==I&&y[B]===0;)B++,g++;for(var b=(I-B)*u+1>>>0,w=new Uint8Array(b);B!==I;){for(var x=y[B],_=0,N=b-1;(x!==0||_<S)&&N!==-1;N--,_++)x+=256*w[N]>>>0,w[N]=x%s>>>0,x=x/s>>>0;if(x!==0)throw new Error("Non-zero carry");S=_,B++}for(var k=b-S;k!==b&&w[k]===0;)k++;for(var T=c.repeat(g);k<b;++k)T+=t.charAt(w[k]);return T}function h(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;for(var g=0,S=0,B=0;y[g]===c;)S++,g++;for(var I=(y.length-g)*l+1>>>0,b=new Uint8Array(I);y[g];){var w=y.charCodeAt(g);if(w>255)return;var x=n[w];if(x===255)return;for(var _=0,N=I-1;(x!==0||_<B)&&N!==-1;N--,_++)x+=s*b[N]>>>0,b[N]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");B=_,g++}for(var k=I-B;k!==I&&b[k]===0;)k++;for(var T=new Uint8Array(S+(I-k)),L=S;k!==I;)T[L++]=b[k++];return T}function f(y){var g=h(y);if(g)return g;throw new Error("Non-base"+s+" character")}return{encode:d,decodeUnsafe:h,decode:f}}return ps=e,ps}var ys,Hu;function lg(){return Hu||(Hu=1,ys=fg()("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")),ys}var gs,Lu;function dg(){if(Lu)return gs;Lu=1;var e=lg();return gs=function(t){function n(i){var s=Uint8Array.from(i),c=t(s),l=s.length+4,u=new Uint8Array(l);return u.set(s,0),u.set(c.subarray(0,4),s.length),e.encode(u,l)}function r(i){var s=i.slice(0,-4),c=i.slice(-4),l=t(s);if(!(c[0]^l[0]|c[1]^l[1]|c[2]^l[2]|c[3]^l[3]))return s}function a(i){var s=e.decodeUnsafe(i);if(s)return r(s)}function o(i){var s=e.decode(i),c=r(s);if(!c)throw new Error("Invalid checksum");return c}return{encode:n,decode:o,decodeUnsafe:a}},gs}var ws,Du;function Sa(){if(Du)return ws;Du=1;var{sha256:e}=Nd(),t=dg();function n(r){return e(e(r))}return ws=t(n),ws}var Nu;function hg(){if(Nu)return Tn;Nu=1,Object.defineProperty(Tn,"__esModule",{value:!0}),Tn.p2pkh=void 0;const e=Wt(),t=wt(),n=et(),r=ze(),a=Ir(),o=Sa(),i=n.OPS;function s(c,l){if(!c.address&&!c.hash&&!c.output&&!c.pubkey&&!c.input)throw new TypeError("Not enough data");l=Object.assign({validate:!0},l||{}),(0,r.typeforce)({network:r.typeforce.maybe(r.typeforce.Object),address:r.typeforce.maybe(r.typeforce.String),hash:r.typeforce.maybe(r.typeforce.BufferN(20)),output:r.typeforce.maybe(r.typeforce.BufferN(25)),pubkey:r.typeforce.maybe(r.isPoint),signature:r.typeforce.maybe(n.isCanonicalScriptSignature),input:r.typeforce.maybe(r.typeforce.Buffer)},c);const u=a.value(()=>{const y=te.from(o.decode(c.address)),g=y.readUInt8(0),S=y.slice(1);return{version:g,hash:S}}),d=a.value(()=>n.decompile(c.input)),h=c.network||t.bitcoin,f={name:"p2pkh",network:h};if(a.prop(f,"address",()=>{if(!f.hash)return;const y=te.allocUnsafe(21);return y.writeUInt8(h.pubKeyHash,0),f.hash.copy(y,1),o.encode(y)}),a.prop(f,"hash",()=>{if(c.output)return c.output.slice(3,23);if(c.address)return u().hash;if(c.pubkey||f.pubkey)return e.hash160(c.pubkey||f.pubkey)}),a.prop(f,"output",()=>{if(f.hash)return n.compile([i.OP_DUP,i.OP_HASH160,f.hash,i.OP_EQUALVERIFY,i.OP_CHECKSIG])}),a.prop(f,"pubkey",()=>{if(c.input)return d()[1]}),a.prop(f,"signature",()=>{if(c.input)return d()[0]}),a.prop(f,"input",()=>{if(c.pubkey&&c.signature)return n.compile([c.signature,c.pubkey])}),a.prop(f,"witness",()=>{if(f.input)return[]}),l.validate){let y=te.from([]);if(c.address){if(u().version!==h.pubKeyHash)throw new TypeError("Invalid version or Network mismatch");if(u().hash.length!==20)throw new TypeError("Invalid address");y=u().hash}if(c.hash){if(y.length>0&&!y.equals(c.hash))throw new TypeError("Hash mismatch");y=c.hash}if(c.output){if(c.output.length!==25||c.output[0]!==i.OP_DUP||c.output[1]!==i.OP_HASH160||c.output[2]!==20||c.output[23]!==i.OP_EQUALVERIFY||c.output[24]!==i.OP_CHECKSIG)throw new TypeError("Output is invalid");const g=c.output.slice(3,23);if(y.length>0&&!y.equals(g))throw new TypeError("Hash mismatch");y=g}if(c.pubkey){const g=e.hash160(c.pubkey);if(y.length>0&&!y.equals(g))throw new TypeError("Hash mismatch");y=g}if(c.input){const g=d();if(g.length!==2)throw new TypeError("Input is invalid");if(!n.isCanonicalScriptSignature(g[0]))throw new TypeError("Input has invalid signature");if(!(0,r.isPoint)(g[1]))throw new TypeError("Input has invalid pubkey");if(c.signature&&!c.signature.equals(g[0]))throw new TypeError("Signature mismatch");if(c.pubkey&&!c.pubkey.equals(g[1]))throw new TypeError("Pubkey mismatch");const S=e.hash160(g[1]);if(y.length>0&&!y.equals(S))throw new TypeError("Hash mismatch")}}return Object.assign(f,c)}return Tn.p2pkh=s,Tn}var kn={},Fu;function pg(){if(Fu)return kn;Fu=1,Object.defineProperty(kn,"__esModule",{value:!0}),kn.p2sh=void 0;const e=Wt(),t=wt(),n=et(),r=ze(),a=Ir(),o=Sa(),i=n.OPS;function s(c,l){if(!c.address&&!c.hash&&!c.output&&!c.redeem&&!c.input)throw new TypeError("Not enough data");l=Object.assign({validate:!0},l||{}),(0,r.typeforce)({network:r.typeforce.maybe(r.typeforce.Object),address:r.typeforce.maybe(r.typeforce.String),hash:r.typeforce.maybe(r.typeforce.BufferN(20)),output:r.typeforce.maybe(r.typeforce.BufferN(23)),redeem:r.typeforce.maybe({network:r.typeforce.maybe(r.typeforce.Object),output:r.typeforce.maybe(r.typeforce.Buffer),input:r.typeforce.maybe(r.typeforce.Buffer),witness:r.typeforce.maybe(r.typeforce.arrayOf(r.typeforce.Buffer))}),input:r.typeforce.maybe(r.typeforce.Buffer),witness:r.typeforce.maybe(r.typeforce.arrayOf(r.typeforce.Buffer))},c);let u=c.network;u||(u=c.redeem&&c.redeem.network||t.bitcoin);const d={network:u},h=a.value(()=>{const g=te.from(o.decode(c.address)),S=g.readUInt8(0),B=g.slice(1);return{version:S,hash:B}}),f=a.value(()=>n.decompile(c.input)),y=a.value(()=>{const g=f(),S=g[g.length-1];return{network:u,output:S===i.OP_FALSE?te.from([]):S,input:n.compile(g.slice(0,-1)),witness:c.witness||[]}});if(a.prop(d,"address",()=>{if(!d.hash)return;const g=te.allocUnsafe(21);return g.writeUInt8(d.network.scriptHash,0),d.hash.copy(g,1),o.encode(g)}),a.prop(d,"hash",()=>{if(c.output)return c.output.slice(2,22);if(c.address)return h().hash;if(d.redeem&&d.redeem.output)return e.hash160(d.redeem.output)}),a.prop(d,"output",()=>{if(d.hash)return n.compile([i.OP_HASH160,d.hash,i.OP_EQUAL])}),a.prop(d,"redeem",()=>{if(c.input)return y()}),a.prop(d,"input",()=>{if(!(!c.redeem||!c.redeem.input||!c.redeem.output))return n.compile([].concat(n.decompile(c.redeem.input),c.redeem.output))}),a.prop(d,"witness",()=>{if(d.redeem&&d.redeem.witness)return d.redeem.witness;if(d.input)return[]}),a.prop(d,"name",()=>{const g=["p2sh"];return d.redeem!==void 0&&d.redeem.name!==void 0&&g.push(d.redeem.name),g.join("-")}),l.validate){let g=te.from([]);if(c.address){if(h().version!==u.scriptHash)throw new TypeError("Invalid version or Network mismatch");if(h().hash.length!==20)throw new TypeError("Invalid address");g=h().hash}if(c.hash){if(g.length>0&&!g.equals(c.hash))throw new TypeError("Hash mismatch");g=c.hash}if(c.output){if(c.output.length!==23||c.output[0]!==i.OP_HASH160||c.output[1]!==20||c.output[22]!==i.OP_EQUAL)throw new TypeError("Output is invalid");const B=c.output.slice(2,22);if(g.length>0&&!g.equals(B))throw new TypeError("Hash mismatch");g=B}const S=B=>{if(B.output){const I=n.decompile(B.output);if(!I||I.length<1)throw new TypeError("Redeem.output too short");if(B.output.byteLength>520)throw new TypeError("Redeem.output unspendable if larger than 520 bytes");if(n.countNonPushOnlyOPs(I)>201)throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");const b=e.hash160(B.output);if(g.length>0&&!g.equals(b))throw new TypeError("Hash mismatch");g=b}if(B.input){const I=B.input.length>0,b=B.witness&&B.witness.length>0;if(!I&&!b)throw new TypeError("Empty input");if(I&&b)throw new TypeError("Input and witness provided");if(I){const w=n.decompile(B.input);if(!n.isPushOnly(w))throw new TypeError("Non push-only scriptSig")}}};if(c.input){const B=f();if(!B||B.length<1)throw new TypeError("Input too short");if(!te.isBuffer(y().output))throw new TypeError("Input is invalid");S(y())}if(c.redeem){if(c.redeem.network&&c.redeem.network!==u)throw new TypeError("Network mismatch");if(c.input){const B=y();if(c.redeem.output&&!c.redeem.output.equals(B.output))throw new TypeError("Redeem.output mismatch");if(c.redeem.input&&!c.redeem.input.equals(B.input))throw new TypeError("Redeem.input mismatch")}S(c.redeem)}if(c.witness&&c.redeem&&c.redeem.witness&&!(0,r.stacksEqual)(c.redeem.witness,c.witness))throw new TypeError("Witness and redeem.witness mismatch")}return Object.assign(d,c)}return kn.p2sh=s,kn}var On={},Pr={},Mu;function Gi(){if(Mu)return Pr;Mu=1,Object.defineProperty(Pr,"__esModule",{value:!0}),Pr.bech32m=Pr.bech32=void 0;const e="qpzry9x8gf2tvdw0s3jn54khce6mua7l",t={};for(let l=0;l<e.length;l++){const u=e.charAt(l);t[u]=l}function n(l){const u=l>>25;return(l&33554431)<<5^-(u>>0&1)&996825010^-(u>>1&1)&642813549^-(u>>2&1)&513874426^-(u>>3&1)&1027748829^-(u>>4&1)&705979059}function r(l){let u=1;for(let d=0;d<l.length;++d){const h=l.charCodeAt(d);if(h<33||h>126)return"Invalid prefix ("+l+")";u=n(u)^h>>5}u=n(u);for(let d=0;d<l.length;++d){const h=l.charCodeAt(d);u=n(u)^h&31}return u}function a(l,u,d,h){let f=0,y=0;const g=(1<<d)-1,S=[];for(let B=0;B<l.length;++B)for(f=f<<u|l[B],y+=u;y>=d;)y-=d,S.push(f>>y&g);if(h)y>0&&S.push(f<<d-y&g);else{if(y>=u)return"Excess padding";if(f<<d-y&g)return"Non-zero padding"}return S}function o(l){return a(l,8,5,!0)}function i(l){const u=a(l,5,8,!1);if(Array.isArray(u))return u}function s(l){const u=a(l,5,8,!1);if(Array.isArray(u))return u;throw new Error(u)}function c(l){let u;l==="bech32"?u=1:u=734539939;function d(g,S,B){if(B=B||90,g.length+7+S.length>B)throw new TypeError("Exceeds length limit");g=g.toLowerCase();let I=r(g);if(typeof I=="string")throw new Error(I);let b=g+"1";for(let w=0;w<S.length;++w){const x=S[w];if(x>>5!==0)throw new Error("Non 5-bit word");I=n(I)^x,b+=e.charAt(x)}for(let w=0;w<6;++w)I=n(I);I^=u;for(let w=0;w<6;++w){const x=I>>(5-w)*5&31;b+=e.charAt(x)}return b}function h(g,S){if(S=S||90,g.length<8)return g+" too short";if(g.length>S)return"Exceeds length limit";const B=g.toLowerCase(),I=g.toUpperCase();if(g!==B&&g!==I)return"Mixed-case string "+g;g=B;const b=g.lastIndexOf("1");if(b===-1)return"No separator character for "+g;if(b===0)return"Missing prefix for "+g;const w=g.slice(0,b),x=g.slice(b+1);if(x.length<6)return"Data too short";let _=r(w);if(typeof _=="string")return _;const N=[];for(let k=0;k<x.length;++k){const T=x.charAt(k),L=t[T];if(L===void 0)return"Unknown character "+T;_=n(_)^L,!(k+6>=x.length)&&N.push(L)}return _!==u?"Invalid checksum for "+g:{prefix:w,words:N}}function f(g,S){const B=h(g,S);if(typeof B=="object")return B}function y(g,S){const B=h(g,S);if(typeof B=="object")return B;throw new Error(B)}return{decodeUnsafe:f,decode:y,encode:d,toWords:o,fromWordsUnsafe:i,fromWords:s}}return Pr.bech32=c("bech32"),Pr.bech32m=c("bech32m"),Pr}var Cu;function yg(){if(Cu)return On;Cu=1,Object.defineProperty(On,"__esModule",{value:!0}),On.p2wpkh=void 0;const e=Wt(),t=wt(),n=et(),r=ze(),a=Ir(),o=Gi(),i=n.OPS,s=te.alloc(0);function c(l,u){if(!l.address&&!l.hash&&!l.output&&!l.pubkey&&!l.witness)throw new TypeError("Not enough data");u=Object.assign({validate:!0},u||{}),(0,r.typeforce)({address:r.typeforce.maybe(r.typeforce.String),hash:r.typeforce.maybe(r.typeforce.BufferN(20)),input:r.typeforce.maybe(r.typeforce.BufferN(0)),network:r.typeforce.maybe(r.typeforce.Object),output:r.typeforce.maybe(r.typeforce.BufferN(22)),pubkey:r.typeforce.maybe(r.isPoint),signature:r.typeforce.maybe(n.isCanonicalScriptSignature),witness:r.typeforce.maybe(r.typeforce.arrayOf(r.typeforce.Buffer))},l);const d=a.value(()=>{const y=o.bech32.decode(l.address),g=y.words.shift(),S=o.bech32.fromWords(y.words);return{version:g,prefix:y.prefix,data:te.from(S)}}),h=l.network||t.bitcoin,f={name:"p2wpkh",network:h};if(a.prop(f,"address",()=>{if(!f.hash)return;const y=o.bech32.toWords(f.hash);return y.unshift(0),o.bech32.encode(h.bech32,y)}),a.prop(f,"hash",()=>{if(l.output)return l.output.slice(2,22);if(l.address)return d().data;if(l.pubkey||f.pubkey)return e.hash160(l.pubkey||f.pubkey)}),a.prop(f,"output",()=>{if(f.hash)return n.compile([i.OP_0,f.hash])}),a.prop(f,"pubkey",()=>{if(l.pubkey)return l.pubkey;if(l.witness)return l.witness[1]}),a.prop(f,"signature",()=>{if(l.witness)return l.witness[0]}),a.prop(f,"input",()=>{if(f.witness)return s}),a.prop(f,"witness",()=>{if(l.pubkey&&l.signature)return[l.signature,l.pubkey]}),u.validate){let y=te.from([]);if(l.address){if(h&&h.bech32!==d().prefix)throw new TypeError("Invalid prefix or Network mismatch");if(d().version!==0)throw new TypeError("Invalid address version");if(d().data.length!==20)throw new TypeError("Invalid address data");y=d().data}if(l.hash){if(y.length>0&&!y.equals(l.hash))throw new TypeError("Hash mismatch");y=l.hash}if(l.output){if(l.output.length!==22||l.output[0]!==i.OP_0||l.output[1]!==20)throw new TypeError("Output is invalid");if(y.length>0&&!y.equals(l.output.slice(2)))throw new TypeError("Hash mismatch");y=l.output.slice(2)}if(l.pubkey){const g=e.hash160(l.pubkey);if(y.length>0&&!y.equals(g))throw new TypeError("Hash mismatch");if(y=g,!(0,r.isPoint)(l.pubkey)||l.pubkey.length!==33)throw new TypeError("Invalid pubkey for p2wpkh")}if(l.witness){if(l.witness.length!==2)throw new TypeError("Witness is invalid");if(!n.isCanonicalScriptSignature(l.witness[0]))throw new TypeError("Witness has invalid signature");if(!(0,r.isPoint)(l.witness[1])||l.witness[1].length!==33)throw new TypeError("Witness has invalid pubkey");if(l.signature&&!l.signature.equals(l.witness[0]))throw new TypeError("Signature mismatch");if(l.pubkey&&!l.pubkey.equals(l.witness[1]))throw new TypeError("Pubkey mismatch");const g=e.hash160(l.witness[1]);if(y.length>0&&!y.equals(g))throw new TypeError("Hash mismatch")}}return Object.assign(f,l)}return On.p2wpkh=c,On}var Rn={},ju;function gg(){if(ju)return Rn;ju=1,Object.defineProperty(Rn,"__esModule",{value:!0}),Rn.p2wsh=void 0;const e=Wt(),t=wt(),n=et(),r=ze(),a=Ir(),o=Gi(),i=n.OPS,s=te.alloc(0);function c(u){return!!(te.isBuffer(u)&&u.length===65&&u[0]===4&&(0,r.isPoint)(u))}function l(u,d){if(!u.address&&!u.hash&&!u.output&&!u.redeem&&!u.witness)throw new TypeError("Not enough data");d=Object.assign({validate:!0},d||{}),(0,r.typeforce)({network:r.typeforce.maybe(r.typeforce.Object),address:r.typeforce.maybe(r.typeforce.String),hash:r.typeforce.maybe(r.typeforce.BufferN(32)),output:r.typeforce.maybe(r.typeforce.BufferN(34)),redeem:r.typeforce.maybe({input:r.typeforce.maybe(r.typeforce.Buffer),network:r.typeforce.maybe(r.typeforce.Object),output:r.typeforce.maybe(r.typeforce.Buffer),witness:r.typeforce.maybe(r.typeforce.arrayOf(r.typeforce.Buffer))}),input:r.typeforce.maybe(r.typeforce.BufferN(0)),witness:r.typeforce.maybe(r.typeforce.arrayOf(r.typeforce.Buffer))},u);const h=a.value(()=>{const S=o.bech32.decode(u.address),B=S.words.shift(),I=o.bech32.fromWords(S.words);return{version:B,prefix:S.prefix,data:te.from(I)}}),f=a.value(()=>n.decompile(u.redeem.input));let y=u.network;y||(y=u.redeem&&u.redeem.network||t.bitcoin);const g={network:y};if(a.prop(g,"address",()=>{if(!g.hash)return;const S=o.bech32.toWords(g.hash);return S.unshift(0),o.bech32.encode(y.bech32,S)}),a.prop(g,"hash",()=>{if(u.output)return u.output.slice(2);if(u.address)return h().data;if(g.redeem&&g.redeem.output)return e.sha256(g.redeem.output)}),a.prop(g,"output",()=>{if(g.hash)return n.compile([i.OP_0,g.hash])}),a.prop(g,"redeem",()=>{if(u.witness)return{output:u.witness[u.witness.length-1],input:s,witness:u.witness.slice(0,-1)}}),a.prop(g,"input",()=>{if(g.witness)return s}),a.prop(g,"witness",()=>{if(u.redeem&&u.redeem.input&&u.redeem.input.length>0&&u.redeem.output&&u.redeem.output.length>0){const S=n.toStack(f());return g.redeem=Object.assign({witness:S},u.redeem),g.redeem.input=s,[].concat(S,u.redeem.output)}if(u.redeem&&u.redeem.output&&u.redeem.witness)return[].concat(u.redeem.witness,u.redeem.output)}),a.prop(g,"name",()=>{const S=["p2wsh"];return g.redeem!==void 0&&g.redeem.name!==void 0&&S.push(g.redeem.name),S.join("-")}),d.validate){let S=te.from([]);if(u.address){if(h().prefix!==y.bech32)throw new TypeError("Invalid prefix or Network mismatch");if(h().version!==0)throw new TypeError("Invalid address version");if(h().data.length!==32)throw new TypeError("Invalid address data");S=h().data}if(u.hash){if(S.length>0&&!S.equals(u.hash))throw new TypeError("Hash mismatch");S=u.hash}if(u.output){if(u.output.length!==34||u.output[0]!==i.OP_0||u.output[1]!==32)throw new TypeError("Output is invalid");const B=u.output.slice(2);if(S.length>0&&!S.equals(B))throw new TypeError("Hash mismatch");S=B}if(u.redeem){if(u.redeem.network&&u.redeem.network!==y)throw new TypeError("Network mismatch");if(u.redeem.input&&u.redeem.input.length>0&&u.redeem.witness&&u.redeem.witness.length>0)throw new TypeError("Ambiguous witness source");if(u.redeem.output){const B=n.decompile(u.redeem.output);if(!B||B.length<1)throw new TypeError("Redeem.output is invalid");if(u.redeem.output.byteLength>3600)throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");if(n.countNonPushOnlyOPs(B)>201)throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");const I=e.sha256(u.redeem.output);if(S.length>0&&!S.equals(I))throw new TypeError("Hash mismatch");S=I}if(u.redeem.input&&!n.isPushOnly(f()))throw new TypeError("Non push-only scriptSig");if(u.witness&&u.redeem.witness&&!(0,r.stacksEqual)(u.witness,u.redeem.witness))throw new TypeError("Witness and redeem.witness mismatch");if(u.redeem.input&&f().some(c)||u.redeem.output&&(n.decompile(u.redeem.output)||[]).some(c))throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey")}if(u.witness&&u.witness.length>0){const B=u.witness[u.witness.length-1];if(u.redeem&&u.redeem.output&&!u.redeem.output.equals(B))throw new TypeError("Witness and redeem.output mismatch");if(u.witness.some(c)||(n.decompile(B)||[]).some(c))throw new TypeError("Witness contains uncompressed pubkey")}}return Object.assign(g,u)}return Rn.p2wsh=l,Rn}var Pn={},Ur={},qu;function Ia(){if(qu)return Ur;qu=1,Object.defineProperty(Ur,"__esModule",{value:!0}),Ur.getEccLib=Ur.initEccLib=void 0;const e={};function t(s,c){s?s!==e.eccLib&&(c?.DANGER_DO_NOT_VERIFY_ECCLIB||a(s),e.eccLib=s):e.eccLib=s}Ur.initEccLib=t;function n(){if(!e.eccLib)throw new Error("No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance");return e.eccLib}Ur.getEccLib=n;const r=s=>te.from(s,"hex");function a(s){o(typeof s.isXOnlyPoint=="function"),o(s.isXOnlyPoint(r("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))),o(s.isXOnlyPoint(r("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e"))),o(s.isXOnlyPoint(r("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9"))),o(s.isXOnlyPoint(r("0000000000000000000000000000000000000000000000000000000000000001"))),o(!s.isXOnlyPoint(r("0000000000000000000000000000000000000000000000000000000000000000"))),o(!s.isXOnlyPoint(r("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"))),o(typeof s.xOnlyPointAddTweak=="function"),i.forEach(c=>{const l=s.xOnlyPointAddTweak(r(c.pubkey),r(c.tweak));c.result===null?o(l===null):(o(l!==null),o(l.parity===c.parity),o(te.from(l.xOnlyPubkey).equals(r(c.result))))})}function o(s){if(!s)throw new Error("ecc library invalid")}const i=[{pubkey:"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",tweak:"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",parity:-1,result:null},{pubkey:"1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",tweak:"a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",parity:1,result:"e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"},{pubkey:"2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",tweak:"823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",parity:0,result:"9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"}];return Ur}var ms={},Ce={},bs,Ku;function wg(){if(Ku)return bs;Ku=1;var e=Kl().Buffer,t=9007199254740991;function n(i){if(i<0||i>t||i%1!==0)throw new RangeError("value out of range")}function r(i,s,c){if(n(i),s||(s=e.allocUnsafe(o(i))),!e.isBuffer(s))throw new TypeError("buffer must be a Buffer instance");return c||(c=0),i<253?(s.writeUInt8(i,c),r.bytes=1):i<=65535?(s.writeUInt8(253,c),s.writeUInt16LE(i,c+1),r.bytes=3):i<=4294967295?(s.writeUInt8(254,c),s.writeUInt32LE(i,c+1),r.bytes=5):(s.writeUInt8(255,c),s.writeUInt32LE(i>>>0,c+1),s.writeUInt32LE(i/4294967296|0,c+5),r.bytes=9),s}function a(i,s){if(!e.isBuffer(i))throw new TypeError("buffer must be a Buffer instance");s||(s=0);var c=i.readUInt8(s);if(c<253)return a.bytes=1,c;if(c===253)return a.bytes=3,i.readUInt16LE(s+1);if(c===254)return a.bytes=5,i.readUInt32LE(s+1);a.bytes=9;var l=i.readUInt32LE(s+1),u=i.readUInt32LE(s+5),d=u*4294967296+l;return n(d),d}function o(i){return n(i),i<253?1:i<=65535?3:i<=4294967295?5:9}return bs={encode:r,decode:a,encodingLength:o},bs}var Vu;function Wi(){if(Vu)return Ce;Vu=1,Object.defineProperty(Ce,"__esModule",{value:!0}),Ce.BufferReader=Ce.BufferWriter=Ce.cloneBuffer=Ce.reverseBuffer=Ce.writeUInt64LE=Ce.readUInt64LE=Ce.varuint=void 0;const e=ze(),{typeforce:t}=e,n=wg();Ce.varuint=n;function r(u,d){if(typeof u!="number")throw new Error("cannot write a non-number as a number");if(u<0)throw new Error("specified a negative value for writing an unsigned value");if(u>d)throw new Error("RangeError: value out of range");if(Math.floor(u)!==u)throw new Error("value has a fractional component")}function a(u,d){const h=u.readUInt32LE(d);let f=u.readUInt32LE(d+4);return f*=4294967296,r(f+h,9007199254740991),f+h}Ce.readUInt64LE=a;function o(u,d,h){return r(d,9007199254740991),u.writeInt32LE(d&-1,h),u.writeUInt32LE(Math.floor(d/4294967296),h+4),h+8}Ce.writeUInt64LE=o;function i(u){if(u.length<1)return u;let d=u.length-1,h=0;for(let f=0;f<u.length/2;f++)h=u[f],u[f]=u[d],u[d]=h,d--;return u}Ce.reverseBuffer=i;function s(u){const d=te.allocUnsafe(u.length);return u.copy(d),d}Ce.cloneBuffer=s;class c{static withCapacity(d){return new c(te.alloc(d))}constructor(d,h=0){this.buffer=d,this.offset=h,t(e.tuple(e.Buffer,e.UInt32),[d,h])}writeUInt8(d){this.offset=this.buffer.writeUInt8(d,this.offset)}writeInt32(d){this.offset=this.buffer.writeInt32LE(d,this.offset)}writeUInt32(d){this.offset=this.buffer.writeUInt32LE(d,this.offset)}writeUInt64(d){this.offset=o(this.buffer,d,this.offset)}writeVarInt(d){n.encode(d,this.buffer,this.offset),this.offset+=n.encode.bytes}writeSlice(d){if(this.buffer.length<this.offset+d.length)throw new Error("Cannot write slice out of bounds");this.offset+=d.copy(this.buffer,this.offset)}writeVarSlice(d){this.writeVarInt(d.length),this.writeSlice(d)}writeVector(d){this.writeVarInt(d.length),d.forEach(h=>this.writeVarSlice(h))}end(){if(this.buffer.length===this.offset)return this.buffer;throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`)}}Ce.BufferWriter=c;class l{constructor(d,h=0){this.buffer=d,this.offset=h,t(e.tuple(e.Buffer,e.UInt32),[d,h])}readUInt8(){const d=this.buffer.readUInt8(this.offset);return this.offset++,d}readInt32(){const d=this.buffer.readInt32LE(this.offset);return this.offset+=4,d}readUInt32(){const d=this.buffer.readUInt32LE(this.offset);return this.offset+=4,d}readUInt64(){const d=a(this.buffer,this.offset);return this.offset+=8,d}readVarInt(){const d=n.decode(this.buffer,this.offset);return this.offset+=n.decode.bytes,d}readSlice(d){if(this.buffer.length<this.offset+d)throw new Error("Cannot read slice out of bounds");const h=this.buffer.slice(this.offset,this.offset+d);return this.offset+=d,h}readVarSlice(){return this.readSlice(this.readVarInt())}readVector(){const d=this.readVarInt(),h=[];for(let f=0;f<d;f++)h.push(this.readVarSlice());return h}}return Ce.BufferReader=l,Ce}var Gu;function _a(){return Gu||(Gu=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.tweakKey=e.tapTweakHash=e.tapleafHash=e.findScriptPath=e.toHashTree=e.rootHashFromPath=e.MAX_TAPTREE_DEPTH=e.LEAF_VERSION_TAPSCRIPT=void 0;const t=Ci(),n=Ia(),r=Wt(),a=Wi(),o=ze();e.LEAF_VERSION_TAPSCRIPT=192,e.MAX_TAPTREE_DEPTH=128;const i=g=>"left"in g&&"right"in g;function s(g,S){if(g.length<33)throw new TypeError(`The control-block length is too small. Got ${g.length}, expected min 33.`);const B=(g.length-33)/32;let I=S;for(let b=0;b<B;b++){const w=g.slice(33+32*b,65+32*b);I.compare(w)<0?I=f(I,w):I=f(w,I)}return I}e.rootHashFromPath=s;function c(g){if((0,o.isTapleaf)(g))return{hash:u(g)};const S=[c(g[0]),c(g[1])];S.sort((b,w)=>b.hash.compare(w.hash));const[B,I]=S;return{hash:f(B.hash,I.hash),left:B,right:I}}e.toHashTree=c;function l(g,S){if(i(g)){const B=l(g.left,S);if(B!==void 0)return[...B,g.right.hash];const I=l(g.right,S);if(I!==void 0)return[...I,g.left.hash]}else if(g.hash.equals(S))return[]}e.findScriptPath=l;function u(g){const S=g.version||e.LEAF_VERSION_TAPSCRIPT;return r.taggedHash("TapLeaf",t.Buffer.concat([t.Buffer.from([S]),y(g.output)]))}e.tapleafHash=u;function d(g,S){return r.taggedHash("TapTweak",t.Buffer.concat(S?[g,S]:[g]))}e.tapTweakHash=d;function h(g,S){if(!t.Buffer.isBuffer(g)||g.length!==32||S&&S.length!==32)return null;const B=d(g,S),I=(0,n.getEccLib)().xOnlyPointAddTweak(g,B);return!I||I.xOnlyPubkey===null?null:{parity:I.parity,x:t.Buffer.from(I.xOnlyPubkey)}}e.tweakKey=h;function f(g,S){return r.taggedHash("TapBranch",t.Buffer.concat([g,S]))}function y(g){const S=a.varuint.encodingLength(g.length),B=t.Buffer.allocUnsafe(S);return a.varuint.encode(g.length,B),t.Buffer.concat([B,g])}})(ms)),ms}var Wu;function mg(){if(Wu)return Pn;Wu=1,Object.defineProperty(Pn,"__esModule",{value:!0}),Pn.p2tr=void 0;const e=Ci(),t=wt(),n=et(),r=ze(),a=Ia(),o=_a(),i=Ir(),s=Gi(),c=Aa(),l=n.OPS,u=1,d=80;function h(f,y){if(!f.address&&!f.output&&!f.pubkey&&!f.internalPubkey&&!(f.witness&&f.witness.length>1))throw new TypeError("Not enough data");y=Object.assign({validate:!0},y||{}),(0,r.typeforce)({address:r.typeforce.maybe(r.typeforce.String),input:r.typeforce.maybe(r.typeforce.BufferN(0)),network:r.typeforce.maybe(r.typeforce.Object),output:r.typeforce.maybe(r.typeforce.BufferN(34)),internalPubkey:r.typeforce.maybe(r.typeforce.BufferN(32)),hash:r.typeforce.maybe(r.typeforce.BufferN(32)),pubkey:r.typeforce.maybe(r.typeforce.BufferN(32)),signature:r.typeforce.maybe(r.typeforce.anyOf(r.typeforce.BufferN(64),r.typeforce.BufferN(65))),witness:r.typeforce.maybe(r.typeforce.arrayOf(r.typeforce.Buffer)),scriptTree:r.typeforce.maybe(r.isTaptree),redeem:r.typeforce.maybe({output:r.typeforce.maybe(r.typeforce.Buffer),redeemVersion:r.typeforce.maybe(r.typeforce.Number),witness:r.typeforce.maybe(r.typeforce.arrayOf(r.typeforce.Buffer))}),redeemVersion:r.typeforce.maybe(r.typeforce.Number)},f);const g=i.value(()=>(0,c.fromBech32)(f.address)),S=i.value(()=>{if(!(!f.witness||!f.witness.length))return f.witness.length>=2&&f.witness[f.witness.length-1][0]===d?f.witness.slice(0,-1):f.witness.slice()}),B=i.value(()=>{if(f.scriptTree)return(0,o.toHashTree)(f.scriptTree);if(f.hash)return{hash:f.hash}}),I=f.network||t.bitcoin,b={name:"p2tr",network:I};if(i.prop(b,"address",()=>{if(!b.pubkey)return;const w=s.bech32m.toWords(b.pubkey);return w.unshift(u),s.bech32m.encode(I.bech32,w)}),i.prop(b,"hash",()=>{const w=B();if(w)return w.hash;const x=S();if(x&&x.length>1){const _=x[x.length-1],N=_[0]&r.TAPLEAF_VERSION_MASK,k=x[x.length-2],T=(0,o.tapleafHash)({output:k,version:N});return(0,o.rootHashFromPath)(_,T)}return null}),i.prop(b,"output",()=>{if(b.pubkey)return n.compile([l.OP_1,b.pubkey])}),i.prop(b,"redeemVersion",()=>f.redeemVersion?f.redeemVersion:f.redeem&&f.redeem.redeemVersion!==void 0&&f.redeem.redeemVersion!==null?f.redeem.redeemVersion:o.LEAF_VERSION_TAPSCRIPT),i.prop(b,"redeem",()=>{const w=S();if(!(!w||w.length<2))return{output:w[w.length-2],witness:w.slice(0,-2),redeemVersion:w[w.length-1][0]&r.TAPLEAF_VERSION_MASK}}),i.prop(b,"pubkey",()=>{if(f.pubkey)return f.pubkey;if(f.output)return f.output.slice(2);if(f.address)return g().data;if(b.internalPubkey){const w=(0,o.tweakKey)(b.internalPubkey,b.hash);if(w)return w.x}}),i.prop(b,"internalPubkey",()=>{if(f.internalPubkey)return f.internalPubkey;const w=S();if(w&&w.length>1)return w[w.length-1].slice(1,33)}),i.prop(b,"signature",()=>{if(f.signature)return f.signature;const w=S();if(!(!w||w.length!==1))return w[0]}),i.prop(b,"witness",()=>{if(f.witness)return f.witness;const w=B();if(w&&f.redeem&&f.redeem.output&&f.internalPubkey){const x=(0,o.tapleafHash)({output:f.redeem.output,version:b.redeemVersion}),_=(0,o.findScriptPath)(w,x);if(!_)return;const N=(0,o.tweakKey)(f.internalPubkey,w.hash);if(!N)return;const k=e.Buffer.concat([e.Buffer.from([b.redeemVersion|N.parity]),f.internalPubkey].concat(_));return[f.redeem.output,k]}if(f.signature)return[f.signature]}),y.validate){let w=e.Buffer.from([]);if(f.address){if(I&&I.bech32!==g().prefix)throw new TypeError("Invalid prefix or Network mismatch");if(g().version!==u)throw new TypeError("Invalid address version");if(g().data.length!==32)throw new TypeError("Invalid address data");w=g().data}if(f.pubkey){if(w.length>0&&!w.equals(f.pubkey))throw new TypeError("Pubkey mismatch");w=f.pubkey}if(f.output){if(f.output.length!==34||f.output[0]!==l.OP_1||f.output[1]!==32)throw new TypeError("Output is invalid");if(w.length>0&&!w.equals(f.output.slice(2)))throw new TypeError("Pubkey mismatch");w=f.output.slice(2)}if(f.internalPubkey){const N=(0,o.tweakKey)(f.internalPubkey,b.hash);if(w.length>0&&!w.equals(N.x))throw new TypeError("Pubkey mismatch");w=N.x}if(w&&w.length&&!(0,a.getEccLib)().isXOnlyPoint(w))throw new TypeError("Invalid pubkey for p2tr");const x=B();if(f.hash&&x&&!f.hash.equals(x.hash))throw new TypeError("Hash mismatch");if(f.redeem&&f.redeem.output&&x){const N=(0,o.tapleafHash)({output:f.redeem.output,version:b.redeemVersion});if(!(0,o.findScriptPath)(x,N))throw new TypeError("Redeem script not in tree")}const _=S();if(f.redeem&&b.redeem){if(f.redeem.redeemVersion&&f.redeem.redeemVersion!==b.redeem.redeemVersion)throw new TypeError("Redeem.redeemVersion and witness mismatch");if(f.redeem.output){if(n.decompile(f.redeem.output).length===0)throw new TypeError("Redeem.output is invalid");if(b.redeem.output&&!f.redeem.output.equals(b.redeem.output))throw new TypeError("Redeem.output and witness mismatch")}if(f.redeem.witness&&b.redeem.witness&&!(0,r.stacksEqual)(f.redeem.witness,b.redeem.witness))throw new TypeError("Redeem.witness and witness mismatch")}if(_&&_.length)if(_.length===1){if(f.signature&&!f.signature.equals(_[0]))throw new TypeError("Signature mismatch")}else{const N=_[_.length-1];if(N.length<33)throw new TypeError(`The control-block length is too small. Got ${N.length}, expected min 33.`);if((N.length-33)%32!==0)throw new TypeError(`The control-block length of ${N.length} is incorrect!`);const k=(N.length-33)/32;if(k>128)throw new TypeError(`The script path is too long. Got ${k}, expected max 128.`);const T=N.slice(1,33);if(f.internalPubkey&&!f.internalPubkey.equals(T))throw new TypeError("Internal pubkey mismatch");if(!(0,a.getEccLib)().isXOnlyPoint(T))throw new TypeError("Invalid internalPubkey for p2tr witness");const L=N[0]&r.TAPLEAF_VERSION_MASK,F=_[_.length-2],O=(0,o.tapleafHash)({output:F,version:L}),R=(0,o.rootHashFromPath)(N,O),P=(0,o.tweakKey)(T,R);if(!P)throw new TypeError("Invalid outputKey for p2tr witness");if(w.length&&!w.equals(P.x))throw new TypeError("Pubkey mismatch for p2tr witness");if(P.parity!==(N[0]&1))throw new Error("Incorrect parity")}}return Object.assign(b,f)}return Pn.p2tr=h,Pn}var $u;function Xn(){return $u||($u=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.p2tr=e.p2wsh=e.p2wpkh=e.p2sh=e.p2pkh=e.p2pk=e.p2ms=e.embed=void 0;const t=rg();Object.defineProperty(e,"embed",{enumerable:!0,get:function(){return t.p2data}});const n=ng();Object.defineProperty(e,"p2ms",{enumerable:!0,get:function(){return n.p2ms}});const r=ig();Object.defineProperty(e,"p2pk",{enumerable:!0,get:function(){return r.p2pk}});const a=hg();Object.defineProperty(e,"p2pkh",{enumerable:!0,get:function(){return a.p2pkh}});const o=pg();Object.defineProperty(e,"p2sh",{enumerable:!0,get:function(){return o.p2sh}});const i=yg();Object.defineProperty(e,"p2wpkh",{enumerable:!0,get:function(){return i.p2wpkh}});const s=gg();Object.defineProperty(e,"p2wsh",{enumerable:!0,get:function(){return s.p2wsh}});const c=mg();Object.defineProperty(e,"p2tr",{enumerable:!0,get:function(){return c.p2tr}})})(os)),os}var Xu;function Aa(){if(Xu)return Je;Xu=1,Object.defineProperty(Je,"__esModule",{value:!0}),Je.toOutputScript=Je.fromOutputScript=Je.toBech32=Je.toBase58Check=Je.fromBech32=Je.fromBase58Check=void 0;const e=wt(),t=Xn(),n=et(),r=ze(),a=Gi(),o=Sa(),i=40,s=2,c=16,l=2,u=80,d="WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";function h(b,w){const x=b.slice(2);if(x.length<s||x.length>i)throw new TypeError("Invalid program length for segwit address");const _=b[0]-u;if(_<l||_>c)throw new TypeError("Invalid version for segwit address");if(b[1]!==x.length)throw new TypeError("Invalid script for segwit address");return console.warn(d),S(x,_,w.bech32)}function f(b){const w=te.from(o.decode(b));if(w.length<21)throw new TypeError(b+" is too short");if(w.length>21)throw new TypeError(b+" is too long");const x=w.readUInt8(0),_=w.slice(1);return{version:x,hash:_}}Je.fromBase58Check=f;function y(b){let w,x;try{w=a.bech32.decode(b)}catch{}if(w){if(x=w.words[0],x!==0)throw new TypeError(b+" uses wrong encoding")}else if(w=a.bech32m.decode(b),x=w.words[0],x===0)throw new TypeError(b+" uses wrong encoding");const _=a.bech32.fromWords(w.words.slice(1));return{version:x,prefix:w.prefix,data:te.from(_)}}Je.fromBech32=y;function g(b,w){(0,r.typeforce)((0,r.tuple)(r.Hash160bit,r.UInt8),arguments);const x=te.allocUnsafe(21);return x.writeUInt8(w,0),b.copy(x,1),o.encode(x)}Je.toBase58Check=g;function S(b,w,x){const _=a.bech32.toWords(b);return _.unshift(w),w===0?a.bech32.encode(x,_):a.bech32m.encode(x,_)}Je.toBech32=S;function B(b,w){w=w||e.bitcoin;try{return t.p2pkh({output:b,network:w}).address}catch{}try{return t.p2sh({output:b,network:w}).address}catch{}try{return t.p2wpkh({output:b,network:w}).address}catch{}try{return t.p2wsh({output:b,network:w}).address}catch{}try{return t.p2tr({output:b,network:w}).address}catch{}try{return h(b,w)}catch{}throw new Error(n.toASM(b)+" has no matching Address")}Je.fromOutputScript=B;function I(b,w){w=w||e.bitcoin;let x,_;try{x=f(b)}catch{}if(x){if(x.version===w.pubKeyHash)return t.p2pkh({hash:x.hash}).output;if(x.version===w.scriptHash)return t.p2sh({hash:x.hash}).output}else{try{_=y(b)}catch{}if(_){if(_.prefix!==w.bech32)throw new Error(b+" has an invalid prefix");if(_.version===0){if(_.data.length===20)return t.p2wpkh({hash:_.data}).output;if(_.data.length===32)return t.p2wsh({hash:_.data}).output}else if(_.version===1){if(_.data.length===32)return t.p2tr({pubkey:_.data}).output}else if(_.version>=l&&_.version<=c&&_.data.length>=s&&_.data.length<=i)return console.warn(d),n.compile([_.version+u,_.data])}}throw new Error(b+" has no matching Script")}return Je.toOutputScript=I,Je}var Un={},Hn={},zu;function bg(){if(zu)return Hn;zu=1,Object.defineProperty(Hn,"__esModule",{value:!0}),Hn.fastMerkleRoot=void 0;function e(t,n){if(!Array.isArray(t))throw TypeError("Expected values Array");if(typeof n!="function")throw TypeError("Expected digest Function");let r=t.length;const a=t.concat();for(;r>1;){let o=0;for(let i=0;i<r;i+=2,++o){const s=a[i],c=i+1===r?s:a[i+1],l=te.concat([s,c]);a[o]=n(l)}r=o}return a[0]}return Hn.fastMerkleRoot=e,Hn}var Ln={},Ju;function zn(){if(Ju)return Ln;Ju=1,Object.defineProperty(Ln,"__esModule",{value:!0}),Ln.Transaction=void 0;const e=Wi(),t=Wt(),n=et(),r=et(),a=ze(),{typeforce:o}=a;function i(S){const B=S.length;return e.varuint.encodingLength(B)+B}function s(S){const B=S.length;return e.varuint.encodingLength(B)+S.reduce((I,b)=>I+i(b),0)}const c=te.allocUnsafe(0),l=[],u=te.from("0000000000000000000000000000000000000000000000000000000000000000","hex"),d=te.from("0000000000000000000000000000000000000000000000000000000000000001","hex"),h=te.from("ffffffffffffffff","hex"),f={script:c,valueBuffer:h};function y(S){return S.value!==void 0}class g{constructor(){this.version=1,this.locktime=0,this.ins=[],this.outs=[]}static fromBuffer(B,I){const b=new e.BufferReader(B),w=new g;w.version=b.readInt32();const x=b.readUInt8(),_=b.readUInt8();let N=!1;x===g.ADVANCED_TRANSACTION_MARKER&&_===g.ADVANCED_TRANSACTION_FLAG?N=!0:b.offset-=2;const k=b.readVarInt();for(let L=0;L<k;++L)w.ins.push({hash:b.readSlice(32),index:b.readUInt32(),script:b.readVarSlice(),sequence:b.readUInt32(),witness:l});const T=b.readVarInt();for(let L=0;L<T;++L)w.outs.push({value:b.readUInt64(),script:b.readVarSlice()});if(N){for(let L=0;L<k;++L)w.ins[L].witness=b.readVector();if(!w.hasWitnesses())throw new Error("Transaction has superfluous witness data")}if(w.locktime=b.readUInt32(),I)return w;if(b.offset!==B.length)throw new Error("Transaction has unexpected data");return w}static fromHex(B){return g.fromBuffer(te.from(B,"hex"),!1)}static isCoinbaseHash(B){o(a.Hash256bit,B);for(let I=0;I<32;++I)if(B[I]!==0)return!1;return!0}isCoinbase(){return this.ins.length===1&&g.isCoinbaseHash(this.ins[0].hash)}addInput(B,I,b,w){return o(a.tuple(a.Hash256bit,a.UInt32,a.maybe(a.UInt32),a.maybe(a.Buffer)),arguments),a.Null(b)&&(b=g.DEFAULT_SEQUENCE),this.ins.push({hash:B,index:I,script:w||c,sequence:b,witness:l})-1}addOutput(B,I){return o(a.tuple(a.Buffer,a.Satoshi),arguments),this.outs.push({script:B,value:I})-1}hasWitnesses(){return this.ins.some(B=>B.witness.length!==0)}stripWitnesses(){this.ins.forEach(B=>{B.witness=l})}weight(){const B=this.byteLength(!1),I=this.byteLength(!0);return B*3+I}virtualSize(){return Math.ceil(this.weight()/4)}byteLength(B=!0){const I=B&&this.hasWitnesses();return(I?10:8)+e.varuint.encodingLength(this.ins.length)+e.varuint.encodingLength(this.outs.length)+this.ins.reduce((b,w)=>b+40+i(w.script),0)+this.outs.reduce((b,w)=>b+8+i(w.script),0)+(I?this.ins.reduce((b,w)=>b+s(w.witness),0):0)}clone(){const B=new g;return B.version=this.version,B.locktime=this.locktime,B.ins=this.ins.map(I=>({hash:I.hash,index:I.index,script:I.script,sequence:I.sequence,witness:I.witness})),B.outs=this.outs.map(I=>({script:I.script,value:I.value})),B}hashForSignature(B,I,b){if(o(a.tuple(a.UInt32,a.Buffer,a.Number),arguments),B>=this.ins.length)return d;const w=n.compile(n.decompile(I).filter(N=>N!==r.OPS.OP_CODESEPARATOR)),x=this.clone();if((b&31)===g.SIGHASH_NONE)x.outs=[],x.ins.forEach((N,k)=>{k!==B&&(N.sequence=0)});else if((b&31)===g.SIGHASH_SINGLE){if(B>=this.outs.length)return d;x.outs.length=B+1;for(let N=0;N<B;N++)x.outs[N]=f;x.ins.forEach((N,k)=>{k!==B&&(N.sequence=0)})}b&g.SIGHASH_ANYONECANPAY?(x.ins=[x.ins[B]],x.ins[0].script=w):(x.ins.forEach(N=>{N.script=c}),x.ins[B].script=w);const _=te.allocUnsafe(x.byteLength(!1)+4);return _.writeInt32LE(b,_.length-4),x.__toBuffer(_,0,!1),t.hash256(_)}hashForWitnessV1(B,I,b,w,x,_){if(o(a.tuple(a.UInt32,o.arrayOf(a.Buffer),o.arrayOf(a.Satoshi),a.UInt32),arguments),b.length!==this.ins.length||I.length!==this.ins.length)throw new Error("Must supply prevout script and value for all inputs");const N=w===g.SIGHASH_DEFAULT?g.SIGHASH_ALL:w&g.SIGHASH_OUTPUT_MASK,T=(w&g.SIGHASH_INPUT_MASK)===g.SIGHASH_ANYONECANPAY,L=N===g.SIGHASH_NONE,F=N===g.SIGHASH_SINGLE;let O=c,R=c,P=c,K=c,U=c;if(!T){let D=e.BufferWriter.withCapacity(36*this.ins.length);this.ins.forEach(W=>{D.writeSlice(W.hash),D.writeUInt32(W.index)}),O=t.sha256(D.end()),D=e.BufferWriter.withCapacity(8*this.ins.length),b.forEach(W=>D.writeUInt64(W)),R=t.sha256(D.end()),D=e.BufferWriter.withCapacity(I.map(i).reduce((W,J)=>W+J)),I.forEach(W=>D.writeVarSlice(W)),P=t.sha256(D.end()),D=e.BufferWriter.withCapacity(4*this.ins.length),this.ins.forEach(W=>D.writeUInt32(W.sequence)),K=t.sha256(D.end())}if(L||F){if(F&&B<this.outs.length){const D=this.outs[B],W=e.BufferWriter.withCapacity(8+i(D.script));W.writeUInt64(D.value),W.writeVarSlice(D.script),U=t.sha256(W.end())}}else{const D=this.outs.map(J=>8+i(J.script)).reduce((J,re)=>J+re),W=e.BufferWriter.withCapacity(D);this.outs.forEach(J=>{W.writeUInt64(J.value),W.writeVarSlice(J.script)}),U=t.sha256(W.end())}const V=(x?2:0)+(_?1:0),C=174-(T?49:0)-(L?32:0)+(_?32:0)+(x?37:0),H=e.BufferWriter.withCapacity(C);if(H.writeUInt8(w),H.writeInt32(this.version),H.writeUInt32(this.locktime),H.writeSlice(O),H.writeSlice(R),H.writeSlice(P),H.writeSlice(K),L||F||H.writeSlice(U),H.writeUInt8(V),T){const D=this.ins[B];H.writeSlice(D.hash),H.writeUInt32(D.index),H.writeUInt64(b[B]),H.writeVarSlice(I[B]),H.writeUInt32(D.sequence)}else H.writeUInt32(B);if(_){const D=e.BufferWriter.withCapacity(i(_));D.writeVarSlice(_),H.writeSlice(t.sha256(D.end()))}return F&&H.writeSlice(U),x&&(H.writeSlice(x),H.writeUInt8(0),H.writeUInt32(4294967295)),t.taggedHash("TapSighash",te.concat([te.from([0]),H.end()]))}hashForWitnessV0(B,I,b,w){o(a.tuple(a.UInt32,a.Buffer,a.Satoshi,a.UInt32),arguments);let x=te.from([]),_,N=u,k=u,T=u;if(w&g.SIGHASH_ANYONECANPAY||(x=te.allocUnsafe(36*this.ins.length),_=new e.BufferWriter(x,0),this.ins.forEach(F=>{_.writeSlice(F.hash),_.writeUInt32(F.index)}),k=t.hash256(x)),!(w&g.SIGHASH_ANYONECANPAY)&&(w&31)!==g.SIGHASH_SINGLE&&(w&31)!==g.SIGHASH_NONE&&(x=te.allocUnsafe(4*this.ins.length),_=new e.BufferWriter(x,0),this.ins.forEach(F=>{_.writeUInt32(F.sequence)}),T=t.hash256(x)),(w&31)!==g.SIGHASH_SINGLE&&(w&31)!==g.SIGHASH_NONE){const F=this.outs.reduce((O,R)=>O+8+i(R.script),0);x=te.allocUnsafe(F),_=new e.BufferWriter(x,0),this.outs.forEach(O=>{_.writeUInt64(O.value),_.writeVarSlice(O.script)}),N=t.hash256(x)}else if((w&31)===g.SIGHASH_SINGLE&&B<this.outs.length){const F=this.outs[B];x=te.allocUnsafe(8+i(F.script)),_=new e.BufferWriter(x,0),_.writeUInt64(F.value),_.writeVarSlice(F.script),N=t.hash256(x)}x=te.allocUnsafe(156+i(I)),_=new e.BufferWriter(x,0);const L=this.ins[B];return _.writeInt32(this.version),_.writeSlice(k),_.writeSlice(T),_.writeSlice(L.hash),_.writeUInt32(L.index),_.writeVarSlice(I),_.writeUInt64(b),_.writeUInt32(L.sequence),_.writeSlice(N),_.writeUInt32(this.locktime),_.writeUInt32(w),t.hash256(x)}getHash(B){return B&&this.isCoinbase()?te.alloc(32,0):t.hash256(this.__toBuffer(void 0,void 0,B))}getId(){return(0,e.reverseBuffer)(this.getHash(!1)).toString("hex")}toBuffer(B,I){return this.__toBuffer(B,I,!0)}toHex(){return this.toBuffer(void 0,void 0).toString("hex")}setInputScript(B,I){o(a.tuple(a.Number,a.Buffer),arguments),this.ins[B].script=I}setWitness(B,I){o(a.tuple(a.Number,[a.Buffer]),arguments),this.ins[B].witness=I}__toBuffer(B,I,b=!1){B||(B=te.allocUnsafe(this.byteLength(b)));const w=new e.BufferWriter(B,I||0);w.writeInt32(this.version);const x=b&&this.hasWitnesses();return x&&(w.writeUInt8(g.ADVANCED_TRANSACTION_MARKER),w.writeUInt8(g.ADVANCED_TRANSACTION_FLAG)),w.writeVarInt(this.ins.length),this.ins.forEach(_=>{w.writeSlice(_.hash),w.writeUInt32(_.index),w.writeVarSlice(_.script),w.writeUInt32(_.sequence)}),w.writeVarInt(this.outs.length),this.outs.forEach(_=>{y(_)?w.writeUInt64(_.value):w.writeSlice(_.valueBuffer),w.writeVarSlice(_.script)}),x&&this.ins.forEach(_=>{w.writeVector(_.witness)}),w.writeUInt32(this.locktime),I!==void 0?B.slice(I,w.offset):B}}return Ln.Transaction=g,g.DEFAULT_SEQUENCE=4294967295,g.SIGHASH_DEFAULT=0,g.SIGHASH_ALL=1,g.SIGHASH_NONE=2,g.SIGHASH_SINGLE=3,g.SIGHASH_ANYONECANPAY=128,g.SIGHASH_OUTPUT_MASK=3,g.SIGHASH_INPUT_MASK=128,g.ADVANCED_TRANSACTION_MARKER=0,g.ADVANCED_TRANSACTION_FLAG=1,Ln}var Yu;function vg(){if(Yu)return Un;Yu=1,Object.defineProperty(Un,"__esModule",{value:!0}),Un.Block=void 0;const e=Wi(),t=Wt(),n=bg(),r=zn(),a=ze(),{typeforce:o}=a,i=new TypeError("Cannot compute merkle root for zero transactions"),s=new TypeError("Cannot compute witness commit for non-segwit block");class c{constructor(){this.version=1,this.prevHash=void 0,this.merkleRoot=void 0,this.timestamp=0,this.witnessCommit=void 0,this.bits=0,this.nonce=0,this.transactions=void 0}static fromBuffer(h){if(h.length<80)throw new Error("Buffer too small (< 80 bytes)");const f=new e.BufferReader(h),y=new c;if(y.version=f.readInt32(),y.prevHash=f.readSlice(32),y.merkleRoot=f.readSlice(32),y.timestamp=f.readUInt32(),y.bits=f.readUInt32(),y.nonce=f.readUInt32(),h.length===80)return y;const g=()=>{const I=r.Transaction.fromBuffer(f.buffer.slice(f.offset),!0);return f.offset+=I.byteLength(),I},S=f.readVarInt();y.transactions=[];for(let I=0;I<S;++I){const b=g();y.transactions.push(b)}const B=y.getWitnessCommit();return B&&(y.witnessCommit=B),y}static fromHex(h){return c.fromBuffer(te.from(h,"hex"))}static calculateTarget(h){const f=((h&4278190080)>>24)-3,y=h&8388607,g=te.alloc(32,0);return g.writeUIntBE(y,29-f,3),g}static calculateMerkleRoot(h,f){if(o([{getHash:a.Function}],h),h.length===0)throw i;if(f&&!l(h))throw s;const y=h.map(S=>S.getHash(f)),g=(0,n.fastMerkleRoot)(y,t.hash256);return f?t.hash256(te.concat([g,h[0].ins[0].witness[0]])):g}getWitnessCommit(){if(!l(this.transactions))return null;const h=this.transactions[0].outs.filter(y=>y.script.slice(0,6).equals(te.from("6a24aa21a9ed","hex"))).map(y=>y.script.slice(6,38));if(h.length===0)return null;const f=h[h.length-1];return f instanceof te&&f.length===32?f:null}hasWitnessCommit(){return this.witnessCommit instanceof te&&this.witnessCommit.length===32||this.getWitnessCommit()!==null}hasWitness(){return u(this.transactions)}weight(){const h=this.byteLength(!1,!1),f=this.byteLength(!1,!0);return h*3+f}byteLength(h,f=!0){return h||!this.transactions?80:80+e.varuint.encodingLength(this.transactions.length)+this.transactions.reduce((y,g)=>y+g.byteLength(f),0)}getHash(){return t.hash256(this.toBuffer(!0))}getId(){return(0,e.reverseBuffer)(this.getHash()).toString("hex")}getUTCDate(){const h=new Date(0);return h.setUTCSeconds(this.timestamp),h}toBuffer(h){const f=te.allocUnsafe(this.byteLength(h)),y=new e.BufferWriter(f);return y.writeInt32(this.version),y.writeSlice(this.prevHash),y.writeSlice(this.merkleRoot),y.writeUInt32(this.timestamp),y.writeUInt32(this.bits),y.writeUInt32(this.nonce),h||!this.transactions||(e.varuint.encode(this.transactions.length,f,y.offset),y.offset+=e.varuint.encode.bytes,this.transactions.forEach(g=>{const S=g.byteLength();g.toBuffer(f,y.offset),y.offset+=S})),f}toHex(h){return this.toBuffer(h).toString("hex")}checkTxRoots(){const h=this.hasWitnessCommit();return!h&&this.hasWitness()?!1:this.__checkMerkleRoot()&&(h?this.__checkWitnessCommit():!0)}checkProofOfWork(){const h=(0,e.reverseBuffer)(this.getHash()),f=c.calculateTarget(this.bits);return h.compare(f)<=0}__checkMerkleRoot(){if(!this.transactions)throw i;const h=c.calculateMerkleRoot(this.transactions);return this.merkleRoot.compare(h)===0}__checkWitnessCommit(){if(!this.transactions)throw i;if(!this.hasWitnessCommit())throw s;const h=c.calculateMerkleRoot(this.transactions,!0);return this.witnessCommit.compare(h)===0}}Un.Block=c;function l(d){return d instanceof Array&&d[0]&&d[0].ins&&d[0].ins instanceof Array&&d[0].ins[0]&&d[0].ins[0].witness&&d[0].ins[0].witness instanceof Array&&d[0].ins[0].witness.length>0}function u(d){return d instanceof Array&&d.some(h=>typeof h=="object"&&h.ins instanceof Array&&h.ins.some(f=>typeof f=="object"&&f.witness instanceof Array&&f.witness.length>0))}return Un}var Dn={},ai={},ci={},vs={},cn={},un={},Es={},Zu;function qe(){return Zu||(Zu=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),(function(t){t[t.UNSIGNED_TX=0]="UNSIGNED_TX",t[t.GLOBAL_XPUB=1]="GLOBAL_XPUB"})(e.GlobalTypes||(e.GlobalTypes={})),e.GLOBAL_TYPE_NAMES=["unsignedTx","globalXpub"],(function(t){t[t.NON_WITNESS_UTXO=0]="NON_WITNESS_UTXO",t[t.WITNESS_UTXO=1]="WITNESS_UTXO",t[t.PARTIAL_SIG=2]="PARTIAL_SIG",t[t.SIGHASH_TYPE=3]="SIGHASH_TYPE",t[t.REDEEM_SCRIPT=4]="REDEEM_SCRIPT",t[t.WITNESS_SCRIPT=5]="WITNESS_SCRIPT",t[t.BIP32_DERIVATION=6]="BIP32_DERIVATION",t[t.FINAL_SCRIPTSIG=7]="FINAL_SCRIPTSIG",t[t.FINAL_SCRIPTWITNESS=8]="FINAL_SCRIPTWITNESS",t[t.POR_COMMITMENT=9]="POR_COMMITMENT",t[t.TAP_KEY_SIG=19]="TAP_KEY_SIG",t[t.TAP_SCRIPT_SIG=20]="TAP_SCRIPT_SIG",t[t.TAP_LEAF_SCRIPT=21]="TAP_LEAF_SCRIPT",t[t.TAP_BIP32_DERIVATION=22]="TAP_BIP32_DERIVATION",t[t.TAP_INTERNAL_KEY=23]="TAP_INTERNAL_KEY",t[t.TAP_MERKLE_ROOT=24]="TAP_MERKLE_ROOT"})(e.InputTypes||(e.InputTypes={})),e.INPUT_TYPE_NAMES=["nonWitnessUtxo","witnessUtxo","partialSig","sighashType","redeemScript","witnessScript","bip32Derivation","finalScriptSig","finalScriptWitness","porCommitment","tapKeySig","tapScriptSig","tapLeafScript","tapBip32Derivation","tapInternalKey","tapMerkleRoot"],(function(t){t[t.REDEEM_SCRIPT=0]="REDEEM_SCRIPT",t[t.WITNESS_SCRIPT=1]="WITNESS_SCRIPT",t[t.BIP32_DERIVATION=2]="BIP32_DERIVATION",t[t.TAP_INTERNAL_KEY=5]="TAP_INTERNAL_KEY",t[t.TAP_TREE=6]="TAP_TREE",t[t.TAP_BIP32_DERIVATION=7]="TAP_BIP32_DERIVATION"})(e.OutputTypes||(e.OutputTypes={})),e.OUTPUT_TYPE_NAMES=["redeemScript","witnessScript","bip32Derivation","tapInternalKey","tapTree","tapBip32Derivation"]})(Es)),Es}var or={},Qu;function Eg(){if(Qu)return or;Qu=1,Object.defineProperty(or,"__esModule",{value:!0});const e=qe(),t=i=>[...Array(i).keys()];function n(i){if(i.key[0]!==e.GlobalTypes.GLOBAL_XPUB)throw new Error("Decode Error: could not decode globalXpub with key 0x"+i.key.toString("hex"));if(i.key.length!==79||![2,3].includes(i.key[46]))throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x"+i.key.toString("hex"));if(i.value.length/4%1!==0)throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");const s=i.key.slice(1),c={masterFingerprint:i.value.slice(0,4),extendedPubkey:s,path:"m"};for(const l of t(i.value.length/4-1)){const u=i.value.readUInt32LE(l*4+4),d=!!(u&2147483648),h=u&2147483647;c.path+="/"+h.toString(10)+(d?"'":"")}return c}or.decode=n;function r(i){const s=te.from([e.GlobalTypes.GLOBAL_XPUB]),c=te.concat([s,i.extendedPubkey]),l=i.path.split("/"),u=te.allocUnsafe(l.length*4);i.masterFingerprint.copy(u,0);let d=4;return l.slice(1).forEach(h=>{const f=h.slice(-1)==="'";let y=2147483647&parseInt(f?h.slice(0,-1):h,10);f&&(y+=2147483648),u.writeUInt32LE(y,d),d+=4}),{key:c,value:u}}or.encode=r,or.expected="{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";function a(i){const s=i.extendedPubkey,c=i.masterFingerprint,l=i.path;return te.isBuffer(s)&&s.length===78&&[2,3].indexOf(s[45])>-1&&te.isBuffer(c)&&c.length===4&&typeof l=="string"&&!!l.match(/^m(\/\d+'?)*$/)}or.check=a;function o(i,s,c){const l=s.extendedPubkey.toString("hex");return c.has(l)?!1:(c.add(l),i.filter(u=>u.extendedPubkey.equals(s.extendedPubkey)).length===0)}return or.canAddToArray=o,or}var ui={},ef;function xg(){if(ef)return ui;ef=1,Object.defineProperty(ui,"__esModule",{value:!0});const e=qe();function t(n){return{key:te.from([e.GlobalTypes.UNSIGNED_TX]),value:n.toBuffer()}}return ui.encode=t,ui}var sr={},tf;function Sg(){if(tf)return sr;tf=1,Object.defineProperty(sr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.FINAL_SCRIPTSIG)throw new Error("Decode Error: could not decode finalScriptSig with key 0x"+o.key.toString("hex"));return o.value}sr.decode=t;function n(o){return{key:te.from([e.InputTypes.FINAL_SCRIPTSIG]),value:o}}sr.encode=n,sr.expected="Buffer";function r(o){return te.isBuffer(o)}sr.check=r;function a(o,i){return!!o&&!!i&&o.finalScriptSig===void 0}return sr.canAdd=a,sr}var ar={},rf;function Ig(){if(rf)return ar;rf=1,Object.defineProperty(ar,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.FINAL_SCRIPTWITNESS)throw new Error("Decode Error: could not decode finalScriptWitness with key 0x"+o.key.toString("hex"));return o.value}ar.decode=t;function n(o){return{key:te.from([e.InputTypes.FINAL_SCRIPTWITNESS]),value:o}}ar.encode=n,ar.expected="Buffer";function r(o){return te.isBuffer(o)}ar.check=r;function a(o,i){return!!o&&!!i&&o.finalScriptWitness===void 0}return ar.canAdd=a,ar}var cr={},nf;function _g(){if(nf)return cr;nf=1,Object.defineProperty(cr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.NON_WITNESS_UTXO)throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x"+o.key.toString("hex"));return o.value}cr.decode=t;function n(o){return{key:te.from([e.InputTypes.NON_WITNESS_UTXO]),value:o}}cr.encode=n,cr.expected="Buffer";function r(o){return te.isBuffer(o)}cr.check=r;function a(o,i){return!!o&&!!i&&o.nonWitnessUtxo===void 0}return cr.canAdd=a,cr}var ur={},of;function Ag(){if(of)return ur;of=1,Object.defineProperty(ur,"__esModule",{value:!0});const e=qe();function t(i){if(i.key[0]!==e.InputTypes.PARTIAL_SIG)throw new Error("Decode Error: could not decode partialSig with key 0x"+i.key.toString("hex"));if(!(i.key.length===34||i.key.length===66)||![2,3,4].includes(i.key[1]))throw new Error("Decode Error: partialSig has invalid pubkey in key 0x"+i.key.toString("hex"));return{pubkey:i.key.slice(1),signature:i.value}}ur.decode=t;function n(i){const s=te.from([e.InputTypes.PARTIAL_SIG]);return{key:te.concat([s,i.pubkey]),value:i.signature}}ur.encode=n,ur.expected="{ pubkey: Buffer; signature: Buffer; }";function r(i){return te.isBuffer(i.pubkey)&&te.isBuffer(i.signature)&&[33,65].includes(i.pubkey.length)&&[2,3,4].includes(i.pubkey[0])&&a(i.signature)}ur.check=r;function a(i){if(!te.isBuffer(i)||i.length<9||i[0]!==48||i.length!==i[1]+3||i[2]!==2)return!1;const s=i[3];if(s>33||s<1||i[3+s+1]!==2)return!1;const c=i[3+s+2];return!(c>33||c<1||i.length!==3+s+2+c+2)}function o(i,s,c){const l=s.pubkey.toString("hex");return c.has(l)?!1:(c.add(l),i.filter(u=>u.pubkey.equals(s.pubkey)).length===0)}return ur.canAddToArray=o,ur}var fr={},sf;function Tg(){if(sf)return fr;sf=1,Object.defineProperty(fr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.POR_COMMITMENT)throw new Error("Decode Error: could not decode porCommitment with key 0x"+o.key.toString("hex"));return o.value.toString("utf8")}fr.decode=t;function n(o){return{key:te.from([e.InputTypes.POR_COMMITMENT]),value:te.from(o,"utf8")}}fr.encode=n,fr.expected="string";function r(o){return typeof o=="string"}fr.check=r;function a(o,i){return!!o&&!!i&&o.porCommitment===void 0}return fr.canAdd=a,fr}var lr={},af;function Bg(){if(af)return lr;af=1,Object.defineProperty(lr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.SIGHASH_TYPE)throw new Error("Decode Error: could not decode sighashType with key 0x"+o.key.toString("hex"));return o.value.readUInt32LE(0)}lr.decode=t;function n(o){const i=te.from([e.InputTypes.SIGHASH_TYPE]),s=te.allocUnsafe(4);return s.writeUInt32LE(o,0),{key:i,value:s}}lr.encode=n,lr.expected="number";function r(o){return typeof o=="number"}lr.check=r;function a(o,i){return!!o&&!!i&&o.sighashType===void 0}return lr.canAdd=a,lr}var dr={},cf;function kg(){if(cf)return dr;cf=1,Object.defineProperty(dr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.TAP_KEY_SIG||o.key.length!==1)throw new Error("Decode Error: could not decode tapKeySig with key 0x"+o.key.toString("hex"));if(!r(o.value))throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");return o.value}dr.decode=t;function n(o){return{key:te.from([e.InputTypes.TAP_KEY_SIG]),value:o}}dr.encode=n,dr.expected="Buffer";function r(o){return te.isBuffer(o)&&(o.length===64||o.length===65)}dr.check=r;function a(o,i){return!!o&&!!i&&o.tapKeySig===void 0}return dr.canAdd=a,dr}var hr={},uf;function Og(){if(uf)return hr;uf=1,Object.defineProperty(hr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.TAP_LEAF_SCRIPT)throw new Error("Decode Error: could not decode tapLeafScript with key 0x"+o.key.toString("hex"));if((o.key.length-2)%32!==0)throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x"+o.key.toString("hex"));const i=o.value[o.value.length-1];if((o.key[1]&254)!==i)throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x"+o.key.toString("hex"));const s=o.value.slice(0,-1);return{controlBlock:o.key.slice(1),script:s,leafVersion:i}}hr.decode=t;function n(o){const i=te.from([e.InputTypes.TAP_LEAF_SCRIPT]),s=te.from([o.leafVersion]);return{key:te.concat([i,o.controlBlock]),value:te.concat([o.script,s])}}hr.encode=n,hr.expected="{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";function r(o){return te.isBuffer(o.controlBlock)&&(o.controlBlock.length-1)%32===0&&(o.controlBlock[0]&254)===o.leafVersion&&te.isBuffer(o.script)}hr.check=r;function a(o,i,s){const c=i.controlBlock.toString("hex");return s.has(c)?!1:(s.add(c),o.filter(l=>l.controlBlock.equals(i.controlBlock)).length===0)}return hr.canAddToArray=a,hr}var pr={},ff;function Rg(){if(ff)return pr;ff=1,Object.defineProperty(pr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.TAP_MERKLE_ROOT||o.key.length!==1)throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x"+o.key.toString("hex"));if(!r(o.value))throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");return o.value}pr.decode=t;function n(o){return{key:te.from([e.InputTypes.TAP_MERKLE_ROOT]),value:o}}pr.encode=n,pr.expected="Buffer";function r(o){return te.isBuffer(o)&&o.length===32}pr.check=r;function a(o,i){return!!o&&!!i&&o.tapMerkleRoot===void 0}return pr.canAdd=a,pr}var yr={},lf;function Pg(){if(lf)return yr;lf=1,Object.defineProperty(yr,"__esModule",{value:!0});const e=qe();function t(o){if(o.key[0]!==e.InputTypes.TAP_SCRIPT_SIG)throw new Error("Decode Error: could not decode tapScriptSig with key 0x"+o.key.toString("hex"));if(o.key.length!==65)throw new Error("Decode Error: tapScriptSig has invalid key 0x"+o.key.toString("hex"));if(o.value.length!==64&&o.value.length!==65)throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x"+o.key.toString("hex"));const i=o.key.slice(1,33),s=o.key.slice(33);return{pubkey:i,leafHash:s,signature:o.value}}yr.decode=t;function n(o){const i=te.from([e.InputTypes.TAP_SCRIPT_SIG]);return{key:te.concat([i,o.pubkey,o.leafHash]),value:o.signature}}yr.encode=n,yr.expected="{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";function r(o){return te.isBuffer(o.pubkey)&&te.isBuffer(o.leafHash)&&te.isBuffer(o.signature)&&o.pubkey.length===32&&o.leafHash.length===32&&(o.signature.length===64||o.signature.length===65)}yr.check=r;function a(o,i,s){const c=i.pubkey.toString("hex")+i.leafHash.toString("hex");return s.has(c)?!1:(s.add(c),o.filter(l=>l.pubkey.equals(i.pubkey)&&l.leafHash.equals(i.leafHash)).length===0)}return yr.canAddToArray=a,yr}var gr={},Mt={},fn={},df;function Zr(){if(df)return fn;df=1,Object.defineProperty(fn,"__esModule",{value:!0});const e=9007199254740991;function t(o){if(o<0||o>e||o%1!==0)throw new RangeError("value out of range")}function n(o,i,s){if(t(o),i||(i=te.allocUnsafe(a(o))),!te.isBuffer(i))throw new TypeError("buffer must be a Buffer instance");return s||(s=0),o<253?(i.writeUInt8(o,s),Object.assign(n,{bytes:1})):o<=65535?(i.writeUInt8(253,s),i.writeUInt16LE(o,s+1),Object.assign(n,{bytes:3})):o<=4294967295?(i.writeUInt8(254,s),i.writeUInt32LE(o,s+1),Object.assign(n,{bytes:5})):(i.writeUInt8(255,s),i.writeUInt32LE(o>>>0,s+1),i.writeUInt32LE(o/4294967296|0,s+5),Object.assign(n,{bytes:9})),i}fn.encode=n;function r(o,i){if(!te.isBuffer(o))throw new TypeError("buffer must be a Buffer instance");i||(i=0);const s=o.readUInt8(i);if(s<253)return Object.assign(r,{bytes:1}),s;if(s===253)return Object.assign(r,{bytes:3}),o.readUInt16LE(i+1);if(s===254)return Object.assign(r,{bytes:5}),o.readUInt32LE(i+1);{Object.assign(r,{bytes:9});const c=o.readUInt32LE(i+1),u=o.readUInt32LE(i+5)*4294967296+c;return t(u),u}}fn.decode=r;function a(o){return t(o),o<253?1:o<=65535?3:o<=4294967295?5:9}return fn.encodingLength=a,fn}var hf;function Ta(){if(hf)return Mt;hf=1,Object.defineProperty(Mt,"__esModule",{value:!0});const e=Zr();Mt.range=s=>[...Array(s).keys()];function t(s){if(s.length<1)return s;let c=s.length-1,l=0;for(let u=0;u<s.length/2;u++)l=s[u],s[u]=s[c],s[c]=l,c--;return s}Mt.reverseBuffer=t;function n(s){const c=s.map(r);return c.push(te.from([0])),te.concat(c)}Mt.keyValsToBuffer=n;function r(s){const c=s.key.length,l=s.value.length,u=e.encodingLength(c),d=e.encodingLength(l),h=te.allocUnsafe(u+c+d+l);return e.encode(c,h,0),s.key.copy(h,u),e.encode(l,h,u+c),s.value.copy(h,u+c+d),h}Mt.keyValToBuffer=r;function a(s,c){if(typeof s!="number")throw new Error("cannot write a non-number as a number");if(s<0)throw new Error("specified a negative value for writing an unsigned value");if(s>c)throw new Error("RangeError: value out of range");if(Math.floor(s)!==s)throw new Error("value has a fractional component")}function o(s,c){const l=s.readUInt32LE(c);let u=s.readUInt32LE(c+4);return u*=4294967296,a(u+l,9007199254740991),u+l}Mt.readUInt64LE=o;function i(s,c,l){return a(c,9007199254740991),s.writeInt32LE(c&-1,l),s.writeUInt32LE(Math.floor(c/4294967296),l+4),l+8}return Mt.writeUInt64LE=i,Mt}var pf;function Ug(){if(pf)return gr;pf=1,Object.defineProperty(gr,"__esModule",{value:!0});const e=qe(),t=Ta(),n=Zr();function r(s){if(s.key[0]!==e.InputTypes.WITNESS_UTXO)throw new Error("Decode Error: could not decode witnessUtxo with key 0x"+s.key.toString("hex"));const c=t.readUInt64LE(s.value,0);let l=8;const u=n.decode(s.value,l);l+=n.encodingLength(u);const d=s.value.slice(l);if(d.length!==u)throw new Error("Decode Error: WITNESS_UTXO script is not proper length");return{script:d,value:c}}gr.decode=r;function a(s){const{script:c,value:l}=s,u=n.encodingLength(c.length),d=te.allocUnsafe(8+u+c.length);return t.writeUInt64LE(d,l,0),n.encode(c.length,d,8),c.copy(d,8+u),{key:te.from([e.InputTypes.WITNESS_UTXO]),value:d}}gr.encode=a,gr.expected="{ script: Buffer; value: number; }";function o(s){return te.isBuffer(s.script)&&typeof s.value=="number"}gr.check=o;function i(s,c){return!!s&&!!c&&s.witnessUtxo===void 0}return gr.canAdd=i,gr}var wr={},yf;function Hg(){if(yf)return wr;yf=1,Object.defineProperty(wr,"__esModule",{value:!0});const e=qe(),t=Zr();function n(i){if(i.key[0]!==e.OutputTypes.TAP_TREE||i.key.length!==1)throw new Error("Decode Error: could not decode tapTree with key 0x"+i.key.toString("hex"));let s=0;const c=[];for(;s<i.value.length;){const l=i.value[s++],u=i.value[s++],d=t.decode(i.value,s);s+=t.encodingLength(d),c.push({depth:l,leafVersion:u,script:i.value.slice(s,s+d)}),s+=d}return{leaves:c}}wr.decode=n;function r(i){const s=te.from([e.OutputTypes.TAP_TREE]),c=[].concat(...i.leaves.map(l=>[te.of(l.depth,l.leafVersion),t.encode(l.script.length),l.script]));return{key:s,value:te.concat(c)}}wr.encode=r,wr.expected="{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";function a(i){return Array.isArray(i.leaves)&&i.leaves.every(s=>s.depth>=0&&s.depth<=128&&(s.leafVersion&254)===s.leafVersion&&te.isBuffer(s.script))}wr.check=a;function o(i,s){return!!i&&!!s&&i.tapTree===void 0}return wr.canAdd=o,wr}var fi={},gf;function Fd(){if(gf)return fi;gf=1,Object.defineProperty(fi,"__esModule",{value:!0});const e=r=>[...Array(r).keys()],t=r=>r.length===33&&[2,3].includes(r[0])||r.length===65&&r[0]===4;function n(r,a=t){function o(u){if(u.key[0]!==r)throw new Error("Decode Error: could not decode bip32Derivation with key 0x"+u.key.toString("hex"));const d=u.key.slice(1);if(!a(d))throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x"+u.key.toString("hex"));if(u.value.length/4%1!==0)throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");const h={masterFingerprint:u.value.slice(0,4),pubkey:d,path:"m"};for(const f of e(u.value.length/4-1)){const y=u.value.readUInt32LE(f*4+4),g=!!(y&2147483648),S=y&2147483647;h.path+="/"+S.toString(10)+(g?"'":"")}return h}function i(u){const d=te.from([r]),h=te.concat([d,u.pubkey]),f=u.path.split("/"),y=te.allocUnsafe(f.length*4);u.masterFingerprint.copy(y,0);let g=4;return f.slice(1).forEach(S=>{const B=S.slice(-1)==="'";let I=2147483647&parseInt(B?S.slice(0,-1):S,10);B&&(I+=2147483648),y.writeUInt32LE(I,g),g+=4}),{key:h,value:y}}const s="{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";function c(u){return te.isBuffer(u.pubkey)&&te.isBuffer(u.masterFingerprint)&&typeof u.path=="string"&&a(u.pubkey)&&u.masterFingerprint.length===4}function l(u,d,h){const f=d.pubkey.toString("hex");return h.has(f)?!1:(h.add(f),u.filter(y=>y.pubkey.equals(d.pubkey)).length===0)}return{decode:o,encode:i,check:c,expected:s,canAddToArray:l}}return fi.makeConverter=n,fi}var li={},wf;function Lg(){if(wf)return li;wf=1,Object.defineProperty(li,"__esModule",{value:!0});function e(t){return n;function n(r){let a;if(t.includes(r.key[0])&&(a=r.key.slice(1),!(a.length===33||a.length===65)||![2,3,4].includes(a[0])))throw new Error("Format Error: invalid pubkey in key 0x"+r.key.toString("hex"));return a}}return li.makeChecker=e,li}var di={},mf;function Dg(){if(mf)return di;mf=1,Object.defineProperty(di,"__esModule",{value:!0});function e(t){function n(s){if(s.key[0]!==t)throw new Error("Decode Error: could not decode redeemScript with key 0x"+s.key.toString("hex"));return s.value}function r(s){return{key:te.from([t]),value:s}}const a="Buffer";function o(s){return te.isBuffer(s)}function i(s,c){return!!s&&!!c&&s.redeemScript===void 0}return{decode:n,encode:r,check:o,expected:a,canAdd:i}}return di.makeConverter=e,di}var hi={},bf;function Ng(){if(bf)return hi;bf=1,Object.defineProperty(hi,"__esModule",{value:!0});const e=Zr(),t=Fd(),n=a=>a.length===32;function r(a){const o=t.makeConverter(a,n);function i(u){const d=e.decode(u.value),h=e.encodingLength(d),f=o.decode({key:u.key,value:u.value.slice(h+d*32)}),y=new Array(d);for(let g=0,S=h;g<d;g++,S+=32)y[g]=u.value.slice(S,S+32);return Object.assign({},f,{leafHashes:y})}function s(u){const d=o.encode(u),h=e.encodingLength(u.leafHashes.length),f=te.allocUnsafe(h);e.encode(u.leafHashes.length,f);const y=te.concat([f,...u.leafHashes,d.value]);return Object.assign({},d,{value:y})}const c="{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";function l(u){return Array.isArray(u.leafHashes)&&u.leafHashes.every(d=>te.isBuffer(d)&&d.length===32)&&o.check(u)}return{decode:i,encode:s,check:l,expected:c,canAddToArray:o.canAddToArray}}return hi.makeConverter=r,hi}var pi={},vf;function Fg(){if(vf)return pi;vf=1,Object.defineProperty(pi,"__esModule",{value:!0});function e(t){function n(s){if(s.key[0]!==t||s.key.length!==1)throw new Error("Decode Error: could not decode tapInternalKey with key 0x"+s.key.toString("hex"));if(s.value.length!==32)throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");return s.value}function r(s){return{key:te.from([t]),value:s}}const a="Buffer";function o(s){return te.isBuffer(s)&&s.length===32}function i(s,c){return!!s&&!!c&&s.tapInternalKey===void 0}return{decode:n,encode:r,check:o,expected:a,canAdd:i}}return pi.makeConverter=e,pi}var yi={},Ef;function Mg(){if(Ef)return yi;Ef=1,Object.defineProperty(yi,"__esModule",{value:!0});function e(t){function n(s){if(s.key[0]!==t)throw new Error("Decode Error: could not decode witnessScript with key 0x"+s.key.toString("hex"));return s.value}function r(s){return{key:te.from([t]),value:s}}const a="Buffer";function o(s){return te.isBuffer(s)}function i(s,c){return!!s&&!!c&&s.witnessScript===void 0}return{decode:n,encode:r,check:o,expected:a,canAdd:i}}return yi.makeConverter=e,yi}var xf;function Ba(){if(xf)return un;xf=1,Object.defineProperty(un,"__esModule",{value:!0});const e=qe(),t=Eg(),n=xg(),r=Sg(),a=Ig(),o=_g(),i=Ag(),s=Tg(),c=Bg(),l=kg(),u=Og(),d=Rg(),h=Pg(),f=Ug(),y=Hg(),g=Fd(),S=Lg(),B=Dg(),I=Ng(),b=Fg(),w=Mg(),x={unsignedTx:n,globalXpub:t,checkPubkey:S.makeChecker([])};un.globals=x;const _={nonWitnessUtxo:o,partialSig:i,sighashType:c,finalScriptSig:r,finalScriptWitness:a,porCommitment:s,witnessUtxo:f,bip32Derivation:g.makeConverter(e.InputTypes.BIP32_DERIVATION),redeemScript:B.makeConverter(e.InputTypes.REDEEM_SCRIPT),witnessScript:w.makeConverter(e.InputTypes.WITNESS_SCRIPT),checkPubkey:S.makeChecker([e.InputTypes.PARTIAL_SIG,e.InputTypes.BIP32_DERIVATION]),tapKeySig:l,tapScriptSig:h,tapLeafScript:u,tapBip32Derivation:I.makeConverter(e.InputTypes.TAP_BIP32_DERIVATION),tapInternalKey:b.makeConverter(e.InputTypes.TAP_INTERNAL_KEY),tapMerkleRoot:d};un.inputs=_;const N={bip32Derivation:g.makeConverter(e.OutputTypes.BIP32_DERIVATION),redeemScript:B.makeConverter(e.OutputTypes.REDEEM_SCRIPT),witnessScript:w.makeConverter(e.OutputTypes.WITNESS_SCRIPT),checkPubkey:S.makeChecker([e.OutputTypes.BIP32_DERIVATION]),tapBip32Derivation:I.makeConverter(e.OutputTypes.TAP_BIP32_DERIVATION),tapTree:y,tapInternalKey:b.makeConverter(e.OutputTypes.TAP_INTERNAL_KEY)};return un.outputs=N,un}var Sf;function Cg(){if(Sf)return cn;Sf=1,Object.defineProperty(cn,"__esModule",{value:!0});const e=Ba(),t=Ta(),n=Zr(),r=qe();function a(s,c){let l=0;function u(){const N=n.decode(s,l);l+=n.encodingLength(N);const k=s.slice(l,l+N);return l+=N,k}function d(){const N=s.readUInt32BE(l);return l+=4,N}function h(){const N=s.readUInt8(l);return l+=1,N}function f(){const N=u(),k=u();return{key:N,value:k}}function y(){if(l>=s.length)throw new Error("Format Error: Unexpected End of PSBT");const N=s.readUInt8(l)===0;return N&&l++,N}if(d()!==1886610036)throw new Error("Format Error: Invalid Magic Number");if(h()!==255)throw new Error("Format Error: Magic Number must be followed by 0xff separator");const g=[],S={};for(;!y();){const N=f(),k=N.key.toString("hex");if(S[k])throw new Error("Format Error: Keys must be unique for global keymap: key "+k);S[k]=1,g.push(N)}const B=g.filter(N=>N.key[0]===r.GlobalTypes.UNSIGNED_TX);if(B.length!==1)throw new Error("Format Error: Only one UNSIGNED_TX allowed");const I=c(B[0].value),{inputCount:b,outputCount:w}=I.getInputOutputCounts(),x=[],_=[];for(const N of t.range(b)){const k={},T=[];for(;!y();){const L=f(),F=L.key.toString("hex");if(k[F])throw new Error("Format Error: Keys must be unique for each input: input index "+N+" key "+F);k[F]=1,T.push(L)}x.push(T)}for(const N of t.range(w)){const k={},T=[];for(;!y();){const L=f(),F=L.key.toString("hex");if(k[F])throw new Error("Format Error: Keys must be unique for each output: output index "+N+" key "+F);k[F]=1,T.push(L)}_.push(T)}return i(I,{globalMapKeyVals:g,inputKeyVals:x,outputKeyVals:_})}cn.psbtFromBuffer=a;function o(s,c,l){if(!c.equals(te.from([l])))throw new Error(`Format Error: Invalid ${s} key: ${c.toString("hex")}`)}cn.checkKeyBuffer=o;function i(s,{globalMapKeyVals:c,inputKeyVals:l,outputKeyVals:u}){const d={unsignedTx:s};let h=0;for(const B of c)switch(B.key[0]){case r.GlobalTypes.UNSIGNED_TX:if(o("global",B.key,r.GlobalTypes.UNSIGNED_TX),h>0)throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");h++;break;case r.GlobalTypes.GLOBAL_XPUB:d.globalXpub===void 0&&(d.globalXpub=[]),d.globalXpub.push(e.globals.globalXpub.decode(B));break;default:d.unknownKeyVals||(d.unknownKeyVals=[]),d.unknownKeyVals.push(B)}const f=l.length,y=u.length,g=[],S=[];for(const B of t.range(f)){const I={};for(const b of l[B])switch(e.inputs.checkPubkey(b),b.key[0]){case r.InputTypes.NON_WITNESS_UTXO:if(o("input",b.key,r.InputTypes.NON_WITNESS_UTXO),I.nonWitnessUtxo!==void 0)throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");I.nonWitnessUtxo=e.inputs.nonWitnessUtxo.decode(b);break;case r.InputTypes.WITNESS_UTXO:if(o("input",b.key,r.InputTypes.WITNESS_UTXO),I.witnessUtxo!==void 0)throw new Error("Format Error: Input has multiple WITNESS_UTXO");I.witnessUtxo=e.inputs.witnessUtxo.decode(b);break;case r.InputTypes.PARTIAL_SIG:I.partialSig===void 0&&(I.partialSig=[]),I.partialSig.push(e.inputs.partialSig.decode(b));break;case r.InputTypes.SIGHASH_TYPE:if(o("input",b.key,r.InputTypes.SIGHASH_TYPE),I.sighashType!==void 0)throw new Error("Format Error: Input has multiple SIGHASH_TYPE");I.sighashType=e.inputs.sighashType.decode(b);break;case r.InputTypes.REDEEM_SCRIPT:if(o("input",b.key,r.InputTypes.REDEEM_SCRIPT),I.redeemScript!==void 0)throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");I.redeemScript=e.inputs.redeemScript.decode(b);break;case r.InputTypes.WITNESS_SCRIPT:if(o("input",b.key,r.InputTypes.WITNESS_SCRIPT),I.witnessScript!==void 0)throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");I.witnessScript=e.inputs.witnessScript.decode(b);break;case r.InputTypes.BIP32_DERIVATION:I.bip32Derivation===void 0&&(I.bip32Derivation=[]),I.bip32Derivation.push(e.inputs.bip32Derivation.decode(b));break;case r.InputTypes.FINAL_SCRIPTSIG:o("input",b.key,r.InputTypes.FINAL_SCRIPTSIG),I.finalScriptSig=e.inputs.finalScriptSig.decode(b);break;case r.InputTypes.FINAL_SCRIPTWITNESS:o("input",b.key,r.InputTypes.FINAL_SCRIPTWITNESS),I.finalScriptWitness=e.inputs.finalScriptWitness.decode(b);break;case r.InputTypes.POR_COMMITMENT:o("input",b.key,r.InputTypes.POR_COMMITMENT),I.porCommitment=e.inputs.porCommitment.decode(b);break;case r.InputTypes.TAP_KEY_SIG:o("input",b.key,r.InputTypes.TAP_KEY_SIG),I.tapKeySig=e.inputs.tapKeySig.decode(b);break;case r.InputTypes.TAP_SCRIPT_SIG:I.tapScriptSig===void 0&&(I.tapScriptSig=[]),I.tapScriptSig.push(e.inputs.tapScriptSig.decode(b));break;case r.InputTypes.TAP_LEAF_SCRIPT:I.tapLeafScript===void 0&&(I.tapLeafScript=[]),I.tapLeafScript.push(e.inputs.tapLeafScript.decode(b));break;case r.InputTypes.TAP_BIP32_DERIVATION:I.tapBip32Derivation===void 0&&(I.tapBip32Derivation=[]),I.tapBip32Derivation.push(e.inputs.tapBip32Derivation.decode(b));break;case r.InputTypes.TAP_INTERNAL_KEY:o("input",b.key,r.InputTypes.TAP_INTERNAL_KEY),I.tapInternalKey=e.inputs.tapInternalKey.decode(b);break;case r.InputTypes.TAP_MERKLE_ROOT:o("input",b.key,r.InputTypes.TAP_MERKLE_ROOT),I.tapMerkleRoot=e.inputs.tapMerkleRoot.decode(b);break;default:I.unknownKeyVals||(I.unknownKeyVals=[]),I.unknownKeyVals.push(b)}g.push(I)}for(const B of t.range(y)){const I={};for(const b of u[B])switch(e.outputs.checkPubkey(b),b.key[0]){case r.OutputTypes.REDEEM_SCRIPT:if(o("output",b.key,r.OutputTypes.REDEEM_SCRIPT),I.redeemScript!==void 0)throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");I.redeemScript=e.outputs.redeemScript.decode(b);break;case r.OutputTypes.WITNESS_SCRIPT:if(o("output",b.key,r.OutputTypes.WITNESS_SCRIPT),I.witnessScript!==void 0)throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");I.witnessScript=e.outputs.witnessScript.decode(b);break;case r.OutputTypes.BIP32_DERIVATION:I.bip32Derivation===void 0&&(I.bip32Derivation=[]),I.bip32Derivation.push(e.outputs.bip32Derivation.decode(b));break;case r.OutputTypes.TAP_INTERNAL_KEY:o("output",b.key,r.OutputTypes.TAP_INTERNAL_KEY),I.tapInternalKey=e.outputs.tapInternalKey.decode(b);break;case r.OutputTypes.TAP_TREE:o("output",b.key,r.OutputTypes.TAP_TREE),I.tapTree=e.outputs.tapTree.decode(b);break;case r.OutputTypes.TAP_BIP32_DERIVATION:I.tapBip32Derivation===void 0&&(I.tapBip32Derivation=[]),I.tapBip32Derivation.push(e.outputs.tapBip32Derivation.decode(b));break;default:I.unknownKeyVals||(I.unknownKeyVals=[]),I.unknownKeyVals.push(b)}S.push(I)}return{globalMap:d,inputs:g,outputs:S}}return cn.psbtFromKeyVals=i,cn}var Nn={},If;function jg(){if(If)return Nn;If=1,Object.defineProperty(Nn,"__esModule",{value:!0});const e=Ba(),t=Ta();function n({globalMap:i,inputs:s,outputs:c}){const{globalKeyVals:l,inputKeyVals:u,outputKeyVals:d}=o({globalMap:i,inputs:s,outputs:c}),h=t.keyValsToBuffer(l),f=B=>B.length===0?[te.from([0])]:B.map(t.keyValsToBuffer),y=f(u),g=f(d),S=te.allocUnsafe(5);return S.writeUIntBE(482972169471,0,5),te.concat([S,h].concat(y,g))}Nn.psbtToBuffer=n;const r=(i,s)=>i.key.compare(s.key);function a(i,s){const c=new Set,l=Object.entries(i).reduce((d,[h,f])=>{if(h==="unknownKeyVals")return d;const y=s[h];if(y===void 0)return d;const g=(Array.isArray(f)?f:[f]).map(y.encode);return g.map(B=>B.key.toString("hex")).forEach(B=>{if(c.has(B))throw new Error("Serialize Error: Duplicate key: "+B);c.add(B)}),d.concat(g)},[]),u=i.unknownKeyVals?i.unknownKeyVals.filter(d=>!c.has(d.key.toString("hex"))):[];return l.concat(u).sort(r)}function o({globalMap:i,inputs:s,outputs:c}){return{globalKeyVals:a(i,e.globals),inputKeyVals:s.map(l=>a(l,e.inputs)),outputKeyVals:c.map(l=>a(l,e.outputs))}}return Nn.psbtToKeyVals=o,Nn}var _f;function Md(){return _f||(_f=1,(function(e){function t(n){for(var r in n)e.hasOwnProperty(r)||(e[r]=n[r])}Object.defineProperty(e,"__esModule",{value:!0}),t(Cg()),t(jg())})(vs)),vs}var Af;function qg(){if(Af)return ci;Af=1,Object.defineProperty(ci,"__esModule",{value:!0});const e=Md();function t(o){const i=o[0],s=e.psbtToKeyVals(i),c=o.slice(1);if(c.length===0)throw new Error("Combine: Nothing to combine");const l=r(i);if(l===void 0)throw new Error("Combine: Self missing transaction");const u=a(s.globalKeyVals),d=s.inputKeyVals.map(a),h=s.outputKeyVals.map(a);for(const f of c){const y=r(f);if(y===void 0||!y.toBuffer().equals(l.toBuffer()))throw new Error("Combine: One of the Psbts does not have the same transaction.");const g=e.psbtToKeyVals(f);a(g.globalKeyVals).forEach(n(u,s.globalKeyVals,g.globalKeyVals)),g.inputKeyVals.map(a).forEach((b,w)=>b.forEach(n(d[w],s.inputKeyVals[w],g.inputKeyVals[w]))),g.outputKeyVals.map(a).forEach((b,w)=>b.forEach(n(h[w],s.outputKeyVals[w],g.outputKeyVals[w])))}return e.psbtFromKeyVals(l,{globalMapKeyVals:s.globalKeyVals,inputKeyVals:s.inputKeyVals,outputKeyVals:s.outputKeyVals})}ci.combine=t;function n(o,i,s){return c=>{if(o.has(c))return;const l=s.filter(u=>u.key.toString("hex")===c)[0];i.push(l),o.add(c)}}function r(o){return o.globalMap.unsignedTx}function a(o){const i=new Set;return o.forEach(s=>{const c=s.key.toString("hex");if(i.has(c))throw new Error("Combine: KeyValue Map keys should be unique");i.add(c)}),i}return ci}var xs={},Tf;function Cd(){return Tf||(Tf=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0});const t=Ba();function n(f,y){const g=f[y];if(g===void 0)throw new Error(`No input #${y}`);return g}e.checkForInput=n;function r(f,y){const g=f[y];if(g===void 0)throw new Error(`No output #${y}`);return g}e.checkForOutput=r;function a(f,y,g){if(f.key[0]<g)throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");if(y&&y.filter(S=>S.key.equals(f.key)).length!==0)throw new Error(`Duplicate Key: ${f.key.toString("hex")}`)}e.checkHasKey=a;function o(f){let y=0;return Object.keys(f).forEach(g=>{Number(isNaN(Number(g)))&&y++}),y}e.getEnumLength=o;function i(f,y){let g=!1;if(y.nonWitnessUtxo||y.witnessUtxo){const S=!!y.redeemScript,B=!!y.witnessScript,I=!S||!!y.finalScriptSig,b=!B||!!y.finalScriptWitness,w=!!y.finalScriptSig||!!y.finalScriptWitness;g=I&&b&&w}if(g===!1)throw new Error(`Input #${f} has too much or too little data to clean`)}e.inputCheckUncleanFinalized=i;function s(f,y,g,S){throw new Error(`Data for ${f} key ${y} is incorrect: Expected ${g} and got ${JSON.stringify(S)}`)}function c(f){return(y,g)=>{for(const S of Object.keys(y)){const B=y[S],{canAdd:I,canAddToArray:b,check:w,expected:x}=t[f+"s"][S]||{},_=!!b;if(w)if(_){if(!Array.isArray(B)||g[S]&&!Array.isArray(g[S]))throw new Error(`Key type ${S} must be an array`);B.every(w)||s(f,S,x,B);const N=g[S]||[],k=new Set;if(!B.every(T=>b(N,T,k)))throw new Error("Can not add duplicate data to array");g[S]=N.concat(B)}else{if(w(B)||s(f,S,x,B),!I(g,B))throw new Error(`Can not add duplicate data to ${f}`);g[S]=B}}}}e.updateGlobal=c("global"),e.updateInput=c("input"),e.updateOutput=c("output");function l(f,y){const g=f.length-1,S=n(f,g);e.updateInput(y,S)}e.addInputAttributes=l;function u(f,y){const g=f.length-1,S=r(f,g);e.updateOutput(y,S)}e.addOutputAttributes=u;function d(f,y){if(!te.isBuffer(y)||y.length<4)throw new Error("Set Version: Invalid Transaction");return y.writeUInt32LE(f,0),y}e.defaultVersionSetter=d;function h(f,y){if(!te.isBuffer(y)||y.length<4)throw new Error("Set Locktime: Invalid Transaction");return y.writeUInt32LE(f,y.length-4),y}e.defaultLocktimeSetter=h})(xs)),xs}var Bf;function Kg(){if(Bf)return ai;Bf=1,Object.defineProperty(ai,"__esModule",{value:!0});const e=qg(),t=Md(),n=qe(),r=Cd();class a{constructor(i){this.inputs=[],this.outputs=[],this.globalMap={unsignedTx:i}}static fromBase64(i,s){const c=te.from(i,"base64");return this.fromBuffer(c,s)}static fromHex(i,s){const c=te.from(i,"hex");return this.fromBuffer(c,s)}static fromBuffer(i,s){const c=t.psbtFromBuffer(i,s),l=new this(c.globalMap.unsignedTx);return Object.assign(l,c),l}toBase64(){return this.toBuffer().toString("base64")}toHex(){return this.toBuffer().toString("hex")}toBuffer(){return t.psbtToBuffer(this)}updateGlobal(i){return r.updateGlobal(i,this.globalMap),this}updateInput(i,s){const c=r.checkForInput(this.inputs,i);return r.updateInput(s,c),this}updateOutput(i,s){const c=r.checkForOutput(this.outputs,i);return r.updateOutput(s,c),this}addUnknownKeyValToGlobal(i){return r.checkHasKey(i,this.globalMap.unknownKeyVals,r.getEnumLength(n.GlobalTypes)),this.globalMap.unknownKeyVals||(this.globalMap.unknownKeyVals=[]),this.globalMap.unknownKeyVals.push(i),this}addUnknownKeyValToInput(i,s){const c=r.checkForInput(this.inputs,i);return r.checkHasKey(s,c.unknownKeyVals,r.getEnumLength(n.InputTypes)),c.unknownKeyVals||(c.unknownKeyVals=[]),c.unknownKeyVals.push(s),this}addUnknownKeyValToOutput(i,s){const c=r.checkForOutput(this.outputs,i);return r.checkHasKey(s,c.unknownKeyVals,r.getEnumLength(n.OutputTypes)),c.unknownKeyVals||(c.unknownKeyVals=[]),c.unknownKeyVals.push(s),this}addInput(i){this.globalMap.unsignedTx.addInput(i),this.inputs.push({unknownKeyVals:[]});const s=i.unknownKeyVals||[],c=this.inputs.length-1;if(!Array.isArray(s))throw new Error("unknownKeyVals must be an Array");return s.forEach(l=>this.addUnknownKeyValToInput(c,l)),r.addInputAttributes(this.inputs,i),this}addOutput(i){this.globalMap.unsignedTx.addOutput(i),this.outputs.push({unknownKeyVals:[]});const s=i.unknownKeyVals||[],c=this.outputs.length-1;if(!Array.isArray(s))throw new Error("unknownKeyVals must be an Array");return s.forEach(l=>this.addUnknownKeyValToOutput(c,l)),r.addOutputAttributes(this.outputs,i),this}clearFinalizedInput(i){const s=r.checkForInput(this.inputs,i);r.inputCheckUncleanFinalized(i,s);for(const c of Object.keys(s))["witnessUtxo","nonWitnessUtxo","finalScriptSig","finalScriptWitness","unknownKeyVals"].includes(c)||delete s[c];return this}combine(...i){const s=e.combine([this].concat(i));return Object.assign(this,s),this}getTransaction(){return this.globalMap.unsignedTx.toBuffer()}}return ai.Psbt=a,ai}var Re={},Oe={},kf;function Ls(){if(kf)return Oe;kf=1,Object.defineProperty(Oe,"__esModule",{value:!0}),Oe.signatureBlocksAction=Oe.checkInputForSig=Oe.pubkeyInScript=Oe.pubkeyPositionInScript=Oe.witnessStackToScriptWitness=Oe.isP2TR=Oe.isP2SHScript=Oe.isP2WSHScript=Oe.isP2WPKH=Oe.isP2PKH=Oe.isP2PK=Oe.isP2MS=void 0;const e=Zr(),t=et(),n=zn(),r=Wt(),a=Xn();function o(f){return y=>{try{return f({output:y}),!0}catch{return!1}}}Oe.isP2MS=o(a.p2ms),Oe.isP2PK=o(a.p2pk),Oe.isP2PKH=o(a.p2pkh),Oe.isP2WPKH=o(a.p2wpkh),Oe.isP2WSHScript=o(a.p2wsh),Oe.isP2SHScript=o(a.p2sh),Oe.isP2TR=o(a.p2tr);function i(f){let y=te.allocUnsafe(0);function g(b){y=te.concat([y,te.from(b)])}function S(b){const w=y.length,x=e.encodingLength(b);y=te.concat([y,te.allocUnsafe(x)]),e.encode(b,y,w)}function B(b){S(b.length),g(b)}function I(b){S(b.length),b.forEach(B)}return I(f),y}Oe.witnessStackToScriptWitness=i;function s(f,y){const g=(0,r.hash160)(f),S=f.slice(1,33),B=t.decompile(y);if(B===null)throw new Error("Unknown script error");return B.findIndex(I=>typeof I=="number"?!1:I.equals(f)||I.equals(g)||I.equals(S))}Oe.pubkeyPositionInScript=s;function c(f,y){return s(f,y)!==-1}Oe.pubkeyInScript=c;function l(f,y){return d(f).some(S=>u(S,t.signature.decode,y))}Oe.checkInputForSig=l;function u(f,y,g){const{hashType:S}=y(f),B=[];switch(S&n.Transaction.SIGHASH_ANYONECANPAY&&B.push("addInput"),S&31){case n.Transaction.SIGHASH_ALL:break;case n.Transaction.SIGHASH_SINGLE:case n.Transaction.SIGHASH_NONE:B.push("addOutput"),B.push("setInputSequence");break}return B.indexOf(g)===-1}Oe.signatureBlocksAction=u;function d(f){let y=[];if((f.partialSig||[]).length===0){if(!f.finalScriptSig&&!f.finalScriptWitness)return[];y=h(f)}else y=f.partialSig;return y.map(g=>g.signature)}function h(f){const y=f.finalScriptSig?t.decompile(f.finalScriptSig)||[]:[],g=f.finalScriptWitness?t.decompile(f.finalScriptWitness)||[]:[];return y.concat(g).filter(S=>te.isBuffer(S)&&t.isCanonicalScriptSignature(S)).map(S=>({signature:S}))}return Oe}var Of;function Vg(){if(Of)return Re;Of=1,Object.defineProperty(Re,"__esModule",{value:!0}),Re.checkTaprootInputForSigs=Re.tapTreeFromList=Re.tapTreeToList=Re.tweakInternalPubKey=Re.checkTaprootOutputFields=Re.checkTaprootInputFields=Re.isTaprootOutput=Re.isTaprootInput=Re.serializeTaprootSignature=Re.tapScriptFinalizer=Re.toXOnly=void 0;const e=ze(),t=zn(),n=Ls(),r=_a(),a=Xn(),o=Ls(),i=C=>C.length===32?C:C.slice(1,33);Re.toXOnly=i;function s(C,H,D){const W=K(H,C,D);try{const re=R(H,W).concat(W.script).concat(W.controlBlock);return{finalScriptWitness:(0,n.witnessStackToScriptWitness)(re)}}catch(J){throw new Error(`Can not finalize taproot input #${C}: ${J}`)}}Re.tapScriptFinalizer=s;function c(C,H){const D=H?te.from([H]):te.from([]);return te.concat([C,D])}Re.serializeTaprootSignature=c;function l(C){return C&&!!(C.tapInternalKey||C.tapMerkleRoot||C.tapLeafScript&&C.tapLeafScript.length||C.tapBip32Derivation&&C.tapBip32Derivation.length||C.witnessUtxo&&(0,n.isP2TR)(C.witnessUtxo.script))}Re.isTaprootInput=l;function u(C,H){return C&&!!(C.tapInternalKey||C.tapTree||C.tapBip32Derivation&&C.tapBip32Derivation.length||H&&(0,n.isP2TR)(H))}Re.isTaprootOutput=u;function d(C,H,D){T(C,H,D),F(C,H,D)}Re.checkTaprootInputFields=d;function h(C,H,D){L(C,H,D),f(C,H)}Re.checkTaprootOutputFields=h;function f(C,H){if(!H.tapTree&&!H.tapInternalKey)return;const D=H.tapInternalKey||C.tapInternalKey,W=H.tapTree||C.tapTree;if(D){const{script:J}=C,re=y(D,W);if(J&&!J.equals(re))throw new Error("Error adding output. Script or address missmatch.")}}function y(C,H){const D=H&&B(H.leaves),{output:W}=(0,a.p2tr)({internalPubkey:C,scriptTree:D});return W}function g(C,H){const D=H.tapInternalKey,W=D&&(0,r.tweakKey)(D,H.tapMerkleRoot);if(!W)throw new Error(`Cannot tweak tap internal key for input #${C}. Public key: ${D&&D.toString("hex")}`);return W.x}Re.tweakInternalPubKey=g;function S(C){if(!(0,e.isTaptree)(C))throw new Error("Cannot convert taptree to tapleaf list. Expecting a tapree structure.");return _(C)}Re.tapTreeToList=S;function B(C=[]){return C.length===1&&C[0].depth===0?{output:C[0].script,version:C[0].leafVersion}:N(C)}Re.tapTreeFromList=B;function I(C,H){return w(C).some(W=>(0,o.signatureBlocksAction)(W,b,H))}Re.checkTaprootInputForSigs=I;function b(C){return{signature:C.slice(0,64),hashType:C.slice(64)[0]||t.Transaction.SIGHASH_DEFAULT}}function w(C){const H=[];if(C.tapKeySig&&H.push(C.tapKeySig),C.tapScriptSig&&H.push(...C.tapScriptSig.map(D=>D.signature)),!H.length){const D=x(C.finalScriptWitness);D&&H.push(D)}return H}function x(C){if(!C)return;const H=C.slice(2);if(H.length===64||H.length===65)return H}function _(C,H=[],D=0){if(D>r.MAX_TAPTREE_DEPTH)throw new Error("Max taptree depth exceeded.");return C?(0,e.isTapleaf)(C)?(H.push({depth:D,leafVersion:C.version||r.LEAF_VERSION_TAPSCRIPT,script:C.output}),H):(C[0]&&_(C[0],H,D+1),C[1]&&_(C[1],H,D+1),H):[]}function N(C){let H;for(const D of C)if(H=k(D,H),!H)throw new Error("No room left to insert tapleaf in tree");return H}function k(C,H,D=0){if(D>r.MAX_TAPTREE_DEPTH)throw new Error("Max taptree depth exceeded.");if(C.depth===D)return H?void 0:{output:C.script,version:C.leafVersion};if((0,e.isTapleaf)(H))return;const W=k(C,H&&H[0],D+1);if(W)return[W,H&&H[1]];const J=k(C,H&&H[1],D+1);if(J)return[H&&H[0],J]}function T(C,H,D){const W=l(C)&&V(H),J=V(C)&&l(H),re=C===H&&l(H)&&V(H);if(W||J||re)throw new Error(`Invalid arguments for Psbt.${D}. Cannot use both taproot and non-taproot fields.`)}function L(C,H,D){const W=u(C)&&V(H),J=V(C)&&u(H),re=C===H&&u(H)&&V(H);if(W||J||re)throw new Error(`Invalid arguments for Psbt.${D}. Cannot use both taproot and non-taproot fields.`)}function F(C,H,D){if(H.tapMerkleRoot){const W=(H.tapLeafScript||[]).every(re=>O(re,H.tapMerkleRoot)),J=(C.tapLeafScript||[]).every(re=>O(re,H.tapMerkleRoot));if(!W||!J)throw new Error(`Invalid arguments for Psbt.${D}. Tapleaf not part of taptree.`)}else if(C.tapMerkleRoot&&!(H.tapLeafScript||[]).every(J=>O(J,C.tapMerkleRoot)))throw new Error(`Invalid arguments for Psbt.${D}. Tapleaf not part of taptree.`)}function O(C,H){if(!H)return!0;const D=(0,r.tapleafHash)({output:C.script,version:C.leafVersion});return(0,r.rootHashFromPath)(C.controlBlock,D).equals(H)}function R(C,H){const D=(0,r.tapleafHash)({output:H.script,version:H.leafVersion});return(C.tapScriptSig||[]).filter(W=>W.leafHash.equals(D)).map(W=>P(H.script,W)).sort((W,J)=>J.positionInScript-W.positionInScript).map(W=>W.signature)}function P(C,H){return Object.assign({positionInScript:(0,n.pubkeyPositionInScript)(H.pubkey,C)},H)}function K(C,H,D){if(!C.tapScriptSig||!C.tapScriptSig.length)throw new Error(`Can not finalize taproot input #${H}. No tapleaf script signature provided.`);const W=(C.tapLeafScript||[]).sort((J,re)=>J.controlBlock.length-re.controlBlock.length).find(J=>U(J,C.tapScriptSig,D));if(!W)throw new Error(`Can not finalize taproot input #${H}. Signature for tapleaf script not found.`);return W}function U(C,H,D){const W=(0,r.tapleafHash)({output:C.script,version:C.leafVersion});return(!D||D.equals(W))&&H.find(re=>re.leafHash.equals(W))!==void 0}function V(C){return C&&!!(C.redeemScript||C.witnessScript||C.bip32Derivation&&C.bip32Derivation.length)}return Re}var Rf;function Gg(){if(Rf)return Dn;Rf=1,Object.defineProperty(Dn,"__esModule",{value:!0}),Dn.Psbt=void 0;const e=Kg(),t=Zr(),n=Cd(),r=Aa(),a=Wi(),o=wt(),i=Xn(),s=_a(),c=et(),l=zn(),u=Vg(),d=Ls(),h={network:o.bitcoin,maximumFeeRate:5e3};class f{static fromBase64(j,v={}){const p=te.from(j,"base64");return this.fromBuffer(p,v)}static fromHex(j,v={}){const p=te.from(j,"hex");return this.fromBuffer(p,v)}static fromBuffer(j,v={}){const p=e.Psbt.fromBuffer(j,y),m=new f(v,p);return F(m.__CACHE.__TX,m.__CACHE),m}constructor(j={},v=new e.Psbt(new g)){this.data=v,this.opts=Object.assign({},h,j),this.__CACHE={__NON_WITNESS_UTXO_TX_CACHE:[],__NON_WITNESS_UTXO_BUF_CACHE:[],__TX_IN_CACHE:{},__TX:this.data.globalMap.unsignedTx.tx,__UNSAFE_SIGN_NONSEGWIT:!1},this.data.inputs.length===0&&this.setVersion(2);const p=(m,M,G,Z)=>Object.defineProperty(m,M,{enumerable:G,writable:Z});p(this,"__CACHE",!1,!0),p(this,"opts",!1,!0)}get inputCount(){return this.data.inputs.length}get version(){return this.__CACHE.__TX.version}set version(j){this.setVersion(j)}get locktime(){return this.__CACHE.__TX.locktime}set locktime(j){this.setLocktime(j)}get txInputs(){return this.__CACHE.__TX.ins.map(j=>({hash:(0,a.cloneBuffer)(j.hash),index:j.index,sequence:j.sequence}))}get txOutputs(){return this.__CACHE.__TX.outs.map(j=>{let v;try{v=(0,r.fromOutputScript)(j.script,this.opts.network)}catch{}return{script:(0,a.cloneBuffer)(j.script),value:j.value,address:v}})}combine(...j){return this.data.combine(...j.map(v=>v.data)),this}clone(){const j=f.fromBuffer(this.data.toBuffer());return j.opts=JSON.parse(JSON.stringify(this.opts)),j}setMaximumFeeRate(j){x(j),this.opts.maximumFeeRate=j}setVersion(j){x(j),N(this.data.inputs,"setVersion");const v=this.__CACHE;return v.__TX.version=j,v.__EXTRACTED_TX=void 0,this}setLocktime(j){x(j),N(this.data.inputs,"setLocktime");const v=this.__CACHE;return v.__TX.locktime=j,v.__EXTRACTED_TX=void 0,this}setInputSequence(j,v){x(v),N(this.data.inputs,"setInputSequence");const p=this.__CACHE;if(p.__TX.ins.length<=j)throw new Error("Input index too high");return p.__TX.ins[j].sequence=v,p.__EXTRACTED_TX=void 0,this}addInputs(j){return j.forEach(v=>this.addInput(v)),this}addInput(j){if(arguments.length>1||!j||j.hash===void 0||j.index===void 0)throw new Error("Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]");(0,u.checkTaprootInputFields)(j,j,"addInput"),N(this.data.inputs,"addInput"),j.witnessScript&&Fe(j.witnessScript);const v=this.__CACHE;this.data.addInput(j);const p=v.__TX.ins[v.__TX.ins.length-1];O(v,p);const m=this.data.inputs.length-1,M=this.data.inputs[m];return M.nonWitnessUtxo&&pe(this.__CACHE,M,m),v.__FEE=void 0,v.__FEE_RATE=void 0,v.__EXTRACTED_TX=void 0,this}addOutputs(j){return j.forEach(v=>this.addOutput(v)),this}addOutput(j){if(arguments.length>1||!j||j.value===void 0||j.address===void 0&&j.script===void 0)throw new Error("Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]");N(this.data.inputs,"addOutput");const{address:v}=j;if(typeof v=="string"){const{network:m}=this.opts,M=(0,r.toOutputScript)(v,m);j=Object.assign({},j,{script:M})}(0,u.checkTaprootOutputFields)(j,j,"addOutput");const p=this.__CACHE;return this.data.addOutput(j),p.__FEE=void 0,p.__FEE_RATE=void 0,p.__EXTRACTED_TX=void 0,this}extractTransaction(j){if(!this.data.inputs.every(b))throw new Error("Not finalized");const v=this.__CACHE;if(j||_(this,v,this.opts),v.__EXTRACTED_TX)return v.__EXTRACTED_TX;const p=v.__TX.clone();return fe(this.data.inputs,p,v,!0),p}getFeeRate(){return U("__FEE_RATE","fee rate",this.data.inputs,this.__CACHE)}getFee(){return U("__FEE","fee",this.data.inputs,this.__CACHE)}finalizeAllInputs(){return(0,n.checkForInput)(this.data.inputs,0),vt(this.data.inputs.length).forEach(j=>this.finalizeInput(j)),this}finalizeInput(j,v){const p=(0,n.checkForInput)(this.data.inputs,j);return(0,u.isTaprootInput)(p)?this._finalizeTaprootInput(j,p,void 0,v):this._finalizeInput(j,p,v)}finalizeTaprootInput(j,v,p=u.tapScriptFinalizer){const m=(0,n.checkForInput)(this.data.inputs,j);if((0,u.isTaprootInput)(m))return this._finalizeTaprootInput(j,m,v,p);throw new Error(`Cannot finalize input #${j}. Not Taproot.`)}_finalizeInput(j,v,p=V){const{script:m,isP2SH:M,isP2WSH:G,isSegwit:Z}=Y(j,v,this.__CACHE);if(!m)throw new Error(`No script found for input #${j}`);k(v);const{finalScriptSig:ee,finalScriptWitness:le}=p(j,v,m,Z,M,G);if(ee&&this.data.updateInput(j,{finalScriptSig:ee}),le&&this.data.updateInput(j,{finalScriptWitness:le}),!ee&&!le)throw new Error(`Unknown error finalizing input #${j}`);return this.data.clearFinalizedInput(j),this}_finalizeTaprootInput(j,v,p,m=u.tapScriptFinalizer){if(!v.witnessUtxo)throw new Error(`Cannot finalize input #${j}. Missing withness utxo.`);if(v.tapKeySig){const M=i.p2tr({output:v.witnessUtxo.script,signature:v.tapKeySig}),G=(0,d.witnessStackToScriptWitness)(M.witness);this.data.updateInput(j,{finalScriptWitness:G})}else{const{finalScriptWitness:M}=m(j,v,p);this.data.updateInput(j,{finalScriptWitness:M})}return this.data.clearFinalizedInput(j),this}getInputType(j){const v=(0,n.checkForInput)(this.data.inputs,j),p=Ie(j,v,this.__CACHE),m=st(p,j,"input",v.redeemScript||bt(v.finalScriptSig),v.witnessScript||dt(v.finalScriptWitness)),M=m.type==="raw"?"":m.type+"-",G=Ot(m.meaningfulScript);return M+G}inputHasPubkey(j,v){const p=(0,n.checkForInput)(this.data.inputs,j);return _e(v,p,j,this.__CACHE)}inputHasHDKey(j,v){const p=(0,n.checkForInput)(this.data.inputs,j),m=w(v);return!!p.bip32Derivation&&p.bip32Derivation.some(m)}outputHasPubkey(j,v){const p=(0,n.checkForOutput)(this.data.outputs,j);return mt(v,p,j,this.__CACHE)}outputHasHDKey(j,v){const p=(0,n.checkForOutput)(this.data.outputs,j),m=w(v);return!!p.bip32Derivation&&p.bip32Derivation.some(m)}validateSignaturesOfAllInputs(j){return(0,n.checkForInput)(this.data.inputs,0),vt(this.data.inputs.length).map(p=>this.validateSignaturesOfInput(p,j)).reduce((p,m)=>m===!0&&p,!0)}validateSignaturesOfInput(j,v,p){const m=this.data.inputs[j];return(0,u.isTaprootInput)(m)?this.validateSignaturesOfTaprootInput(j,v,p):this._validateSignaturesOfInput(j,v,p)}_validateSignaturesOfInput(j,v,p){const m=this.data.inputs[j],M=(m||{}).partialSig;if(!m||!M||M.length<1)throw new Error("No signatures to validate");if(typeof v!="function")throw new Error("Need validator function to validate signatures");const G=p?M.filter(me=>me.pubkey.equals(p)):M;if(G.length<1)throw new Error("No signatures for this pubkey");const Z=[];let ee,le,we;for(const me of G){const ve=c.signature.decode(me.signature),{hash:Ee,script:Ae}=we!==ve.hashType?D(j,Object.assign({},m,{sighashType:ve.hashType}),this.__CACHE,!0):{hash:ee,script:le};we=ve.hashType,ee=Ee,le=Ae,T(me.pubkey,Ae,"verify"),Z.push(v(me.pubkey,Ee,ve.signature))}return Z.every(me=>me===!0)}validateSignaturesOfTaprootInput(j,v,p){const m=this.data.inputs[j],M=(m||{}).tapKeySig,G=(m||{}).tapScriptSig;if(!m&&!M&&!(G&&!G.length))throw new Error("No signatures to validate");if(typeof v!="function")throw new Error("Need validator function to validate signatures");p=p&&(0,u.toXOnly)(p);const Z=p?se(j,m,this.data.inputs,p,this.__CACHE):W(j,m,this.data.inputs,this.__CACHE);if(!Z.length)throw new Error("No signatures for this pubkey");const ee=Z.find(we=>!we.leafHash);let le=0;if(M&&ee){if(!v(ee.pubkey,ee.hash,re(M)))return!1;le++}if(G)for(const we of G){const me=Z.find(ve=>we.pubkey.equals(ve.pubkey));if(me){if(!v(we.pubkey,me.hash,re(we.signature)))return!1;le++}}return le>0}signAllInputsHD(j,v=[l.Transaction.SIGHASH_ALL]){if(!j||!j.publicKey||!j.fingerprint)throw new Error("Need HDSigner to sign input");const p=[];for(const m of vt(this.data.inputs.length))try{this.signInputHD(m,j,v),p.push(!0)}catch{p.push(!1)}if(p.every(m=>m===!1))throw new Error("No inputs were signed");return this}signAllInputsHDAsync(j,v=[l.Transaction.SIGHASH_ALL]){return new Promise((p,m)=>{if(!j||!j.publicKey||!j.fingerprint)return m(new Error("Need HDSigner to sign input"));const M=[],G=[];for(const Z of vt(this.data.inputs.length))G.push(this.signInputHDAsync(Z,j,v).then(()=>{M.push(!0)},()=>{M.push(!1)}));return Promise.all(G).then(()=>{if(M.every(Z=>Z===!1))return m(new Error("No inputs were signed"));p()})})}signInputHD(j,v,p=[l.Transaction.SIGHASH_ALL]){if(!v||!v.publicKey||!v.fingerprint)throw new Error("Need HDSigner to sign input");return ae(j,this.data.inputs,v).forEach(M=>this.signInput(j,M,p)),this}signInputHDAsync(j,v,p=[l.Transaction.SIGHASH_ALL]){return new Promise((m,M)=>{if(!v||!v.publicKey||!v.fingerprint)return M(new Error("Need HDSigner to sign input"));const Z=ae(j,this.data.inputs,v).map(ee=>this.signInputAsync(j,ee,p));return Promise.all(Z).then(()=>{m()}).catch(M)})}signAllInputs(j,v){if(!j||!j.publicKey)throw new Error("Need Signer to sign input");const p=[];for(const m of vt(this.data.inputs.length))try{this.signInput(m,j,v),p.push(!0)}catch{p.push(!1)}if(p.every(m=>m===!1))throw new Error("No inputs were signed");return this}signAllInputsAsync(j,v){return new Promise((p,m)=>{if(!j||!j.publicKey)return m(new Error("Need Signer to sign input"));const M=[],G=[];for(const[Z]of this.data.inputs.entries())G.push(this.signInputAsync(Z,j,v).then(()=>{M.push(!0)},()=>{M.push(!1)}));return Promise.all(G).then(()=>{if(M.every(Z=>Z===!1))return m(new Error("No inputs were signed"));p()})})}signInput(j,v,p){if(!v||!v.publicKey)throw new Error("Need Signer to sign input");const m=(0,n.checkForInput)(this.data.inputs,j);return(0,u.isTaprootInput)(m)?this._signTaprootInput(j,m,v,void 0,p):this._signInput(j,v,p)}signTaprootInput(j,v,p,m){if(!v||!v.publicKey)throw new Error("Need Signer to sign input");const M=(0,n.checkForInput)(this.data.inputs,j);if((0,u.isTaprootInput)(M))return this._signTaprootInput(j,M,v,p,m);throw new Error(`Input #${j} is not of type Taproot.`)}_signInput(j,v,p=[l.Transaction.SIGHASH_ALL]){const{hash:m,sighashType:M}=H(this.data.inputs,j,v.publicKey,this.__CACHE,p),G=[{pubkey:v.publicKey,signature:c.signature.encode(v.sign(m),M)}];return this.data.updateInput(j,{partialSig:G}),this}_signTaprootInput(j,v,p,m,M=[l.Transaction.SIGHASH_DEFAULT]){const G=this.checkTaprootHashesForSig(j,v,p,m,M),Z=G.filter(le=>!le.leafHash).map(le=>(0,u.serializeTaprootSignature)(p.signSchnorr(le.hash),v.sighashType))[0],ee=G.filter(le=>!!le.leafHash).map(le=>({pubkey:(0,u.toXOnly)(p.publicKey),signature:(0,u.serializeTaprootSignature)(p.signSchnorr(le.hash),v.sighashType),leafHash:le.leafHash}));return Z&&this.data.updateInput(j,{tapKeySig:Z}),ee.length&&this.data.updateInput(j,{tapScriptSig:ee}),this}signInputAsync(j,v,p){return Promise.resolve().then(()=>{if(!v||!v.publicKey)throw new Error("Need Signer to sign input");const m=(0,n.checkForInput)(this.data.inputs,j);return(0,u.isTaprootInput)(m)?this._signTaprootInputAsync(j,m,v,void 0,p):this._signInputAsync(j,v,p)})}signTaprootInputAsync(j,v,p,m){return Promise.resolve().then(()=>{if(!v||!v.publicKey)throw new Error("Need Signer to sign input");const M=(0,n.checkForInput)(this.data.inputs,j);if((0,u.isTaprootInput)(M))return this._signTaprootInputAsync(j,M,v,p,m);throw new Error(`Input #${j} is not of type Taproot.`)})}_signInputAsync(j,v,p=[l.Transaction.SIGHASH_ALL]){const{hash:m,sighashType:M}=H(this.data.inputs,j,v.publicKey,this.__CACHE,p);return Promise.resolve(v.sign(m)).then(G=>{const Z=[{pubkey:v.publicKey,signature:c.signature.encode(G,M)}];this.data.updateInput(j,{partialSig:Z})})}async _signTaprootInputAsync(j,v,p,m,M=[l.Transaction.SIGHASH_DEFAULT]){const G=this.checkTaprootHashesForSig(j,v,p,m,M),Z=[],ee=G.filter(we=>!we.leafHash)[0];if(ee){const we=Promise.resolve(p.signSchnorr(ee.hash)).then(me=>({tapKeySig:(0,u.serializeTaprootSignature)(me,v.sighashType)}));Z.push(we)}const le=G.filter(we=>!!we.leafHash);if(le.length){const we=le.map(me=>Promise.resolve(p.signSchnorr(me.hash)).then(ve=>({tapScriptSig:[{pubkey:(0,u.toXOnly)(p.publicKey),signature:(0,u.serializeTaprootSignature)(ve,v.sighashType),leafHash:me.leafHash}]})));Z.push(...we)}return Promise.all(Z).then(we=>{we.forEach(me=>this.data.updateInput(j,me))})}checkTaprootHashesForSig(j,v,p,m,M){if(typeof p.signSchnorr!="function")throw new Error(`Need Schnorr Signer to sign taproot input #${j}.`);const G=se(j,v,this.data.inputs,p.publicKey,this.__CACHE,m,M);if(!G||!G.length)throw new Error(`Can not sign for input #${j} with the key ${p.publicKey.toString("hex")}`);return G}toBuffer(){return B(this.__CACHE),this.data.toBuffer()}toHex(){return B(this.__CACHE),this.data.toHex()}toBase64(){return B(this.__CACHE),this.data.toBase64()}updateGlobal(j){return this.data.updateGlobal(j),this}updateInput(j,v){return v.witnessScript&&Fe(v.witnessScript),(0,u.checkTaprootInputFields)(this.data.inputs[j],v,"updateInput"),this.data.updateInput(j,v),v.nonWitnessUtxo&&pe(this.__CACHE,this.data.inputs[j],j),this}updateOutput(j,v){const p=this.data.outputs[j];return(0,u.checkTaprootOutputFields)(p,v,"updateOutput"),this.data.updateOutput(j,v),this}addUnknownKeyValToGlobal(j){return this.data.addUnknownKeyValToGlobal(j),this}addUnknownKeyValToInput(j,v){return this.data.addUnknownKeyValToInput(j,v),this}addUnknownKeyValToOutput(j,v){return this.data.addUnknownKeyValToOutput(j,v),this}clearFinalizedInput(j){return this.data.clearFinalizedInput(j),this}}Dn.Psbt=f;const y=ne=>new g(ne);class g{constructor(j=te.from([2,0,0,0,0,0,0,0,0,0])){this.tx=l.Transaction.fromBuffer(j),L(this.tx),Object.defineProperty(this,"tx",{enumerable:!1,writable:!0})}getInputOutputCounts(){return{inputCount:this.tx.ins.length,outputCount:this.tx.outs.length}}addInput(j){if(j.hash===void 0||j.index===void 0||!te.isBuffer(j.hash)&&typeof j.hash!="string"||typeof j.index!="number")throw new Error("Error adding input.");const v=typeof j.hash=="string"?(0,a.reverseBuffer)(te.from(j.hash,"hex")):j.hash;this.tx.addInput(v,j.index,j.sequence)}addOutput(j){if(j.script===void 0||j.value===void 0||!te.isBuffer(j.script)||typeof j.value!="number")throw new Error("Error adding output.");this.tx.addOutput(j.script,j.value)}toBuffer(){return this.tx.toBuffer()}}function S(ne,j,v){switch(v){case"pubkey":case"pubkeyhash":case"witnesspubkeyhash":return I(1,ne.partialSig);case"multisig":const p=i.p2ms({output:j});return I(p.m,ne.partialSig,p.pubkeys);default:return!1}}function B(ne){if(ne.__UNSAFE_SIGN_NONSEGWIT!==!1)throw new Error("Not BIP174 compliant, can not export")}function I(ne,j,v){if(!j)return!1;let p;if(v?p=v.map(m=>{const M=$t(m);return j.find(G=>G.pubkey.equals(M))}).filter(m=>!!m):p=j,p.length>ne)throw new Error("Too many signatures");return p.length===ne}function b(ne){return!!ne.finalScriptSig||!!ne.finalScriptWitness}function w(ne){return j=>!(!j.masterFingerprint.equals(ne.fingerprint)||!ne.derivePath(j.path).publicKey.equals(j.pubkey))}function x(ne){if(typeof ne!="number"||ne!==Math.floor(ne)||ne>4294967295||ne<0)throw new Error("Invalid 32 bit integer")}function _(ne,j,v){const p=j.__FEE_RATE||ne.getFeeRate(),m=j.__EXTRACTED_TX.virtualSize(),M=p*m;if(p>=v.maximumFeeRate)throw new Error(`Warning: You are paying around ${(M/1e8).toFixed(8)} in fees, which is ${p} satoshi per byte for a transaction with a VSize of ${m} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`)}function N(ne,j){ne.forEach(v=>{if((0,u.isTaprootInput)(v)?(0,u.checkTaprootInputForSigs)(v,j):(0,d.checkInputForSig)(v,j))throw new Error("Can not modify transaction, signatures exist.")})}function k(ne){if(!ne.sighashType||!ne.partialSig)return;const{partialSig:j,sighashType:v}=ne;j.forEach(p=>{const{hashType:m}=c.signature.decode(p.signature);if(v!==m)throw new Error("Signature sighash does not match input sighash type")})}function T(ne,j,v){if(!(0,d.pubkeyInScript)(ne,j))throw new Error(`Can not ${v} for this input with the key ${ne.toString("hex")}`)}function L(ne){if(!ne.ins.every(v=>v.script&&v.script.length===0&&v.witness&&v.witness.length===0))throw new Error("Format Error: Transaction ScriptSigs are not empty")}function F(ne,j){ne.ins.forEach(v=>{O(j,v)})}function O(ne,j){const v=(0,a.reverseBuffer)(te.from(j.hash)).toString("hex")+":"+j.index;if(ne.__TX_IN_CACHE[v])throw new Error("Duplicate input detected.");ne.__TX_IN_CACHE[v]=1}function R(ne,j){return(v,p,m,M)=>{const G=ne({redeem:{output:m}}).output;if(!p.equals(G))throw new Error(`${j} for ${M} #${v} doesn't match the scriptPubKey in the prevout`)}}const P=R(i.p2sh,"Redeem script"),K=R(i.p2wsh,"Witness script");function U(ne,j,v,p){if(!v.every(b))throw new Error(`PSBT must be finalized to calculate ${j}`);if(ne==="__FEE_RATE"&&p.__FEE_RATE)return p.__FEE_RATE;if(ne==="__FEE"&&p.__FEE)return p.__FEE;let m,M=!0;if(p.__EXTRACTED_TX?(m=p.__EXTRACTED_TX,M=!1):m=p.__TX.clone(),fe(v,m,p,M),ne==="__FEE_RATE")return p.__FEE_RATE;if(ne==="__FEE")return p.__FEE}function V(ne,j,v,p,m,M){const G=Ot(v);if(!S(j,v,G))throw new Error(`Can not finalize input #${ne}`);return C(v,G,j.partialSig,p,m,M)}function C(ne,j,v,p,m,M){let G,Z;const ee=X(ne,j,v),le=M?i.p2wsh({redeem:ee}):null,we=m?i.p2sh({redeem:le||ee}):null;return p?(le?Z=(0,d.witnessStackToScriptWitness)(le.witness):Z=(0,d.witnessStackToScriptWitness)(ee.witness),we&&(G=we.input)):we?G=we.input:G=ee.input,{finalScriptSig:G,finalScriptWitness:Z}}function H(ne,j,v,p,m){const M=(0,n.checkForInput)(ne,j),{hash:G,sighashType:Z,script:ee}=D(j,M,p,!1,m);return T(v,ee,"sign"),{hash:G,sighashType:Z}}function D(ne,j,v,p,m){const M=v.__TX,G=j.sighashType||l.Transaction.SIGHASH_ALL;z(G,m);let Z,ee;if(j.nonWitnessUtxo){const me=ye(v,j,ne),ve=M.ins[ne].hash,Ee=me.getHash();if(!ve.equals(Ee))throw new Error(`Non-witness UTXO hash for input #${ne} doesn't match the hash specified in the prevout`);const Ae=M.ins[ne].index;ee=me.outs[Ae]}else if(j.witnessUtxo)ee=j.witnessUtxo;else throw new Error("Need a Utxo input item for signing");const{meaningfulScript:le,type:we}=st(ee.script,ne,"input",j.redeemScript,j.witnessScript);if(["p2sh-p2wsh","p2wsh"].indexOf(we)>=0)Z=M.hashForWitnessV0(ne,le,ee.value,G);else if((0,d.isP2WPKH)(le)){const me=i.p2pkh({hash:le.slice(2)}).output;Z=M.hashForWitnessV0(ne,me,ee.value,G)}else{if(j.nonWitnessUtxo===void 0&&v.__UNSAFE_SIGN_NONSEGWIT===!1)throw new Error(`Input #${ne} has witnessUtxo but non-segwit script: ${le.toString("hex")}`);!p&&v.__UNSAFE_SIGN_NONSEGWIT!==!1&&console.warn(`Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`),Z=M.hashForSignature(ne,le,G)}return{script:le,sighashType:G,hash:Z}}function W(ne,j,v,p){const m=[];if(j.tapInternalKey){const G=J(ne,j,p);G&&m.push(G)}if(j.tapScriptSig){const G=j.tapScriptSig.map(Z=>Z.pubkey);m.push(...G)}return m.map(G=>se(ne,j,v,G,p)).flat()}function J(ne,j,v){const{script:p}=xe(ne,j,v);return(0,d.isP2TR)(p)?p.subarray(2,34):null}function re(ne){return ne.length===64?ne:ne.subarray(0,64)}function se(ne,j,v,p,m,M,G){const Z=m.__TX,ee=j.sighashType||l.Transaction.SIGHASH_DEFAULT;z(ee,G);const le=v.map((Ae,Me)=>xe(Me,Ae,m)),we=le.map(Ae=>Ae.script),me=le.map(Ae=>Ae.value),ve=[];if(j.tapInternalKey&&!M){const Ae=J(ne,j,m)||te.from([]);if((0,u.toXOnly)(p).equals(Ae)){const Me=Z.hashForWitnessV1(ne,we,me,ee);ve.push({pubkey:p,hash:Me})}}const Ee=(j.tapLeafScript||[]).filter(Ae=>(0,d.pubkeyInScript)(p,Ae.script)).map(Ae=>{const Me=(0,s.tapleafHash)({output:Ae.script,version:Ae.leafVersion});return Object.assign({hash:Me},Ae)}).filter(Ae=>!M||M.equals(Ae.hash)).map(Ae=>{const Me=Z.hashForWitnessV1(ne,we,me,ee,Ae.hash);return{pubkey:p,hash:Me,leafHash:Ae.hash}});return ve.concat(Ee)}function z(ne,j){if(j&&j.indexOf(ne)<0){const v=de(ne);throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${v}`)}}function X(ne,j,v){let p;switch(j){case"multisig":const m=ce(ne,v);p=i.p2ms({output:ne,signatures:m});break;case"pubkey":p=i.p2pk({output:ne,signature:v[0].signature});break;case"pubkeyhash":p=i.p2pkh({output:ne,pubkey:v[0].pubkey,signature:v[0].signature});break;case"witnesspubkeyhash":p=i.p2wpkh({output:ne,pubkey:v[0].pubkey,signature:v[0].signature});break}return p}function Y(ne,j,v){const p=v.__TX,m={script:null,isSegwit:!1,isP2SH:!1,isP2WSH:!1};if(m.isP2SH=!!j.redeemScript,m.isP2WSH=!!j.witnessScript,j.witnessScript)m.script=j.witnessScript;else if(j.redeemScript)m.script=j.redeemScript;else if(j.nonWitnessUtxo){const M=ye(v,j,ne),G=p.ins[ne].index;m.script=M.outs[G].script}else j.witnessUtxo&&(m.script=j.witnessUtxo.script);return(j.witnessScript||(0,d.isP2WPKH)(m.script))&&(m.isSegwit=!0),m}function ae(ne,j,v){const p=(0,n.checkForInput)(j,ne);if(!p.bip32Derivation||p.bip32Derivation.length===0)throw new Error("Need bip32Derivation to sign with HD");const m=p.bip32Derivation.map(G=>{if(G.masterFingerprint.equals(v.fingerprint))return G}).filter(G=>!!G);if(m.length===0)throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");return m.map(G=>{const Z=v.derivePath(G.path);if(!G.pubkey.equals(Z.publicKey))throw new Error("pubkey did not match bip32Derivation");return Z})}function ce(ne,j){return i.p2ms({output:ne}).pubkeys.map(p=>(j.filter(m=>m.pubkey.equals(p))[0]||{}).signature).filter(p=>!!p)}function oe(ne){let j=0;function v(G){return j+=G,ne.slice(j-G,j)}function p(){const G=t.decode(ne,j);return j+=t.decode.bytes,G}function m(){return v(p())}function M(){const G=p(),Z=[];for(let ee=0;ee<G;ee++)Z.push(m());return Z}return M()}function de(ne){let j=ne&l.Transaction.SIGHASH_ANYONECANPAY?"SIGHASH_ANYONECANPAY | ":"";switch(ne&31){case l.Transaction.SIGHASH_ALL:j+="SIGHASH_ALL";break;case l.Transaction.SIGHASH_SINGLE:j+="SIGHASH_SINGLE";break;case l.Transaction.SIGHASH_NONE:j+="SIGHASH_NONE";break}return j}function pe(ne,j,v){ne.__NON_WITNESS_UTXO_BUF_CACHE[v]=j.nonWitnessUtxo;const p=l.Transaction.fromBuffer(j.nonWitnessUtxo);ne.__NON_WITNESS_UTXO_TX_CACHE[v]=p;const m=ne,M=v;delete j.nonWitnessUtxo,Object.defineProperty(j,"nonWitnessUtxo",{enumerable:!0,get(){const G=m.__NON_WITNESS_UTXO_BUF_CACHE[M],Z=m.__NON_WITNESS_UTXO_TX_CACHE[M];if(G!==void 0)return G;{const ee=Z.toBuffer();return m.__NON_WITNESS_UTXO_BUF_CACHE[M]=ee,ee}},set(G){m.__NON_WITNESS_UTXO_BUF_CACHE[M]=G}})}function fe(ne,j,v,p){let m=0;ne.forEach((ee,le)=>{if(p&&ee.finalScriptSig&&(j.ins[le].script=ee.finalScriptSig),p&&ee.finalScriptWitness&&(j.ins[le].witness=oe(ee.finalScriptWitness)),ee.witnessUtxo)m+=ee.witnessUtxo.value;else if(ee.nonWitnessUtxo){const we=ye(v,ee,le),me=j.ins[le].index,ve=we.outs[me];m+=ve.value}});const M=j.outs.reduce((ee,le)=>ee+le.value,0),G=m-M;if(G<0)throw new Error("Outputs are spending more than Inputs");const Z=j.virtualSize();v.__FEE=G,v.__EXTRACTED_TX=j,v.__FEE_RATE=Math.floor(G/Z)}function ye(ne,j,v){const p=ne.__NON_WITNESS_UTXO_TX_CACHE;return p[v]||pe(ne,j,v),p[v]}function Ie(ne,j,v){const{script:p}=xe(ne,j,v);return p}function xe(ne,j,v){if(j.witnessUtxo!==void 0)return{script:j.witnessUtxo.script,value:j.witnessUtxo.value};if(j.nonWitnessUtxo!==void 0){const m=ye(v,j,ne).outs[v.__TX.ins[ne].index];return{script:m.script,value:m.value}}else throw new Error("Can't find pubkey in input without Utxo data")}function _e(ne,j,v,p){const m=Ie(v,j,p),{meaningfulScript:M}=st(m,v,"input",j.redeemScript,j.witnessScript);return(0,d.pubkeyInScript)(ne,M)}function mt(ne,j,v,p){const m=p.__TX.outs[v].script,{meaningfulScript:M}=st(m,v,"output",j.redeemScript,j.witnessScript);return(0,d.pubkeyInScript)(ne,M)}function bt(ne){if(!ne)return;const j=c.decompile(ne);if(!j)return;const v=j[j.length-1];if(!(!te.isBuffer(v)||Te(v)||Ne(v)||!c.decompile(v)))return v}function dt(ne){if(!ne)return;const j=oe(ne),v=j[j.length-1];if(!(Te(v)||!c.decompile(v)))return v}function $t(ne){if(ne.length===65){const j=ne[64]&1,v=ne.slice(0,33);return v[0]=2|j,v}return ne.slice()}function Te(ne){return ne.length===33&&c.isCanonicalPubKey(ne)}function Ne(ne){return c.isCanonicalScriptSignature(ne)}function st(ne,j,v,p,m){const M=(0,d.isP2SHScript)(ne),G=M&&p&&(0,d.isP2WSHScript)(p),Z=(0,d.isP2WSHScript)(ne);if(M&&p===void 0)throw new Error("scriptPubkey is P2SH but redeemScript missing");if((Z||G)&&m===void 0)throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");let ee;return G?(ee=m,P(j,ne,p,v),K(j,p,m,v),Fe(ee)):Z?(ee=m,K(j,ne,m,v),Fe(ee)):M?(ee=p,P(j,ne,p,v)):ee=ne,{meaningfulScript:ee,type:G?"p2sh-p2wsh":M?"p2sh":Z?"p2wsh":"raw"}}function Fe(ne){if((0,d.isP2WPKH)(ne)||(0,d.isP2SHScript)(ne))throw new Error("P2WPKH or P2SH can not be contained within P2WSH")}function Ot(ne){return(0,d.isP2WPKH)(ne)?"witnesspubkeyhash":(0,d.isP2PKH)(ne)?"pubkeyhash":(0,d.isP2MS)(ne)?"multisig":(0,d.isP2PK)(ne)?"pubkey":"nonstandard"}function vt(ne){return[...Array(ne).keys()]}return Dn}var Pf;function Wg(){return Pf||(Pf=1,(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.initEccLib=e.Transaction=e.opcodes=e.Psbt=e.Block=e.script=e.payments=e.networks=e.crypto=e.address=void 0;const t=Aa();e.address=t;const n=Wt();e.crypto=n;const r=wt();e.networks=r;const a=Xn();e.payments=a;const o=et();e.script=o;var i=vg();Object.defineProperty(e,"Block",{enumerable:!0,get:function(){return i.Block}});var s=Gg();Object.defineProperty(e,"Psbt",{enumerable:!0,get:function(){return s.Psbt}});var c=va();Object.defineProperty(e,"opcodes",{enumerable:!0,get:function(){return c.OPS}});var l=zn();Object.defineProperty(e,"Transaction",{enumerable:!0,get:function(){return l.Transaction}});var u=Ia();Object.defineProperty(e,"initEccLib",{enumerable:!0,get:function(){return u.initEccLib}})})(is)),is}Wg();var Uf;(function(e){e.App="originals:kind:app",e.Agent="originals:kind:agent",e.Module="originals:kind:module",e.Dataset="originals:kind:dataset",e.Media="originals:kind:media",e.Document="originals:kind:document"})(Uf||(Uf={}));var Hf;(function(e){e.PENDING="pending",e.VALIDATING="validating",e.CHECKPOINTED="checkpointed",e.IN_PROGRESS="in_progress",e.ANCHORING="anchoring",e.COMPLETED="completed",e.FAILED="failed",e.ROLLED_BACK="rolled_back",e.QUARANTINED="quarantined"})(Hf||(Hf={}));var Lf;(function(e){e.VALIDATION_ERROR="validation_error",e.STORAGE_ERROR="storage_error",e.BITCOIN_ERROR="bitcoin_error",e.CREDENTIAL_ERROR="credential_error",e.NETWORK_ERROR="network_error",e.ROLLBACK_ERROR="rollback_error",e.TIMEOUT_ERROR="timeout_error",e.UNKNOWN_ERROR="unknown_error"})(Lf||(Lf={}));export{$h as A,zg as B,Zg as D,Kh as M,ln as _,Ff as a,Ci as b,te as c,Uy as d,ip as g,uh as q,Kl as r,dl as s,yl as u,pl as v};
